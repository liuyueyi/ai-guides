const l=JSON.parse('{"key":"v-87e97296","path":"/tutorial/hello-llm/","title":"LLM应用开发","lang":"zh-CN","frontmatter":{"title":"LLM应用开发","icon":"exercise","index":false,"description":"LLM应用开发:零基础也可以入门的大模型应用开发教程 前言 为什么你“会用 LLM”，但做不出复杂应用？ 为什么调得好 Prompt ≠ 系统就稳定？ 为什么多数 Demo 无法上线？ 本书解决什么问题、不解决什么问题 本书的学习路径说明 你需要什么基础？ 每一模块学完你“能做什么” 推荐的学习与实践方式 第一部分｜重新认识 LLM：不是模型问题，而是系统问题","head":[["meta",{"property":"og:url","content":"https://liuyueyi.github.io/ai-guides/tutorial/hello-llm/"}],["meta",{"property":"og:site_name","content":"Helllo LLM Guides"}],["meta",{"property":"og:title","content":"LLM应用开发"}],["meta",{"property":"og:description","content":"LLM应用开发:零基础也可以入门的大模型应用开发教程 前言 为什么你“会用 LLM”，但做不出复杂应用？ 为什么调得好 Prompt ≠ 系统就稳定？ 为什么多数 Demo 无法上线？ 本书解决什么问题、不解决什么问题 本书的学习路径说明 你需要什么基础？ 每一模块学完你“能做什么” 推荐的学习与实践方式 第一部分｜重新认识 LLM：不是模型问题，而是系统问题"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-22T08:45:40.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-22T08:45:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"LLM应用开发\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2026-01-22T08:45:40.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":3,"title":"为什么你“会用 LLM”，但做不出复杂应用？","slug":"为什么你-会用-llm-但做不出复杂应用","link":"#为什么你-会用-llm-但做不出复杂应用","children":[]},{"level":3,"title":"本书的学习路径说明","slug":"本书的学习路径说明","link":"#本书的学习路径说明","children":[]},{"level":2,"title":"第 1 章：LLM 到底在做什么？（程序员版认知重建）","slug":"第-1-章-llm-到底在做什么-程序员版认知重建","link":"#第-1-章-llm-到底在做什么-程序员版认知重建","children":[{"level":3,"title":"1.1 一个反直觉的问题：LLM 真的“理解”语言吗？","slug":"_1-1-一个反直觉的问题-llm-真的-理解-语言吗","link":"#_1-1-一个反直觉的问题-llm-真的-理解-语言吗","children":[]},{"level":3,"title":"1.2 从函数视角理解 LLM","slug":"_1-2-从函数视角理解-llm","link":"#_1-2-从函数视角理解-llm","children":[]},{"level":3,"title":"1.3 你必须接受的事实：LLM 天生不可靠","slug":"_1-3-你必须接受的事实-llm-天生不可靠","link":"#_1-3-你必须接受的事实-llm-天生不可靠","children":[]},{"level":3,"title":"1.4 第一性原理总结","slug":"_1-4-第一性原理总结","link":"#_1-4-第一性原理总结","children":[]}]},{"level":2,"title":"第 2 章：模型不是重点，参数才是你真正的控制面板","slug":"第-2-章-模型不是重点-参数才是你真正的控制面板","link":"#第-2-章-模型不是重点-参数才是你真正的控制面板","children":[{"level":3,"title":"2.1 一个问题：为什么同一个 Prompt 效果忽好忽坏？","slug":"_2-1-一个问题-为什么同一个-prompt-效果忽好忽坏","link":"#_2-1-一个问题-为什么同一个-prompt-效果忽好忽坏","children":[]},{"level":3,"title":"2.2 参数 ≠ 配置，而是策略","slug":"_2-2-参数-配置-而是策略","link":"#_2-2-参数-配置-而是策略","children":[]},{"level":3,"title":"2.3 API 调用的本质结构","slug":"_2-3-api-调用的本质结构","link":"#_2-3-api-调用的本质结构","children":[]}]},{"level":2,"title":"第 3 章：Prompt 为什么会失败？","slug":"第-3-章-prompt-为什么会失败","link":"#第-3-章-prompt-为什么会失败","children":[{"level":3,"title":"3.1 一个常见误区：Prompt 写得越长越好？","slug":"_3-1-一个常见误区-prompt-写得越长越好","link":"#_3-1-一个常见误区-prompt-写得越长越好","children":[]},{"level":3,"title":"3.2 Prompt 的三条工程原则","slug":"_3-2-prompt-的三条工程原则","link":"#_3-2-prompt-的三条工程原则","children":[]}]},{"level":2,"title":"第 4 章：从 Zero-shot 到 Few-shot 的设计思维","slug":"第-4-章-从-zero-shot-到-few-shot-的设计思维","link":"#第-4-章-从-zero-shot-到-few-shot-的设计思维","children":[{"level":3,"title":"4.1 什么时候你真的需要 Few-shot？","slug":"_4-1-什么时候你真的需要-few-shot","link":"#_4-1-什么时候你真的需要-few-shot","children":[]},{"level":3,"title":"4.2 示例驱动 Prompt 的本质","slug":"_4-2-示例驱动-prompt-的本质","link":"#_4-2-示例驱动-prompt-的本质","children":[]}]},{"level":2,"title":"第 5 章：Prompt 模板化与工程落地","slug":"第-5-章-prompt-模板化与工程落地","link":"#第-5-章-prompt-模板化与工程落地","children":[{"level":3,"title":"5.1 为什么 Prompt 必须版本化？","slug":"_5-1-为什么-prompt-必须版本化","link":"#_5-1-为什么-prompt-必须版本化","children":[]},{"level":3,"title":"5.2 通用 Prompt 模板结构","slug":"_5-2-通用-prompt-模板结构","link":"#_5-2-通用-prompt-模板结构","children":[]}]},{"level":2,"title":"第 6 章：上下文窗口的真实边界","slug":"第-6-章-上下文窗口的真实边界","link":"#第-6-章-上下文窗口的真实边界","children":[{"level":3,"title":"6.1 上下文不是“无限内存”","slug":"_6-1-上下文不是-无限内存","link":"#_6-1-上下文不是-无限内存","children":[]},{"level":3,"title":"6.2 为什么长对话一定会崩？","slug":"_6-2-为什么长对话一定会崩","link":"#_6-2-为什么长对话一定会崩","children":[]}]},{"level":2,"title":"第 7 章：三种记忆策略的工程取舍","slug":"第-7-章-三种记忆策略的工程取舍","link":"#第-7-章-三种记忆策略的工程取舍","children":[{"level":3,"title":"7.1 短期记忆：直接塞上下文","slug":"_7-1-短期记忆-直接塞上下文","link":"#_7-1-短期记忆-直接塞上下文","children":[]},{"level":3,"title":"7.2 摘要记忆：用 LLM 管 LLM","slug":"_7-2-摘要记忆-用-llm-管-llm","link":"#_7-2-摘要记忆-用-llm-管-llm","children":[]},{"level":3,"title":"7.3 长期记忆：向量化存储历史","slug":"_7-3-长期记忆-向量化存储历史","link":"#_7-3-长期记忆-向量化存储历史","children":[]}]},{"level":2,"title":"第 8 章：上下文工程（Context Engineering）","slug":"第-8-章-上下文工程-context-engineering","link":"#第-8-章-上下文工程-context-engineering","children":[{"level":3,"title":"8.1 什么信息值得留下？","slug":"_8-1-什么信息值得留下","link":"#_8-1-什么信息值得留下","children":[]},{"level":3,"title":"8.2 信息如何“压缩但不失真”？","slug":"_8-2-信息如何-压缩但不失真","link":"#_8-2-信息如何-压缩但不失真","children":[]},{"level":3,"title":"8.3 结构化上下文设计模式","slug":"_8-3-结构化上下文设计模式","link":"#_8-3-结构化上下文设计模式","children":[]}]},{"level":2,"title":"第 9 章：为什么单靠 LLM 永远不够？","slug":"第-9-章-为什么单靠-llm-永远不够","link":"#第-9-章-为什么单靠-llm-永远不够","children":[{"level":3,"title":"9.1 知识截止的问题","slug":"_9-1-知识截止的问题","link":"#_9-1-知识截止的问题","children":[]},{"level":3,"title":"9.2 无状态的问题","slug":"_9-2-无状态的问题","link":"#_9-2-无状态的问题","children":[]},{"level":3,"title":"9.3 无执行能力的问题","slug":"_9-3-无执行能力的问题","link":"#_9-3-无执行能力的问题","children":[]}]},{"level":2,"title":"第 10 章：Function Calling —— LLM 的“决策大脑”","slug":"第-10-章-function-calling-——-llm-的-决策大脑","link":"#第-10-章-function-calling-——-llm-的-决策大脑","children":[{"level":3,"title":"10.1 模型是如何“选择工具”的？","slug":"_10-1-模型是如何-选择工具-的","link":"#_10-1-模型是如何-选择工具-的","children":[]},{"level":3,"title":"10.2 Schema 设计的关键原则","slug":"_10-2-schema-设计的关键原则","link":"#_10-2-schema-设计的关键原则","children":[]}]},{"level":2,"title":"第 11 章：RAG —— 企业级 LLM 的地基","slug":"第-11-章-rag-——-企业级-llm-的地基","link":"#第-11-章-rag-——-企业级-llm-的地基","children":[{"level":3,"title":"11.1 为什么 RAG 不是“外挂知识库”？","slug":"_11-1-为什么-rag-不是-外挂知识库","link":"#_11-1-为什么-rag-不是-外挂知识库","children":[]},{"level":3,"title":"11.2 RAG 解决的是哪一类问题？","slug":"_11-2-rag-解决的是哪一类问题","link":"#_11-2-rag-解决的是哪一类问题","children":[]},{"level":3,"title":"11.3 文档 → Chunk → Embedding 的关键设计点","slug":"_11-3-文档-→-chunk-→-embedding-的关键设计点","link":"#_11-3-文档-→-chunk-→-embedding-的关键设计点","children":[]},{"level":3,"title":"11.4 检索失败的真实原因","slug":"_11-4-检索失败的真实原因","link":"#_11-4-检索失败的真实原因","children":[]}]},{"level":2,"title":"第 12 章：什么是 Agent？它和 Prompt 的本质区别","slug":"第-12-章-什么是-agent-它和-prompt-的本质区别","link":"#第-12-章-什么是-agent-它和-prompt-的本质区别","children":[{"level":3,"title":"12.1 为什么 CoT ≠ Agent？","slug":"_12-1-为什么-cot-agent","link":"#_12-1-为什么-cot-agent","children":[]},{"level":3,"title":"12.2 ReAct / Plan-Execute 的本质抽象","slug":"_12-2-react-plan-execute-的本质抽象","link":"#_12-2-react-plan-execute-的本质抽象","children":[]}]},{"level":2,"title":"第 13 章：一个 Agent 的最小系统结构","slug":"第-13-章-一个-agent-的最小系统结构","link":"#第-13-章-一个-agent-的最小系统结构","children":[]},{"level":2,"title":"第 14 章：失败的 Agent 都失败在哪？","slug":"第-14-章-失败的-agent-都失败在哪","link":"#第-14-章-失败的-agent-都失败在哪","children":[]},{"level":2,"title":"第 15 章：实战一：可控的多轮对话助手","slug":"第-15-章-实战一-可控的多轮对话助手","link":"#第-15-章-实战一-可控的多轮对话助手","children":[]},{"level":2,"title":"第 16 章：实战二：企业知识库问答系统（RAG）","slug":"第-16-章-实战二-企业知识库问答系统-rag","link":"#第-16-章-实战二-企业知识库问答系统-rag","children":[]},{"level":2,"title":"第 17 章：实战三：工具驱动型 Agent","slug":"第-17-章-实战三-工具驱动型-agent","link":"#第-17-章-实战三-工具驱动型-agent","children":[]}],"git":{"createdTime":1769071540000,"updatedTime":1769071540000,"contributors":[{"name":"wuzebang","email":"bangzewu@126.com","commits":1}]},"readingTime":{"minutes":4.65,"words":1394},"filePathRelative":"tutorial/hello-llm/README.md","localizedDate":"2026年1月22日","excerpt":"<blockquote>\\n<p>LLM应用开发:零基础也可以入门的大模型应用开发教程</p>\\n</blockquote>\\n<h1> 前言</h1>\\n<h3> 为什么你“会用 LLM”，但做不出复杂应用？</h3>\\n<ul>\\n<li>为什么调得好 Prompt ≠ 系统就稳定？</li>\\n<li>为什么多数 Demo 无法上线？</li>\\n<li>本书解决什么问题、不解决什么问题</li>\\n</ul>\\n<h3> 本书的学习路径说明</h3>\\n<ul>\\n<li>你需要什么基础？</li>\\n<li>每一模块学完你“能做什么”</li>\\n<li>推荐的学习与实践方式</li>\\n</ul>\\n<hr>\\n<h1> 第一部分｜重新认识 LLM：不是模型问题，而是系统问题</h1>","copyright":{},"autoDesc":true}');export{l as data};
