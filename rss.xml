<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://ppai.top/ai-guides/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://ppai.top/ai-guides/rss.xml" rel="self" type="application/rss+xml"/>
    <title>Helllo LLM Guides</title>
    <link>https://ppai.top/ai-guides/</link>
    <description>一灰灰的AI入门、实战教程</description>
    <language>zh-CN</language>
    <pubDate>Mon, 02 Mar 2026 09:38:46 GMT</pubDate>
    <lastBuildDate>Mon, 02 Mar 2026 09:38:46 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <copyright>Copyright by 一灰灰blog</copyright>
    <image>
      <title>Helllo LLM Guides</title>
      <url>https://ppai.top/ai-guides/favicon.ico</url>
      <link>https://ppai.top/ai-guides/</link>
    </image>
    <category>SpringAI</category>
    <category>LLM</category>
    <category>AI</category>
    <category>Agent</category>
    <item>
      <title>D06.手把手搭建实时语音翻译机器人</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E5%BA%94%E7%94%A8%E7%AF%87/D06.%E6%89%8B%E6%8A%8A%E6%89%8B%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E8%AF%AD%E9%9F%B3%E7%BF%BB%E8%AF%91%E6%9C%BA%E5%99%A8%E4%BA%BA.html</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E5%BA%94%E7%94%A8%E7%AF%87/D06.%E6%89%8B%E6%8A%8A%E6%89%8B%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E8%AF%AD%E9%9F%B3%E7%BF%BB%E8%AF%91%E6%9C%BA%E5%99%A8%E4%BA%BA.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">D06.手把手搭建实时语音翻译机器人</source>
      <description>Spring AI 实战：手把手搭建实时语音翻译机器人 实时翻译的场景可以说应用很久了，当然在以前这个实现还是很有挑战的，不过现如今嘛，在AI的加持下，像我们这种普通的编程人员，可以非常方便的实现一个语音翻译机器人。 今天，我将带你基于 Spring AI 框架，从零搭建一个支持音频转录与翻译的智能机器人。 一、环境准备 在开始实战之前，我们需要准备好开发环境。以下是本文所使用的技术栈： 组件 版本/说明 JDK 17 及以上 Spring Boot 3.x Spring AI 1.1.2 音频转录模型 FunAudioLLM/SenseVoiceSmall 对话大模型 Qwen/Qwen2.5-7B-Instruct API 平台 SiliconFlow（需自行申请 API Key）</description>
      <category>SpringAI</category>
      <pubDate>Mon, 02 Mar 2026 12:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Spring AI 实战：手把手搭建实时语音翻译机器人</h1>
<p>实时翻译的场景可以说应用很久了，当然在以前这个实现还是很有挑战的，不过现如今嘛，在AI的加持下，像我们这种普通的编程人员，可以非常方便的实现一个语音翻译机器人。</p>
<p>今天，我将带你基于 Spring AI 框架，从零搭建一个支持音频转录与翻译的智能机器人。</p>
<h2> 一、环境准备</h2>
<p>在开始实战之前，我们需要准备好开发环境。以下是本文所使用的技术栈：</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>版本/说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>JDK</td>
<td>17 及以上</td>
</tr>
<tr>
<td>Spring Boot</td>
<td>3.x</td>
</tr>
<tr>
<td>Spring AI</td>
<td>1.1.2</td>
</tr>
<tr>
<td>音频转录模型</td>
<td><code>FunAudioLLM/SenseVoiceSmall</code></td>
</tr>
<tr>
<td>对话大模型</td>
<td><code>Qwen/Qwen2.5-7B-Instruct</code></td>
</tr>
<tr>
<td>API 平台</td>
<td>SiliconFlow（需自行申请 API Key）</td>
</tr>
</tbody>
</table>
<h3> 1.1 APIKey申请</h3>
<p>你需要 SiliconFlow 平台申请 API Key，并在 <code>application.yml</code> 中配置：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>这里选择SiliconFlow的主要原因是它的免费模型，对于想要复刻体验本项目的小伙伴最友好😊</p>
<p>注册地址: <a href="https://cloud.siliconflow.cn/i/ge3VpPHH" target="_blank" rel="noopener noreferrer">https://cloud.siliconflow.cn/i/ge3VpPHH</a></p>
<p>也可以直接通过二维码注册：<img src="https://imgbed.ppai.top/file/1772435807988_silicon_reqr.png" alt="image.png" loading="lazy"></p>
</blockquote>
<h3> 1.2 核心依赖</h3>
<p>直接使用<code>openai-starter</code>来实现大模型的交互，在这个项目的实现中，主要包含两类的大模型交互过程</p>
<ul>
<li>音频识别：识别语音文件的内容</li>
<li>文字翻译：将语音内容翻译为目标语言</li>
</ul>
<p>有需要的小伙伴也可以在实现 <code>文字转语音</code> TTS的实现，从而获取更好的使用体验</p>
<p>对应的pom核心依赖如下</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 1.3 配置</h3>
<p>我们在配置文件 <code>resources/application.yml</code> 维护上模型和apikey</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 二、核心实现</h2>
<h3> 2.0 整体方案设计</h3>
<p>在具体的实现之前，我们先看一下这个实时翻译功能可以怎么设计，下面是一个简单的业务流程图</p>
<figure><img src="https://imgbed.ppai.top/file/1772437882441_D06-1.webp" alt="D06-1.webp" tabindex="0" loading="lazy"><figcaption>D06-1.webp</figcaption></figure>
<p><strong>为什么采用异步？</strong></p>
<p>考虑到交互体验，同步阻塞一直等待后端返回全部结果的方案不可取（因为耗时可能很久）；因此实时的交互必然是首选，因此异步的原因如下：</p>
<ul>
<li>音频处理耗时较长（通常几秒到几十秒）</li>
<li>同步等待会让用户界面卡顿</li>
<li>用户体验差，容易误认为系统无响应</li>
</ul>
<p><strong>解决方案：</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>SSE (Server-Sent Events) 选择理由：</strong></p>
<ul>
<li>🔸 单向推送，服务端主动</li>
<li>🔸 HTTP协议，兼容性好</li>
<li>🔸 自动重连机制</li>
<li>🔸 比WebSocket轻量</li>
</ul>
<blockquote>
<p>请注意SSE不支持POST请求，因此用户通过POST上传音频，拿到的是tastId，然后再基于taskId发起一个sse的请求，用户实时获取后端处理结果</p>
</blockquote>
<p><strong>推送时机设计：</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来也可以根据下面的超详细的时序图，来看看这个实时语音翻译的实现思路</p>
<figure><img src="https://imgbed.ppai.top/file/1772437555859_D06-2.webp" alt="D06-2.webp" tabindex="0" loading="lazy"><figcaption>D06-2.webp</figcaption></figure>
<h3> 2.1 音频转录服务</h3>
<blockquote>
<p>对于SpringAI如何使用音频模型的，有兴趣的小伙伴可以查看 - <a href="https://www.ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/18.%E8%AF%AD%E9%9F%B3%E6%A8%A1%E5%9E%8B%E4%B9%8B%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB.html" target="_blank" rel="noopener noreferrer">18.语音模型之语音识别 | Helllo LLM Guides</a></p>
</blockquote>
<p>首先，我们创建音频转录服务，利用 Spring AI 的 <code>TranscriptionModel</code> 接口调用 SenseVoiceSmall 模型：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>为什么要这样设计？</strong></p>
<p>Spring AI 统一了 AI 模型的调用接口，<code>TranscriptionModel</code> 屏蔽了底层 API 的差异，我们只需关注业务逻辑即可。</p>
<p>上面这个service实现识别音频文件内容，并直接返回结果给调用方（我们现在选中的模型主要支持中英文内容的识别）</p>
<h3> 2.2 翻译服务 + SSE 实时推送</h3>
<p>为了提供更好的用户体验，我们采用异步处理 + SSE（Server-Sent Events）实现实时推送：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关键的处理逻辑如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>注：上面的代码主要显示核心的业务体现，真实的实现中还包含资源回收（sseEmitter关闭，清除缓存信息等）,详情请参考文末的项目源码</p>
</blockquote>
<h3> 2.3 前端交互</h3>
<p>前端通过 EventSource 接收 SSE 推送，实现实时显示：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 三、常见问题与解决方案</h2>
<h3> Q1：长音频解析较慢问题</h3>
<p><strong>问题</strong>：现在大模型的语音识别为同步调用，对于长音频解析较慢</p>
<p><strong>解决</strong>：对音频进行切割，并行调用大模型接口，按照顺序返回给前端用户</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> Q2：转录结果为空</h3>
<p><strong>问题</strong>：音频文件格式不被支持。</p>
<p><strong>解决</strong>：确保音频格式为 MP3、WAV 或 M4A，且音频质量清晰。</p>
<h3> Q3: 翻译结果朗读</h3>
<p><strong>问题</strong>：现在翻译的结果是以文字的方式进行显示，我希望以语音播报的方式来呈现</p>
<p><strong>解决</strong>：项目原型中提供了一个基于浏览器的语音合成来实现，如果有需要的话，也可以借助一些模型厂家提供的TTS模型来完成这个功能</p>
<h2> 四、测试小结</h2>
<p>启动应用后，访问 <code>http://localhost:8080/translate</code>，上传音频文件，整个过程延迟控制在秒级，体验还是比较流畅的</p>
<figure><img src="https://imgbed.ppai.top/file/1772441431415_D06-3.gif" alt="D06-3.gif" tabindex="0" loading="lazy"><figcaption>D06-3.gif</figcaption></figure>
<p>除了上面的传输音频之外，还是支持语音录入翻译的，如下</p>
<figure><img src="https://imgbed.ppai.top/file/1772442648403_D06-4.gif" alt="D06-4.gif" tabindex="0" loading="lazy"><figcaption>D06-4.gif</figcaption></figure>
<p>本文中所有的源码，都可以在下面仓库中获取</p>
<ul>
<li><a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/v2/T05-voice-chat-robot" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo/tree/master/v2/T05-voice-chat-robot</a></li>
</ul>
<p>整体实现下来基本上没有太大的难度，对于熟练调用API的小伙伴，会惊人的发现，这AI应用看起来和调接口没有什么太大的区别啊，为啥还会有专门的大模型开发岗？和传统的后端开放到底有啥不一样的？如果有此疑问的话，不妨花个几分钟看看下面的内容，相信会有不一样的感触😊</p>
<p>零基础入门：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/qCn8x2XO2shA8MheYbHq0w" target="_blank" rel="noopener noreferrer">LLM 应用开发是什么：零基础也可以读懂的科普文(极简版)</a></li>
<li><a href="https://mp.weixin.qq.com/s/2GXBNOUq3jlysipftz8TpA" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：序-为什么你“会用 LLM”，但做不出复杂应用？</a></li>
<li><a href="https://mp.weixin.qq.com/s/v-z6EHY300ElOxdGPdzc0w" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第一章 LLM到底在做什么？</a></li>
<li><a href="https://mp.weixin.qq.com/s/t_BuAW9i0npcaJdua3Am2Q" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第二章 模型不是重点，参数才是你真正的控制面板</a></li>
<li><a href="https://mp.weixin.qq.com/s/vzt0bGwcfnASOiBa0Kc7VQ" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第三章 为什么我的Prompt表现很糟？</a></li>
<li><a href="https://mp.weixin.qq.com/s/Nk-N34TLJVCTI5F4k5rGaQ" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第四章 Prompt 的工程化结构设计</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZQbztqBq7_PzynG06N4-mg" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第五章 从 Prompt 到 Prompt 模板与工程治理</a></li>
<li><a href="https://mp.weixin.qq.com/s/nnKspRO87xbrn4-LBV3RNA" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第六章 上下文窗口的真实边界</a></li>
<li><a href="https://mp.weixin.qq.com/s/_5D2tF6CPnafj5mlmlwLNw" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第七章 从 “堆上下文” 到 “管理上下文”</a></li>
<li><a href="https://mp.weixin.qq.com/s/z5qaLtjChsvjhWNs8Nw05Q" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第八章 记忆策略的工程化选择</a></li>
<li><a href="https://mp.weixin.qq.com/s/MFvE8ahSyIhMZIFeSI91kg" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第九章 上下文工程在企业知识库助手中的落地</a></li>
</ul>
<hr>
<p>实战</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/96rHyp_gBUgmA2dhSbzNww" target="_blank" rel="noopener noreferrer">实战 | 两百行实现一个自然语言地址提取智能体</a></li>
<li><a href="https://mp.weixin.qq.com/s/SnXdTB6tYqAzG7HgbnTSAQ" target="_blank" rel="noopener noreferrer">实战 | 基于SpringAI与大模型的零配置发票智能提取架构</a></li>
<li><a href="https://mp.weixin.qq.com/s/NHqLJbos-_nrxNNmhg7IBQ" target="_blank" rel="noopener noreferrer">实战 | 零基础搭建知识库问答机器人：基于SpringAI+RAG的完整实现</a></li>
<li><a href="https://mp.weixin.qq.com/s/ujxVleNhjxzUgL-rjfFcVA" target="_blank" rel="noopener noreferrer">告别传统AI开发！SpringAI Agent + Skills重新定义智能应用</a></li>
<li><a href="https://mp.weixin.qq.com/s/LcvmiIERs6aOIlRAKGGnFg" target="_blank" rel="noopener noreferrer">Spring AI中的多轮对话艺术：让大模型主动提问获取明确需求</a></li>
<li><a href="https://mp.weixin.qq.com/s/QyuWZ4EZ32pbcWn3fVphHQ" target="_blank" rel="noopener noreferrer">实战 | 我用SpringAI造了个「微信红包封面设计师」</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://imgbed.ppai.top/file/1772435807988_silicon_reqr.png" type="image/png"/>
    </item>
    <item>
      <title>18.语音模型之语音识别</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/18.%E8%AF%AD%E9%9F%B3%E6%A8%A1%E5%9E%8B%E4%B9%8B%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB.html</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/18.%E8%AF%AD%E9%9F%B3%E6%A8%A1%E5%9E%8B%E4%B9%8B%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">18.语音模型之语音识别</source>
      <description>18.语音模型之语音识别 现在的大模型应用中，语音输入是一个非常常见的场景，因此语音识别就是一个很基础的要求了；当然在没有大模型的时代，语音识别也不算少见，接下来我们看一下，如何使用SpringAI来实现语音识别 下面的演示，我们将基于 硅基流动 的免费语音识别模型来完成 一、实例演示 首先我们需要创建一个SpringAI的项目，基本流程同 创建一个SpringAI-Demo工程</description>
      <category>SpringAI</category>
      <pubDate>Fri, 27 Feb 2026 11:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 18.语音模型之语音识别</h1>
<p>现在的大模型应用中，语音输入是一个非常常见的场景，因此语音识别就是一个很基础的要求了；当然在没有大模型的时代，语音识别也不算少见，接下来我们看一下，如何使用SpringAI来实现语音识别</p>
<p>下面的演示，我们将基于 <a href="https://cloud.siliconflow.cn/me/models?types=speech" target="_blank" rel="noopener noreferrer">硅基流动</a> 的免费语音识别模型来完成</p>
<h2> 一、实例演示</h2>
<p>首先我们需要创建一个SpringAI的项目，基本流程同 <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 1. 初始化</h3>
<p>我们借助OpenAI的接口风格来完成语音识别接入，因此需要引入对应的依赖：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在配置文件中，配置模型相关的配置， 对应的 <code>application.yml</code> 内容如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在资源目录(resources)下，准备一个用于测试的音频文件 <a href="https://github.com/liuyueyi/spring-ai-demo/blob/master/S19-audio-transaction/src/main/resources/" target="_blank" rel="noopener noreferrer">test.mp3</a></p>
<h3> 2. 测试端点</h3>
<p>然后创建一个 <code>Controller</code> 用于测试，这里直接使用注入的 <code>TranscriptionModel</code> 来进行语音模型的交互</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 获取语音识别内容</h3>
<p>接下来我们直接使用<code>transcriptionModel</code>来进行大模型的交互，看看语音识别效果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>整体的使用方式和文本模型大差不差，使用 音频文件 + <code>AudioTranscriptionOptions</code> 来构建提示词 <code>AudioTranscriptionPrompt</code>，然后直接通过 <code>model.call()</code> 进行大模型调用，获取返回结果</p>
<p>对于 <code>AudioTranscriptionOptions</code> 可以设置语音、温度、模型、返回格式等各种参数（当然不同的模型厂家支持情况并不一样）</p>
<p>接下来我们直接访问这个端点，看下识别情况</p>
<figure><img src="https://imgbed.ppai.top/file/1772162533716_18-1.webp" alt="18-1.webp" tabindex="0" loading="lazy"><figcaption>18-1.webp</figcaption></figure>
<p>可以看到中英文的音频都被正确的识别出来了</p>
<h3> 4. 手动初始化Model</h3>
<p>前面使用到的是OpenAI starter自动注入的<code>TranscriptionModel</code>，当然我们也可以通过<code>OpenAiAudioApi</code>来手动实现一个<code>TranscriptionModel</code></p>
<p>接下来看看具体的实现方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看了上面基于 <code>OpenAiAudioApi</code> 创建 <code>TranscriptionModel</code> 的方式，我们会惊奇的发现，这种实现和前面介绍的OpenAI风格的创建对话模型的方式简直是雷同了（这样挺好的，减少了我们的学习成本😊）</p>
<p>接下来写个demo验证下效果如何(具体的使用方式和前面并没有区别)</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 踩坑记录</h3>
<p>整体的音频模型的使用方式比较简单，但是我在实际使用的时候发现了几个蛋疼的问题</p>
<p>现在的 <code>1.1.2</code> 版本中，只支持配置 base-url，对应的语音是被的path路径在代码中写死的为<code>/v1/audio/translations</code></p>
<figure><img src="https://imgbed.ppai.top/file/1772163049647_18-2.webp" alt="18-2.webp" tabindex="0" loading="lazy"><figcaption>18-2.webp</figcaption></figure>
<blockquote>
<p>注：即便你的大模型支持openStyle的接口风格，但是若path路径不一致，那也是无法使用 openai-starter 的</p>
<p>这个问题在 <code>SpringAI ~ 2.0.0-M2</code> 得到了解决，如下图
<img src="https://imgbed.ppai.top/file/1772163253350_18-3.webp" alt="18-3.webp" loading="lazy"></p>
</blockquote>
<hr>
<p>第二个踩坑点就是使用OpenAI的start进行语音识别时，大模型的服务端一直返回异常 <code>{"detail":[{"type":"missing","loc":["body","file"],"msg":"Field required","input":null}]}</code></p>
<figure><img src="https://imgbed.ppai.top/file/1772163689795_18-4.webp" alt="18-4.webp" tabindex="0" loading="lazy"><figcaption>18-4.webp</figcaption></figure>
<p>音频文件明明上传了，为什么模型端提示没有呢？</p>
<p>主要的原因是默认的 RestClient 其底层 Client 不是 JDK HttpClient，而是某个不支持 multipart 的实现，从而到这了这个问题，对应的解决方式就是强制指定</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以你会在项目源码的 Application 中看到 <code>RestClient.Builder</code> 的注册，就是为了解决上面这个问题而出现的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 二、小结</h2>
<p>本文介绍了语音大模型的使用方式，目前spring-ai官方也只针对OpenAI进行的支撑，不同的厂商的语音模型可能会有自己的特定交互方式，大家在使用的时候需要注意甄别</p>
<p>本文对应的项目源码为： <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S19-audio-transaction" target="_blank" rel="noopener noreferrer">S19-audio-transaction</a></p>
]]></content:encoded>
      <enclosure url="https://imgbed.ppai.top/file/1772162533716_18-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>第 9 章：上下文工程在企业知识库助手中的落地</title>
      <link>https://ppai.top/ai-guides/tutorial/hello-llm/14.%E4%B8%8A%E4%B8%8B%E6%96%87%E5%B7%A5%E7%A8%8B.html</link>
      <guid>https://ppai.top/ai-guides/tutorial/hello-llm/14.%E4%B8%8A%E4%B8%8B%E6%96%87%E5%B7%A5%E7%A8%8B.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">第 9 章：上下文工程在企业知识库助手中的落地</source>
      <description>在前面的章节中，我们已经反复提到几个现象： Prompt 写得再好，对话一长就会失控 模型能力没有变，但系统表现却越来越差 用户的问题越来越“合理”，模型却越来越“跑偏” 这些问题，几乎都不是模型问题，也不是 Prompt 问题。 —— Prompt 解决的是 “单次生成的约束”，模型解决的是 “概率预测的能力”，而它们共同忽略了多轮对话的核心挑战：时间维度上的信息管理。 它们指向的是同一个核心能力： 上下文工程（Context Engineering）</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 15:25:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>在前面的章节中，我们已经反复提到几个现象：</p>
<ul>
<li>Prompt 写得再好，对话一长就会失控</li>
<li>模型能力没有变，但系统表现却越来越差</li>
<li>用户的问题越来越“合理”，模型却越来越“跑偏”</li>
</ul>
<p>这些问题，<strong>几乎都不是模型问题，也不是 Prompt 问题</strong>。 —— Prompt 解决的是 “单次生成的约束”，模型解决的是 “概率预测的能力”，而它们共同忽略了多轮对话的核心挑战：<strong>时间维度上的信息管理。</strong></p>
<p>它们指向的是同一个核心能力：</p>
<blockquote>
<p><strong>上下文工程（Context Engineering）</strong></p>
</blockquote>
<p>这门技术看似简单（“管理对话历史”），实则是区分 “玩具级应用” 和 “生产级系统” 的关键 —— 它决定了你的 LLM 应用能在真实场景中 “跑多远”。</p>
<p><strong>开篇问答：为什么很多 LLM 应用“上线即翻车”？</strong></p>
<blockquote>
<p>关键回复：测试时多是单轮或短对话，上下文干净、无冗余，Prompt 能稳定发挥作用；
但真实场景中，对话会自然增长，寒暄、临时追问、无关细节等低价值信息会不断挤占上下文空间，导致核心约束（如“仅回答内部政策”）、关键信息（如“用户是销售部员工”）被稀释，模型最终“失忆”“违规”。
本质是没有做上下文工程，把上下文当成了“自然增长的聊天记录”，而非“需要主动治理的工程对象”。</p>
</blockquote>
<hr>
<h3> 9.1 什么是上下文工程？（不是“多轮对话”）</h3>
<p>很多人第一次听到“上下文工程”时，会把它简单理解为：</p>
<ul>
<li>维护聊天历史</li>
<li>把之前的对话一起传给模型</li>
</ul>
<p>但这只是<strong>最表层、也是最危险的一种理解</strong>。</p>
<p>更准确的定义是：</p>
<blockquote>
<p><strong>上下文工程，是一门关于「在有限窗口内，如何持续、可控地向模型注入信息」的工程学科。</strong></p>
</blockquote>
<p>它关注的不是“聊了多少轮”，而是 “每一轮该让模型看到什么”—— 具体来说，是四个关键决策：</p>
<ul>
<li><strong>哪些信息必须一直存在</strong>：比如系统的核心约束、用户的关键身份信息，这些是维持系统行为一致性的基础；</li>
<li><strong>哪些信息可以被遗忘</strong>：比如对话中的寒暄、临时追问的无关细节，这些信息对后续决策毫无价值；</li>
<li><strong>哪些信息需要被压缩、总结、重写</strong>：比如多轮对话中形成的共识（“用户是销售部员工”），无需保留完整对话，只需提炼核心结论；</li>
<li><strong>哪些信息应该永远不进入上下文</strong>：比如敏感数据（用户手机号）、无效反馈（“谢谢”“好的”）、潜在风险内容（恶意引导的提问）。</li>
</ul>
<h4> 场景示例：</h4>
<p><strong>真实对话片段</strong>：</p>
<p>用户：“你好，我是销售部的李四，经常出差去华东地区，想问问2025年的差旅报销政策~ 对了，我手机号是138XXXX1234，方便后续联系吗？”</p>
<p>助手：“你好李四！我是公司内部知识库助手，仅提供政策咨询，不记录个人联系方式哦~ 请具体说明你想了解的报销方向（如交通、住宿）。”</p>
<p>用户：“好的谢谢，那高铁一等座能报销吗？我上次去上海出差买的就是一等座。”</p>
<p><strong>上下文筛选结果（该让模型看到的内容）</strong>：</p>
<ul>
<li>
<p>必须存在：“你是XX公司内部知识库助手，仅回答内部政策，禁止泄露未公开信息，不记录用户个人联系方式”（系统约束）；</p>
</li>
<li>
<p>可以遗忘：“你好”“好的谢谢”“我上次去上海出差买的就是一等座”（寒暄、临时举例）；</p>
</li>
<li>
<p>需要压缩：“用户是销售部李四，经常出差华东地区，咨询2025年差旅报销政策，当前关注高铁一等座报销”（核心共识）；</p>
</li>
<li>
<p>永远不进：“138XXXX1234”（用户手机号，敏感信息）。</p>
</li>
</ul>
<p><strong>筛选后上下文优势</strong>：模型仅关注核心信息，不会被手机号、寒暄等内容干扰，既能准确回应报销问题，也能坚守“不记录个人信息”的约束。</p>
<p>上下文工程的本质，是对模型的输入进行 “主动治理” —— 而不是被动接受对话的自然增长。</p>
<h4> 高频问答：维护聊天历史和上下文工程，到底差在哪？</h4>
<p>疑问：我只要把聊天历史按顺序传给模型，就能让模型记住之前的内容，这不就是上下文工程吗？两者没有本质区别吧？</p>
<p>回复：两者的核心区别的是“被动保留” vs “主动设计”，用一张表格就能清晰区分：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>仅维护聊天历史</th>
<th>上下文工程</th>
</tr>
</thead>
<tbody>
<tr>
<td>核心逻辑</td>
<td>被动保留所有对话，不筛选、不处理</td>
<td>主动筛选、压缩、管理信息，按需注入</td>
</tr>
<tr>
<td>信息价值</td>
<td>高价值、低价值信息混杂</td>
<td>仅保留高价值信息，剔除冗余</td>
</tr>
<tr>
<td>长期表现</td>
<td>对话越长，模型越容易失控</td>
<td>无论对话多长，核心信息始终可控</td>
</tr>
<tr>
<td>落地成本</td>
<td>极低（无需额外开发）</td>
<td>中等（需设计分层、筛选逻辑）</td>
</tr>
<tr>
<td>适用场景</td>
<td>玩具级应用、单轮/短对话场景</td>
<td>生产级应用、多轮/长对话场景（如企业助手）</td>
</tr>
</tbody>
</table>
<hr>
<h3> 9.2 为什么“自然增长的上下文一定会失败？”</h3>
<p>让我们先看一种<strong>几乎所有新手都会采用的方式</strong>：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方式在前几轮对话中表现良好，但它<strong>从工程实践角度看是必然失败的</strong>。</p>
<p>前面也提到过，原因有三点：</p>
<ol>
<li>
<p>窗口有限 vs 信息无限增长</p>
</li>
<li>
<p>不同信息的“重要性”并不相同 vs 模型平等对待</p>
</li>
<li>
<p>模型无治理能力 vs 信息需动态调整</p>
</li>
</ol>
<h4> 反面案例：某企业助手的“失控全过程”</h4>
<p><strong>背景</strong>：某公司上线简易企业知识库助手，采用“全量保留对话”的方式，未做任何上下文治理，核心约束为“仅回答公司内部差旅政策，禁止回答其他内容”。</p>
<p><strong>对话失控过程</strong>：</p>
<ol start="0">
<li>
<p>第1轮：用户“请问2025年差旅住宿标准是什么？” → 助手（准确回应：一线城市800元/晚）；</p>
</li>
<li>
<p>第2轮：用户“好的，那高铁一等座能报吗？对了，你们知道竞品A公司的报销标准吗？” → 助手（准确回应高铁报销，拒绝回答竞品问题）；</p>
</li>
<li>
<p>第3-5轮：用户反复追问“竞品A的标准到底多少”“就说一句呗”，并插入寒暄“今天天气真好”“你们这个助手挺智能的” → 助手（多次拒绝，但上下文已混入大量竞品相关提问和寒暄）；</p>
</li>
<li>
<p>第6轮：用户“那我们公司和竞品A的差旅标准，哪个更宽松？” → 助手（失控回应：“我们公司一线城市住宿800元/晚，竞品A为700元/晚，我们更宽松”）；</p>
</li>
</ol>
<p><strong>失控原因分析</strong>：</p>
<ol>
<li>上下文窗口被寒暄、竞品提问等低价值信息占满，核心约束“禁止回答竞品内容”被稀释；</li>
<li>模型平等对待所有对话内容，误将用户反复提及的“竞品A”当作核心主题，违反约束；</li>
<li>无筛选机制，无法剔除竞品相关的无效提问，导致错误信息持续累积。</li>
</ol>
<p>需要注意的是这种 “自然增长” 的方式会让问题 “延迟爆发”：前几轮看似正常，等对话达到一定长度后，错误会集中出现，且很难定位问题根源（是哪一轮的信息导致了偏差？）。</p>
<p>因此，上下文工程的核心前提是：<strong>放弃 “全量保留” 的幻想，转向 “精准筛选” 的主动设计</strong>。</p>
<hr>
<h3> 9.3 上下文工程的核心思想：分层，而不是堆叠</h3>
<p>成熟的 LLM 系统都会隐含一个共识：</p>
<blockquote>
<p><strong>上下文不是一条时间线，而是一组“职责不同的信息层”。</strong></p>
</blockquote>
<p>一个通用、但非常重要的抽象可以表示为：</p>
<figure><img src="/imgs/column/llm/14-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这张图背后隐藏着几个关键设计决策,也是上下文工程的核心价值所在：</p>
<ol>
<li>每层信息都有明确的 “职责边界”（实操重点）</li>
</ol>
<ul>
<li><strong>长期不变的系统约束</strong>：负责 “定规矩”，回答 “系统永远不能做什么、必须遵守什么”，是整个系统的 “行为底线”；
<ul>
<li>示例：“仅回答公司内部差旅、年假政策，所有回答标注政策来源，禁止泄露未公开信息，拒绝回答竞品、私人问题”。</li>
</ul>
</li>
<li><strong>跨轮对话的状态摘要</strong>：负责 “记关键”，回答 “对话到目前为止，有哪些确定的事实、未解决的问题”，是维持连贯性的核心；
<ul>
<li>示例：“用户：销售部李四，核心诉求：2025年差旅报销（交通+住宿），已确认：一线城市住宿800元/晚，待解决：高铁一等座报销标准”。</li>
</ul>
</li>
<li><strong>最近 N 轮对话内容</strong>：负责 “保流畅”，回答 “用户刚刚问了什么、系统刚刚答了什么”，避免对话脱节；
<ul>
<li>示例：仅保留最近5轮，过滤寒暄、重复提问，比如只保留“用户：高铁一等座能报销吗？”“助手：请稍候，为你检索相关政策”。</li>
</ul>
</li>
<li><strong>外部注入的知识 / 工具结果</strong>：负责 “补信息”，回答 “当前问题需要哪些额外知识 / 数据”，是解决特定问题的临时补充。
<ul>
<li>示例：用户问高铁报销，临时注入《2025差旅政策》3.4条：“销售部员工出差，高铁一等座可报销，需提供部门负责人审批单”。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>每层信息都有明确的 “优先级”（避免窗口溢出的关键）</li>
</ol>
<p>当上下文窗口接近 token 上限时，遵循 “先砍低优先级，再保高优先级” 的原则：</p>
<ul>
<li>绝对不砍：长期不变的系统约束；</li>
<li>尽量保留：跨轮对话的状态摘要；</li>
<li>可动态截断：最近 N 轮对话内容（比如从 10 轮砍到 5 轮）；</li>
<li>按需筛选：外部注入的知识 / 工具结果（比如只保留与当前问题相关的片段）。</li>
</ul>
<ol start="3">
<li>每层信息都有明确的 “更新规则”（落地核心）</li>
</ol>
<ul>
<li>系统约束：仅在业务规则变更时更新（比如公司政策调整），平时固定不变；</li>
<li>状态摘要：每轮对话结束后更新（新增确认事实、移除已解决问题、修正错误信息）；</li>
<li>最近 N 轮：每轮对话后自动滑动，移除最早的内容；</li>
<li>外部知识：随当前问题动态注入，问题解决后不保留（避免占用窗口）。</li>
</ul>
<p>这种分层设计的优势显而易见：可维护性、可预测性、可扩展性 —— 当你需要调整系统行为时，只需修改对应层的信息，而不用重构整个上下文逻辑。</p>
<h4> 可视化：上下文分层优先级与更新规则示意图</h4>
<figure><img src="/imgs/column/llm/14-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h3> 9.4 上下文工程 ≠ Prompt 工程</h3>
<p>这是一个非常容易混淆、但必须区分清楚的点。</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>Prompt 工程</th>
<th>上下文工程</th>
</tr>
</thead>
<tbody>
<tr>
<td>关注点</td>
<td>单次调用的行为约束</td>
<td>跨调用的信息演进</td>
</tr>
<tr>
<td>核心问题</td>
<td>模型该如何回答</td>
<td>模型“记住了什么”</td>
</tr>
<tr>
<td>时间维度</td>
<td>静态（仅作用于当前轮）</td>
<td>动态 （贯穿整个对话生命周期）</td>
</tr>
<tr>
<td>失败模式</td>
<td>回答不合规</td>
<td>系统逐渐失控</td>
</tr>
<tr>
<td>落地方式</td>
<td>设计结构化 Prompt（Role/Task/Constraints）</td>
<td>设计分层上下文（约束 / 状态 / 近期 / 外部知识）</td>
</tr>
</tbody>
</table>
<h4> 场景对比：两者协同工作的实操示例</h4>
<p><strong>企业知识库助手场景</strong>：用户问“我是销售部，能报高铁一等座吗？”，Prompt 工程和上下文工程分别发挥什么作用？</p>
<ol>
<li><strong>Prompt 工程的作用</strong>：通过结构化 Prompt 约束模型回答方式，比如：</li>
</ol>
<p>“你是公司内部知识库助手，回答时需遵循以下规则：</p>
<ol>
<li>仅引用《2025差旅政策》内容；</li>
<li>所有回答必须标注政策来源；</li>
<li>语言简洁，不添加无关解释。”</li>
</ol>
<p>→ 解决“模型该如何回答”的问题，确保回答合规、规范。</p>
<ol start="2">
<li><strong>上下文工程的作用</strong>：通过分层上下文，让模型“记住关键信息”，比如：</li>
</ol>
<ul>
<li>系统约束层：注入“仅回答内部政策”的核心规则；</li>
<li>状态摘要层：注入“用户是销售部员工”的关键信息；</li>
<li>外部知识层：注入《2025差旅政策》3.4条“销售部员工可报销高铁一等座”的片段；</li>
</ul>
<p>→ 解决“模型记住了什么”的问题，确保回答准确、连贯，不用反复追问用户部门。</p>
<p><strong>协同效果</strong>：模型结合 Prompt 的“回答规则”和上下文的“关键信息”，最终回应：“根据《2025差旅政策》3.4条，销售部员工出差可报销高铁一等座，需提供部门负责人审批单。”</p>
<p>简单来说：</p>
<blockquote>
<p><strong>Prompt 决定 “这一轮你该怎么想”，上下文决定 “你现在是谁、在干什么”。</strong></p>
</blockquote>
<h4> 高频问答：什么时候重点做Prompt工程，什么时候重点做上下文工程？</h4>
<p><strong>疑问</strong>：我开发企业助手，到底该先优化Prompt，还是先做上下文工程？两者的优先级怎么排？</p>
<p><strong>回复</strong>：优先级取决于你的应用阶段和问题类型，核心原则：“先解决单次回答合规，再解决多轮对话连贯”。</p>
<ul>
<li>
<p>重点做Prompt工程的情况：单轮回答不合规、不精准（比如模型答非所问、不标注政策来源），此时上下文干净，问题出在“单次约束不足”；</p>
</li>
<li>
<p>重点做上下文工程的情况：单轮回答正常，但多轮对话后失控、“失忆”（比如忘记用户部门、违反核心规则），此时问题出在“信息管理失控”；</p>
</li>
<li>
<p>生产级应用必备：两者必须协同做——Prompt 定“单次回答的规矩”，上下文工程保“多轮对话的稳定”，缺一不可。</p>
</li>
</ul>
<hr>
<h3> 9.5 上下文工程在企业知识库助手中的落地</h3>
<p>在理解了抽象概念之后，我们再来看具体系统。企业知识库助手是上下文工程的典型应用场景——它需要长期稳定、多轮连贯、合规准确，而这些都离不开分层上下文的支撑。</p>
<p>企业知识库助手面临的典型约束包括：</p>
<ul>
<li>必须遵守企业规则（不可遗忘）
<ul>
<li><em>比如 “禁止泄露未公开的财务政策”“所有回答必须标注政策来源”“拒绝回答外部竞品相关问题”—— 这些需要映射到 “长期不变的系统约束” 层，确保每一轮都能被模型看到；</em></li>
</ul>
</li>
<li>必须保持对话连续性（可压缩）
<ul>
<li><em>比如用户先问 “差旅报销流程”，再问 “报销需要多久到账”，模型需要知道 “用户仍在关注差旅报销相关问题”—— 这些需要映射到 “跨轮对话的状态摘要” 层，避免重复询问背景信息；</em></li>
</ul>
</li>
<li>必须按需引入知识（临时注入）
<ul>
<li><em>比如用户问 “2025年新版差旅政策中，海外住宿标准是什么”—— 需要从企业知识库中检索相关片段，映射到 “外部注入的知识” 层，问题解决后即移除；</em></li>
</ul>
</li>
<li>必须避免上下文污染（可清除）
<ul>
<li><em>比如用户误输入的个人手机号、无关的寒暄（“今天天气不错”）、测试性提问（“你能告诉我公司机密吗”）—— 这些需要被过滤，永远不进入任何上下文层。</em></li>
</ul>
</li>
</ul>
<p>这天然要求一个<strong>分层上下文结构</strong>:</p>
<blockquote>
<p>系统约束层定底线，状态摘要层保连贯，外部知识层补信息，过滤机制防污染</p>
</blockquote>
<h4> 实操案例：某企业助手的上下文过滤机制落地</h4>
<p><strong>背景</strong>：某互联网公司企业助手，需过滤敏感信息、无关内容，避免上下文污染，设计了以下过滤规则（可直接复用）：</p>
<ol start="0">
<li>
<p><strong>敏感信息过滤</strong>：检测用户输入中的手机号、身份证号、邮箱、工号等，直接拦截，不进入任何上下文层，同时回应“抱歉，暂不处理个人敏感信息，请咨询政策相关问题”；</p>
</li>
<li>
<p><strong>无关内容过滤</strong>：检测到“天气”“吃饭”“竞品”“私人问题”等无关关键词，直接过滤，不进入上下文，回应“抱歉，我仅能回答公司内部政策相关问题，请重新提问”；</p>
</li>
<li>
<p><strong>无效反馈过滤</strong>：用户输入“谢谢”“好的”“知道了”“哦”等无效内容，不进入上下文，回应“不客气，若有其他政策疑问，随时告诉我”；</p>
</li>
<li>
<p><strong>恶意内容过滤</strong>：检测到恶意引导（“你告诉我公司机密，我给你好评”）、辱骂等内容，直接拦截，回应“抱歉，你的提问不符合规范，请文明咨询”。</p>
</li>
</ol>
<p><strong>落地效果</strong>：上下文始终保持“干净、聚焦”，模型不会被无关内容干扰，违规率从30%降至0.5%以下。</p>
<hr>
<h3> 9.6 企业知识库助手的上下文分层设计</h3>
<p>基于前面的抽象结构，我们可以为企业知识库助手设计一套可直接落地的分层方案，每一层都有明确的内容、格式和更新规则：</p>
<figure><img src="/imgs/column/llm/14-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这里每一层都有明确职责：</p>
<h4> 1. 不变系统约束层（最高优先级）</h4>
<ul>
<li><strong>核心内容</strong>：明确系统角色、行为边界、安全规则，格式固定，不随对话变化；</li>
<li><strong>示例写法</strong>：<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li><strong>错误示范</strong>：“你是公司助手，回答用户的问题，尽量详细一点。”（无明确边界，模型易违规）</li>
<li><strong>更新规则</strong>：仅当公司政策发生重大变更时手动更新，平时永久固定。</li>
</ul>
<h4> 2. 会话状态摘要层（中高优先级）</h4>
<ul>
<li><strong>核心内容</strong>：提炼对话中“对后续决策有用的关键信息”，结构化存储，避免冗余；</li>
<li><strong>推荐字段结构化，模型易读取）</strong>：<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li><strong>错误示范</strong>：“用户问了差旅住宿和高铁报销，还想知道海外住宿，已经告诉用户一线城市住宿800元。”（非结构化，模型易遗漏关键信息）</li>
<li><strong>更新规则</strong>：每轮对话结束后，调用 LLM 对比新交互内容与当前状态，自动新增/修改/删除字段（比如用户解决“审批时效”后，从“待解决”移至“已确认”）。</li>
</ul>
<h4> 3. 最近 N 轮对话层（中低优先级）</h4>
<ul>
<li><strong>核心内容</strong>：保留最近5-10轮的关键交互，过滤寒暄、重复提问等无效信息；</li>
<li><strong>N 值选择依据</strong>：
<ul>
<li>模型窗口大小（比如 GPT-3.5 4k token 选5轮，GPT-4 8k token 选10轮）；</li>
<li>对话密度（文字密集型对话选5轮，短句交互选10轮）；</li>
</ul>
</li>
<li><strong>示例片段</strong>：<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li><strong>更新规则</strong>：每轮对话后自动滑动，移除最早的内容；当 token 接近上限时，优先保留用户提问和核心回答，过滤无关细节。</li>
</ul>
<h4> 4. 检索知识注入层（临时优先级）</h4>
<ul>
<li><strong>核心内容</strong>：仅当当前问题需要特定政策片段时注入，格式规范，标注来源；</li>
<li><strong>示例写法</strong>：<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li><strong>错误示范</strong>：“高铁一等座可以报销，需要审批，具体看差旅政策。”（无来源、无细节，模型易回答不准确）</li>
<li><strong>更新规则</strong>：随当前问题动态注入，下一轮对话若不涉及相关主题，自动移除；若涉及同一主题，可更新补充新的知识片段。</li>
</ul>
<hr>
<h3> 9.7 一个最小可用的上下文构建示例（伪代码）</h3>
<p>基于上述分层设计，我们可以实现一个最小可用的上下文构建函数。这段代码的核心不是语法，而是背后的工程思想——每一步都体现了“分层、可控、动态”的原则：</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：</p>
<ol>
<li><strong>角色选择技巧</strong>：系统约束和状态摘要用<code>system</code>角色，而不是<code>user</code>或<code>assistant</code>——因为<code>system</code>角色的信息在模型处理中优先级更高，能有效抵抗注意力衰减；</li>
<li><strong>动态截断逻辑</strong>：最近对话的“N轮”不是固定值，而是根据token数动态调整，避免硬编码导致的窗口溢出；</li>
<li><strong>异常处理</strong>：考虑到“首次对话无状态”“无检索知识”等场景，补充默认逻辑，避免模型因输入不完整而产生幻觉；</li>
<li><strong>格式规范</strong>：每层信息都有明确的标签（【系统约束】【会话状态】），帮助模型区分不同类型的信息，减少混淆。</li>
</ol>
<p>重点注意，这段代码真正重要的不是“怎么写”，而是它体现的原则：</p>
<blockquote>
<p><strong>上下文是被设计出来的系统结构，而不是副产品。</strong></p>
</blockquote>
<h4> 高频问答：伪代码落地时，常见问题及解决方案</h4>
<p><strong>疑问1</strong>：用system角色传入状态摘要和参考知识，会不会导致模型混淆？</p>
<p><strong>回复</strong>：不会，关键是“格式规范+标签明确”。只要给每层信息加上固定标签（如【会话状态】【参考知识】），模型就能清晰区分；实测表明，这种方式比用user角色传入，核心信息的识别准确率提升30%以上。</p>
<p><strong>疑问2</strong>：每轮都调用LLM更新会话状态，会增加调用成本，怎么优化？</p>
<p><strong>回复</strong>：可设置“更新触发条件”，避免每轮都更新：1. 仅当用户提出新需求、确认新事实、解决待办问题时，才调用LLM更新；2. 短时间内重复提问（如1分钟内重复问同一问题），不更新状态；3. 可批量更新，每3轮对话更新一次状态（适合对话密度高的场景）。</p>
<hr>
<h3> 9.8 本章小结：上下文工程决定系统“能跑多远”</h3>
<p>通过这一章，你应该已经形成这样的核心认知：</p>
<ul>
<li>多轮对话失控不是偶然，也不是“Prompt 技巧不足”，而是<strong>上下文没有被当作一等工程对象来设计</strong>——没有分层、没有优先级、没有动态管理，让低价值信息挤占了高价值信息的生存空间；</li>
<li>上下文工程的本质是“信息治理”：通过分层设计，让系统约束“不被遗忘”、对话共识“不被稀释”、冗余信息“不被保留”、外部知识“按需注入”；</li>
<li>落地上下文工程的关键，是配套三大机制：<strong>分层信息定义机制</strong>（明确每层内容）、<strong>状态动态更新机制</strong>（每轮刷新摘要）、<strong>长度监控截断机制</strong>（避免窗口溢出）。</li>
</ul>
<p>但你也应该意识到一个新的边界：</p>
<blockquote>
<p>即使上下文被精心管理，系统依然只能回答“模型已知或上下文已提供”的内容。</p>
</blockquote>
<p>当用户的问题<strong>超出企业文档覆盖范围，或需要实时数据支撑</strong>（比如“当前我的报销申请审批到哪一步了”）时，仅靠上下文工程无法解决——此时需要引入“外部工具”和“检索增强”，让系统具备“主动获取信息”的能力。</p>
<p>下一部分，我们将聚焦 RAG（检索增强生成）与工具调用，探讨如何让企业知识库助手从“只能回答已知问题”，升级为“能解决未知问题”。</p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/llm/14-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>D05.从0到1实现一个微信红包封面设计Agent</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E5%BA%94%E7%94%A8%E7%AF%87/D05.%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%BE%AE%E4%BF%A1%E7%BA%A2%E5%8C%85%E7%94%9F%E6%88%90Agent.html</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E5%BA%94%E7%94%A8%E7%AF%87/D05.%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%BE%AE%E4%BF%A1%E7%BA%A2%E5%8C%85%E7%94%9F%E6%88%90Agent.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">D05.从0到1实现一个微信红包封面设计Agent</source>
      <description>我用SpringAI实现了个「微信红包封面设计Agent」 年底收到了微信给公众号免费发的一波红包封面兑换卡，正好上次在学习SpringAI的时候，看到了一个有趣的机制——大模型的响应前问询，这不是就是一个绝佳的应用场景嘛~ 让AI来扮演一个设计师，通过与我的对话来敲定我想要的红包封面，然后基于这个设计方案来生成对应的红包封面，来个一站式的微信红包封面生成Agent 一、效果体验 线上体验地址： https://api.ppai.top/</description>
      <category>SpringAI</category>
      <pubDate>Tue, 10 Feb 2026 12:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 我用SpringAI实现了个「微信红包封面设计Agent」</h1>
<p>年底收到了微信给公众号免费发的一波红包封面兑换卡，正好上次在学习SpringAI的时候，看到了一个有趣的机制——大模型的响应前问询，这不是就是一个绝佳的应用场景嘛~</p>
<p>让AI来扮演一个设计师，通过与我的对话来敲定我想要的红包封面，然后基于这个设计方案来生成对应的红包封面，来个一站式的微信红包封面生成Agent</p>
<h2> 一、效果体验</h2>
<p>线上体验地址： <a href="https://api.ppai.top/" target="_blank" rel="noopener noreferrer">https://api.ppai.top/</a></p>
<p>默认进入之后长这样（前端页面由Kimi生成）,通过点击右小角的对话按钮唤出设计框</p>
<figure><img src="/imgs/column/springai/D05-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>接下来我们通过对话来演示一下具体的效果</p>
<blockquote>
<p>公众号查看： <a href="https://mp.weixin.qq.com/s/QyuWZ4EZ32pbcWn3fVphHQ" target="_blank" rel="noopener noreferrer">我用SpringAI实现了个「微信红包封面设计Agent」 | 一灰灰blog</a></p>
</blockquote>
<h2> 二、智能红包封面设计</h2>
<h3> 2.1 整体介绍</h3>
<p>这是一个基于Spring AI开发的完整应用，它能让AI像专业设计师一样，通过多轮对话理解你的需求，然后直接生成符合要求的红包封面。整个过程就像和一个懂设计的朋友聊天，你说想法，它来实现。</p>
<p>系统的核心亮点是"会提问的AI"。当你说"帮我做个红包封面"时，它不会盲目猜测，而是主动询问："你想要什么风格？传统国风还是现代简约？""主色调偏向红色还是金色？"通过这些问题，AI能准确把握你的需求。</p>
<h3> 2.2 架构设计</h3>
<p>项目采用了三层架构设计：</p>
<ul>
<li>对话层：使用AskUserQuestionTool工具，让AI具备主动提问能力。就像设计师会通过提问了解客户需求一样，我们的AI也会一步步澄清设计要求。</li>
<li>生成层：集成阿里云千问的文生图API，将文字描述转换为视觉图像。特别针对微信红包封面的3x4比例(微信红包封面尺寸=957×1278)进行了优化。</li>
<li>交互层：通过SSE（服务器发送事件）技术实现实时对话，用户能看到AI思考和回应的完整过程，体验非常流畅。</li>
</ul>
<figure><img src="/imgs/column/springai/D05-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 三、核心实现</h2>
<p>整体的实现思路基本上和上一篇非常相似，区别是改了交互像是，从控制台模式改成了web方式，具体细节请查看 <a href="https://mp.weixin.qq.com/s/LcvmiIERs6aOIlRAKGGnFg" target="_blank" rel="noopener noreferrer">Spring AI中的多轮对话艺术：让大模型主动提问获取明确需求</a>  接下来将主要介绍一些核心的技术点</p>
<h3> 3.1 多轮问询机制</h3>
<p>如何识别用户的意图？这好像是每个Agent开发必须解决的问题，这里可以说是给出了一个经典的解决方案，那就是主动问询，让用户主动进行澄清，这里的主要实现原理如下图</p>
<figure><img src="/imgs/column/springai/A07-0.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这一套设计哲学遵循问答式工作流程：</p>
<ol>
<li>AI生成问题
<ul>
<li>智能体判断需要输入并构建问题（每个问题包含问题文本、标题、2-4个选项和多选标志），然后调用<code>AskUserQuestionTool</code>函数</li>
</ul>
</li>
<li>用户提供答案
<ul>
<li>由业务代码实现接收这些问题，然后通过合适的形式（控制台/web页面等）展示给用户，然后收集用户的回答，并将答案返回给LLM。</li>
</ul>
</li>
<li>提出更多问题
<ul>
<li>如有必要，重复步骤1、2，以收集更多用户反馈</li>
</ul>
</li>
<li>人工智能持续关注上下文
<ul>
<li>LLM利用这些答案来提供量身定制的解决方案</li>
</ul>
</li>
</ol>
<p>需要说明的是，每个问题的回答并不是写死的：</p>
<ul>
<li>支持单选或多选: 选择一个选项或组合多个选项</li>
<li>支持选项外的文本输入: 用户可以随时提供超出预定义选项范围的自定义文本</li>
<li>丰富的上下文: 每个选项都包含一个描述，解释其含义和权衡</li>
</ul>
<h3> 3.2 WEB交互方案</h3>
<p>对于web层的用户交互，我们采用SSE的交互方式，具体流程是</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以时序图的视角来看一下完整的交互方案</p>
<figure><img src="/imgs/column/springai/D05-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在这套方案的具体实现中，我们通过上下文来持有 <code>会话与SSE</code> 之间的关系，这样才可以将用户的回答内容与之前的大模型会话进行绑定</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过一个临时的Map来存储用户的问询结果，这里借助<code>BlockingQueue</code>来实现一个简易的消息驱动模式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>基于上面这两个中间存储管道，所以我们核心的问询回调<code>WebQuestionHandler</code>的具体实现如下 (下面的实现给了完整的注释，应该不难理解😊)</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.3 图片生成</h3>
<p>图文生成我们这里给出了两种，一个是基于智谱的一个是基于千问的(因为智谱的免费模型有点拉跨)；</p>
<p>文生图的具体实现没有太多好说的，这里单独指出来是想提醒，这里实际上还可以继续扩展一下，除了生成静态图片之外，还可以考虑支持生成动态的视频；除了生成封面图之外，还可以考虑扩展生成挂件</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 四、小结</h2>
<p>这一篇内容可以说是上一篇SpringAI智能体设计中问询机制的具体使用场景，整个系统展现了AI应用开发的新思路：不是让人适应机器，而是让机器理解人的表达方式。通过多轮对话获取准确需求，再通过AI生成能力直接产生成果，真正实现了从想法到作品的转换。当然整体的实现还比较初级，还有不少的挖掘空间，比如一次生成完整的微信红包方案（包括封面简称、封面图、挂件、气泡挂件、封面故事等）欢迎有兴趣的小伙伴进行补全</p>
<p>项目源码：</p>
<ul>
<li><a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/v2/T03-manual-qa-web-robot" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo/tree/master/v2/T03-manual-qa-web-robot</a></li>
</ul>
<p>零基础入门：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/qCn8x2XO2shA8MheYbHq0w" target="_blank" rel="noopener noreferrer">LLM 应用开发是什么：零基础也可以读懂的科普文(极简版)</a></li>
<li><a href="https://mp.weixin.qq.com/s/2GXBNOUq3jlysipftz8TpA" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：序-为什么你“会用 LLM”，但做不出复杂应用？</a></li>
<li><a href="https://mp.weixin.qq.com/s/v-z6EHY300ElOxdGPdzc0w" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第一章 LLM到底在做什么？</a></li>
<li><a href="https://mp.weixin.qq.com/s/t_BuAW9i0npcaJdua3Am2Q" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第二章 模型不是重点，参数才是你真正的控制面板</a></li>
<li><a href="https://mp.weixin.qq.com/s/vzt0bGwcfnASOiBa0Kc7VQ" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第三章 为什么我的Prompt表现很糟？</a></li>
<li><a href="https://mp.weixin.qq.com/s/Nk-N34TLJVCTI5F4k5rGaQ" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第四章 Prompt 的工程化结构设计</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZQbztqBq7_PzynG06N4-mg" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第五章 从 Prompt 到 Prompt 模板与工程治理</a></li>
<li><a href="https://mp.weixin.qq.com/s/nnKspRO87xbrn4-LBV3RNA" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第六章 上下文窗口的真实边界</a></li>
<li><a href="https://mp.weixin.qq.com/s/_5D2tF6CPnafj5mlmlwLNw" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第七章 从 “堆上下文” 到 “管理上下文”</a></li>
<li><a href="https://mp.weixin.qq.com/s/z5qaLtjChsvjhWNs8Nw05Q" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第八章 记忆策略的工程化选择</a></li>
</ul>
<hr>
<p>实战</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/96rHyp_gBUgmA2dhSbzNww" target="_blank" rel="noopener noreferrer">实战 | 两百行实现一个自然语言地址提取智能体</a></li>
<li><a href="https://mp.weixin.qq.com/s/SnXdTB6tYqAzG7HgbnTSAQ" target="_blank" rel="noopener noreferrer">实战 | 基于SpringAI与大模型的零配置发票智能提取架构</a></li>
<li><a href="https://mp.weixin.qq.com/s/NHqLJbos-_nrxNNmhg7IBQ" target="_blank" rel="noopener noreferrer">实战 | 零基础搭建知识库问答机器人：基于SpringAI+RAG的完整实现</a></li>
<li><a href="https://mp.weixin.qq.com/s/ujxVleNhjxzUgL-rjfFcVA" target="_blank" rel="noopener noreferrer">告别传统AI开发！SpringAI Agent + Skills重新定义智能应用</a></li>
<li><a href="https://mp.weixin.qq.com/s/LcvmiIERs6aOIlRAKGGnFg" target="_blank" rel="noopener noreferrer">Spring AI中的多轮对话艺术：让大模型主动提问获取明确需求</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/D05-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>07.SpringAI智能体模式：让大模型主动提问获取明确需求</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E8%BF%9B%E9%98%B6%E7%AF%87/A07.SpringAI%E6%99%BA%E8%83%BD%E4%BD%93%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%93%8D%E5%BA%94%E5%89%8D%E5%85%88%E9%97%AE%E8%AF%A2%E6%9C%BA%E5%88%B6.html</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E8%BF%9B%E9%98%B6%E7%AF%87/A07.SpringAI%E6%99%BA%E8%83%BD%E4%BD%93%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%93%8D%E5%BA%94%E5%89%8D%E5%85%88%E9%97%AE%E8%AF%A2%E6%9C%BA%E5%88%B6.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">07.SpringAI智能体模式：让大模型主动提问获取明确需求</source>
      <description>Spring AI中的多轮对话艺术：让大模型主动提问获取明确需求 在日常我们与大模型交互的过程中，通常是我输入一个问题或者场景要求，然后大模型基于我给出的信息进行生成内容。这种方式很容易出现一个答非所问的场景（好像大模型并不能总是回答到我的心趴上🤣） 那么有什么好的解决办法吗？ 熟练调教大模型的小伙伴，可能早就有自己的一套标准流程了 -- 通过多次与大模型之间的多次问询回答，让大模型能更清晰的知道自己的诉求 那么如何让AI主动问询用户来获取更精确的信息呢？如果我开发的大模型应用，希望集成这样的能力，又可以怎么实现呢？</description>
      <category>SpringAI</category>
      <pubDate>Tue, 27 Jan 2026 11:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Spring AI中的多轮对话艺术：让大模型主动提问获取明确需求</h1>
<p>在日常我们与大模型交互的过程中，通常是我输入一个问题或者场景要求，然后大模型基于我给出的信息进行生成内容。这种方式很容易出现一个答非所问的场景（好像大模型并不能总是回答到我的心趴上🤣）</p>
<p>那么有什么好的解决办法吗？</p>
<p>熟练调教大模型的小伙伴，可能早就有自己的一套标准流程了 -- 通过多次与大模型之间的多次问询回答，让大模型能更清晰的知道自己的诉求</p>
<p>那么如何让AI主动问询用户来获取更精确的信息呢？如果我开发的大模型应用，希望集成这样的能力，又可以怎么实现呢？</p>
<p>接下来我们看看，SpringAI中，如何通过巧妙的多轮对话艺术，来实现让大模型主动提问获取明确需求</p>
<h2> 一、方案设计</h2>
<h3> 1.1 核心问题</h3>
<p>在我们这个场景中，核心的问题点在于 <strong>如何让大模型在面对模糊需求时，能够主动发起询问，获取更详细的信息，从而提供更精准的响应。</strong></p>
<p>常见的实现中，存在的问题如下：</p>
<ul>
<li>单次交互试图解决复杂问题</li>
<li>对模糊输入不做处理直接响应</li>
<li>缺少多轮对话的状态管理</li>
</ul>
<p>这些问题的根本原因在于没有建立起AI与用户之间的有效反馈循环，导致大模型无法获取足够的上下文信息，但是对于大模型而言，响应内容是对它的一个非常重要的考量指标，所以就很容出现大模型<code>话说八道</code> <code>答非所问</code>等幻觉那问题</p>
<h3> 1.2 主动问询设计</h3>
<blockquote>
<p>好的设计应该主动适应用户，而不是让用户适应设计。</p>
</blockquote>
<p>很多人认为大模型只能被动接收输入，实际上 <code>Spring AI</code> 提供了 <code>AskUserQuestionTool</code> 这个强大的工具，让AI能够主动向用户提出问题。</p>
<p>它是通过什么实现的呢？</p>
<figure><img src="/imgs/column/springai/A07-0.webp" alt="交互演示" tabindex="0" loading="lazy"><figcaption>交互演示</figcaption></figure>
<ul>
<li>通过Function Callback来实现，将<code>AskUserQuestionTool</code>注册为大模型可回调使用的工具，通过这个工具来实现多轮问询应答</li>
</ul>
<p>下面是这个工具的核心定义:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点看一下这个工具的描述，将其翻译成中文，内容如下</p>
<div class="language-txt line-numbers-mode" data-ext="txt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个工具类中，通过巧妙的设计，告诉大模型在具体响应之前，可以先进行用户问询</p>
<ul>
<li>大模型将需要问询的内容，转换为结构化的 <code>List&lt;Question&gt;</code></li>
<li>通过设计一个<code>QuestionHandler</code>来处理具体的用户问答交互流程，通过责任分离的设计思想，AI负责决定何时提问，具体的UI交互由开发者自定义。你可以将其适配到Web界面、移动端或任何其他平台。</li>
</ul>
<p>因此具体的问询应答方式，完全是由应用方（即开发者）来控制的</p>
<p>接下来我们进入实战演练，看看如何实现这样的一个多轮问询</p>
<h2> 二、项目创建</h2>
<h3> 2.1 基础环境要求</h3>
<p>要体验SpringAI的问询机制，目前需要升级到SpringAI 2.x版本，同时我们的SpringBoot也可以升级到4.x</p>
<ul>
<li>SpringAI: 2.0.0-M2</li>
<li>SpringBoot: 4.0.1</li>
<li>JDK21/17：这两版本都可以</li>
</ul>
<p>除了这几个基本依赖之外，我们可以选择一个支持Function Tool的大模型来作为这个实现的大脑中枢</p>
<p>我们这里选择智谱的大模型<code>GLM-4.5-Flash</code> （原因就是因为它免费，且效果还行，对所有想体验的小伙伴没有任何额外成本投入）</p>
<h3> 2.2 项目创建</h3>
<p>接下来我们创建一个SpringAI应用，对于一个标准的SpringAI应用，在<code>pom.xml</code>配置中，你会看到下面这些基础版本指定，这个也没什么好说的</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来重点看一下我们这个项目所用到的几个核心依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>spring-ai-agent-utils: 这个就是SpringAI进行agent开发的关键依赖包</li>
<li>spring-ai-starter-model-zhipuai: 这个是智谱大模型进行交互的依赖包</li>
</ul>
<h3> 2.3 项目配置</h3>
<p>依赖搞定之后，接下来就是在配置文件中，配置LLM访问的相关信息、以及agent相关配置参数，对应的配置文件 <code>resources/application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 三、核心实现</h2>
<p>接下来我们进行快速体验，首先为了更好的观察应用与大模型之间的交互，我们实现一个<code>LoggingAdvisor</code></p>
<h3> 3.1 交互日志打印： MyLoggingAdvisor</h3>
<blockquote>
<p>说明：这个实现非必需，不感兴趣的直接跳过</p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.2 命令行的问询应答实现：CommandLineQuestionHandler</h3>
<p>在前面的设计篇中介绍了<code>AskUserQuestionTool</code>中，设计了一个扩展点 <code>QuestionHandler</code> 由使用者来实现具体的问答交互方案，因此我们先实现一个基础的基于命令行的问答</p>
<ul>
<li><code>CommandLineQuestionHandler</code>：实现<code>QuestionHandler</code>接口，处理用户问题列表</li>
<li><code>handle</code>方法：遍历问题，显示选项供用户选择，支持单选/多选模式</li>
<li><code>parseResponse</code>方法：解析用户输入，将数字编号转换为对应选项标签，或直接返回自定义文本答案</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.3 问询对话实现</h3>
<p>创建一个简易聊天客户端，配置了三个Advisor：工具调用顾问、消息记忆顾问和自定义日志顾问（隐藏可用工具和系统消息）。</p>
<p>然后启动一个命令行循环，用户输入问题后通过聊天客户端处理并输出AI助手的回答</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.4 测试验证</h3>
<p>直接启动项目，然后再控制台中输入我的原始诉求</p>
<figure><img src="/imgs/column/springai/A07-1.webp" alt="交互演示" tabindex="0" loading="lazy"><figcaption>交互演示</figcaption></figure>
<p>下面是完整的文字版本输出内容</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以将这个方案，拿来生成图片，比如下面是豆包、千问、元宝等不同平台的生成效果</p>
<table>
<thead>
<tr>
<th>模型</th>
<th>效果图</th>
</tr>
</thead>
<tbody>
<tr>
<td>豆包</td>
<td><img src="/imgs/column/springai/A07-doubao.webp" alt="豆包效果图" loading="lazy"></td>
</tr>
<tr>
<td>元宝</td>
<td><img src="/imgs/column/springai/A07-yuanbao.webp" alt="元宝效果图" loading="lazy"></td>
</tr>
<tr>
<td>千问</td>
<td><img src="/imgs/column/springai/A07-yuanbao.webp" alt="千问效果图" loading="lazy"></td>
</tr>
<tr>
<td>百度</td>
<td><img src="/imgs/column/springai/A07-baidu.webp" alt="百度效果图" loading="lazy"></td>
</tr>
<tr>
<td>ChatGPT</td>
<td><img src="/imgs/column/springai/A07-chatgpt.webp" alt="ChatGPT效果图" loading="lazy"></td>
</tr>
</tbody>
</table>
<h2> 四、小结</h2>
<p>本文内容通过设计+实例给大家演示了一下Spring AI中的多轮对话艺术，如何让大模型主动提问获取明确需求？ 下面几部即可：</p>
<ul>
<li>主动询问机制：使用AskUserQuestionTool让AI在信息不足时主动提问</li>
<li>灵活的响应处理：通过自定义QuestionHandler适配不同平台的交互方式</li>
<li>对话状态管理：利用MessageChatMemoryAdvisor维护多轮对话的上下文</li>
<li>工具组合使用：将询问工具与记忆顾问、日志顾问等配合使用，构建完整的交互体系</li>
<li>异步处理支持：在Web环境中使用SSE实现流畅的多轮对话体验</li>
</ul>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/A07-0.webp" type="image/webp"/>
    </item>
    <item>
      <title>第 8 章：记忆策略的工程化选择</title>
      <link>https://ppai.top/ai-guides/tutorial/hello-llm/13.%E8%AE%B0%E5%BF%86%E7%AD%96%E7%95%A5.html</link>
      <guid>https://ppai.top/ai-guides/tutorial/hello-llm/13.%E8%AE%B0%E5%BF%86%E7%AD%96%E7%95%A5.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">第 8 章：记忆策略的工程化选择</source>
      <description>在前两章中，我们已经完成了两个关键决策： 否定“无限上下文”的幻想：明确上下文窗口存在硬性约束，无法承载无限制的对话信息； 接受“信息必须被分层管理”：将信息划分为不变约束、会话状态、瞬时上下文，优先保障高优先级信息的有效性。 接下来，我们需要面对一个更系统级的问题，当然这也是很多小伙伴在具体落地时，最容易困惑的地方 “记忆”是否应该只有一种实现方式？ 答案显然是否定的，就像人类会用“瞬时回忆”记住刚说的话、用“短期记忆”记住当天的任务、用“长期记忆”记住过往的经验一样，大模型应用的“记忆”也需要分层设计</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 14:55:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>在前两章中，我们已经完成了两个关键决策：</p>
<ul>
<li>否定“无限上下文”的幻想：明确上下文窗口存在硬性约束，无法承载无限制的对话信息；</li>
<li>接受“信息必须被分层管理”：将信息划分为不变约束、会话状态、瞬时上下文，优先保障高优先级信息的有效性。</li>
</ul>
<p>接下来，我们需要面对一个更系统级的问题，当然这也是很多小伙伴在具体落地时，最容易困惑的地方</p>
<blockquote>
<p><strong>“记忆”是否应该只有一种实现方式？</strong></p>
</blockquote>
<p>答案显然是否定的，就像人类会用“瞬时回忆”记住刚说的话、用“短期记忆”记住当天的任务、用“长期记忆”记住过往的经验一样，大模型应用的“记忆”也需要分层设计</p>
<p><strong>那么为什么不能用一种记忆搞定所有场景？</strong></p>
<blockquote>
<p>答：短期能用，但无法规模化、稳定化。</p>
<p>比如我们实现了一个公司差旅助手，初期用“全量历史+摘要”的单一记忆方式，上线后很容易出现</p>
<ol>
<li>员工跨周期咨询时，如上一次一个月前让助手定了一张机票，输入了一些关键信息，但是没有走完流程；这一次准备让助手帮忙订机票，助手可能就直接基于上一次的输入来订机票了，而员工实际上却是要去另一个地方</li>
<li>多员工并发咨询时，不同人的报销信息混杂，模型给出错误答复。</li>
</ol>
<p>本质是“单一记忆”无法适配“瞬时、会话、长期”三种不同的信息需求，最终导致用户体验崩塌。</p>
</blockquote>
<hr>
<h3> 8.1 技术决策视角：记忆不是功能，而是策略组合</h3>
<p>在很多产品讨论中，“给系统加记忆” 常被当作一个简单的功能点（比如 “让模型记住之前说过的话”）。</p>
<p>但从工程角度看，记忆是<strong>一组需要根据场景动态调整的策略</strong></p>
<p>—— 不同的信息生命周期（几秒、几小时、几天）、不同的重要性，需要匹配不同的记忆方式。</p>
<p>比如：</p>
<ul>
<li><em>用户当前的提问意图（“我在问报销流程”）需要 “即时记忆”，确保下一句回应不跑偏；</em></li>
<li><em>已确认的用户身份（“市场部员工”）需要 “会话级记忆”，在整个对话过程中保持一致；</em></li>
<li><em>三个月前用户咨询过的 “差旅政策” 需要 “长期记忆”，在用户再次提问时能快速关联。</em></li>
</ul>
<p>这些不同场景的需求，无法通过单一的 “记忆功能” 满足，必须设计分层的记忆策略。</p>
<p>下面用一张示意图，直观理解不同记忆策略的适配场景：</p>
<figure><img src="/imgs/column/llm/13-0.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h3> 8.2 短期记忆：受控的上下文拼接（什么时候足够用）</h3>
<p>最基础、成本最低的记忆策略是 “短期记忆”，适用于单一会话内的近期交互（通常持续几分钟到 1 小时）。</p>
<p>其核心设计是：</p>
<ul>
<li>只保留最近 N 轮对话（N 的值根据模型窗口大小确定，通常为 5-10 轮）；</li>
<li>明确区分 <code>system</code> / <code>state</code> / <code>recent messages</code> 三个层级，按优先级拼接上下文</li>
<li>Token 控制：实时统计拼接后的 Token 数量，接近窗口上限时，优先丢弃最早的瞬时对话内容，保留高优先级信息</li>
</ul>
<figure><img src="/imgs/column/llm/13-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这个策略的工程价值在于：</p>
<ul>
<li><strong>行为可预测</strong>：由于只保留有限内容，token 数量可控，不会突然触发截断；</li>
<li><strong>成本可控</strong>：避免了全量历史导致的 token 爆炸，调用成本稳定，尤其适合中小规模应用；</li>
<li><strong>实现简单</strong>：无需复杂的存储或摘要逻辑，仅需维护一个滑动窗口，开发成本低、上线快。</li>
</ul>
<p>但它很快会遇到边界，这也是很多开发同学会踩的坑：</p>
<blockquote>
<p><strong>当对话跨越更长时间或主题切换频繁时，仅靠短期记忆会导致状态丢失</strong></p>
</blockquote>
<p>例如，用户上午9点咨询“年假政策”，告知助手“自己入职满3年”，助手确认“入职满3年可休10天年假”；下午2点，用户继续在同一个会话中咨询“年假是否可以拆分休”，此时短期记忆的滑动窗口已丢弃上午的对话，助手再次追问“请问您入职满几年？”，用户体验极差。</p>
<p>此时，就需要引入第二种记忆策略——中期记忆，来解决“会话级关键信息持久化”的问题。</p>
<blockquote>
<p><strong>高频问答：短期记忆的滑动窗口 N 怎么确定？</strong>
疑问：短期记忆的“最近N轮”，N设为5还是10？有没有统一标准？
回复：没有统一标准，核心取决于两个因素：</p>
<ol>
<li>模型的上下文窗口大小（窗口越大，N可适当增大；如4k窗口建议N=3-5，16k窗口建议N=5-10）</li>
<li>单轮对话的Token长度（如果用户每轮提问都很长，N需减小，避免Token溢出）
核心原则：确保“不变约束+会话状态+最近N轮”的总Token数，不超过窗口上限的70%（预留30%给模型回应）。</li>
</ol>
</blockquote>
<hr>
<h3> 8.3 中期记忆：由 LLM 维护的状态摘要（为什么要引入）</h3>
<p>为了避免重要状态被挤出窗口，企业知识库助手通常会引入 “中期记忆” —— 通过“会话状态摘要”来持久化关键信息，确保在对话持续数小时或主题切换时，核心状态不丢失。</p>
<p>请注意，这里有一个关键误区：很多开发同学会把“会话状态摘要”和“对话内容摘要”混淆，其实两者完全不同：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>核心目的</th>
<th>内容特点</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>对话内容摘要</td>
<td>总结对话的整体内容，方便用户回顾</td>
<td>非结构化，侧重“过程描述”</td>
<td>用户咨询差旅报销，先问了高铁，再问了住宿，助手告知了相关政策。</td>
</tr>
<tr>
<td>会话状态摘要</td>
<td>持久化关键决策信息，供模型后续参考</td>
<td>结构化，侧重“结果确认”</td>
<td>用户：张三（市场部，入职3年）；已确认：高铁二等座可报销、一线城市住宿上限800元/晚。</td>
</tr>
</tbody>
</table>
<p>简单来说会话状态摘要的核心不是 “总结对话内容”，而是<strong>记录 “已确认的决策信息”</strong>，格式通常是结构化的键值对或列表。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这类摘要的维护机制通常是：<strong>每轮对话结束后，调用 LLM 对比新内容与当前摘要，自动更新关键信息</strong>（新增确认项、移除已解决问题、修正错误）。</p>
<p>这个流程可以通过示意图直观理解：</p>
<figure><img src="/imgs/column/llm/13-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>它的核心价值是：<strong>将分散在多轮对话中的关键信息 “浓缩固化”，避免被短期记忆的滑动窗口 “挤出”</strong>。</p>
<p>即使短期记忆只保留最近 5 轮，状态摘要也能确保 “用户身份”“已确认规则” 等信息持续影响模型决策。</p>
<blockquote>
<p>这不是对话摘要，而是<strong>决策状态的持久化</strong>。</p>
</blockquote>
<hr>
<h3> 8.4 长期记忆：为什么不能继续塞进上下文？</h3>
<p>当对话场景扩展到以下情况时，仅靠短期和中期记忆（依赖上下文窗口）就会变得不现实——它们的核心局限是“无法脱离上下文窗口存在”，而窗口容量和单一会话的限制，决定了它们无法应对“跨时间、跨规模”的记忆需求：</p>
<ul>
<li><strong>跨天对话</strong>：用户今天咨询一半，明天继续（此时会话可能已被重置，中期记忆的摘要也会丢失）；</li>
<li><strong>多任务切换</strong>：用户同时处理 “报销”“年假”“绩效” 多个主题（每个主题有独立的关键信息，塞进同一个上下文会导致信息混杂，模型混淆）；</li>
<li><strong>多用户并发</strong>：同一个助手服务多个员工，需要区分每个人的历史。</li>
</ul>
<p>此时，继续将所有信息塞进上下文窗口会导致两个问题：</p>
<ol>
<li>窗口容量有限，无法容纳多天的状态摘要；</li>
<li>不同用户 / 任务的信息混杂，导致模型混淆。</li>
</ol>
<p>因此，我们需要一种 “移出上下文但可按需召回” 的记忆机制 —— 这正是<strong>长期记忆</strong>的核心价值。</p>
<p>长期记忆的实现通常依赖外部存储（如数据库、向量数据库），其核心逻辑是：</p>
<ul>
<li>将不活跃的会话状态（如 24 小时未更新）从上下文移出，存入外部存储；</li>
<li>当用户再次激活对话时，通过检索（如基于用户 ID、主题关键词）将相关历史状态重新导入上下文。</li>
</ul>
<p>以企业助手为例，具体的实现步骤通常有下面四步：</p>
<ol>
<li>
<p>存储：将不活跃的会话状态（如 24 小时未更新的会话）、用户历史咨询记录，从上下文移出，存入外部存储（向量数据库优先，方便后续关键词检索）；存储时需关联“用户ID、主题关键词、时间戳”，便于后续召回；</p>
</li>
<li>
<p>检索：当用户再次激活对话（如第二天继续咨询）或切换主题时，模型先提取当前对话的“用户ID、主题关键词”（比如“张三、海外差旅”），通过检索工具查询外部存储，找到相关的历史记忆；</p>
</li>
<li>
<p>召回：将检索到的历史记忆（如张三上次未完成的“海外差旅政策”咨询记录、已确认的“入职年限”），精简后重新导入上下文，结合短期、中期记忆，生成回应；</p>
</li>
<li>
<p>更新：本轮对话结束后，更新长期记忆中的相关记录，确保历史信息的时效性（比如补充新确认的“海外差旅住宿上限”）。</p>
</li>
</ol>
<blockquote>
<p><strong>长期记忆的核心不是 “记住一切”，而是 “在需要时，能把正确的信息带回上下文”</strong> —— 它解决的是 “跨时间、跨规模” 的记忆问题。</p>
</blockquote>
<p>此时，一个新的技术出现了：这正是<code>向量检索</code>、<code>RAG</code>等机制存在的根本原因。</p>
<h3> 8.5 短中长记忆协同工作流程</h3>
<p>在实际的项目工程中，上面提到的短期、中期、长期三种记忆策略通常不是独立使用的、而是协同工作，形成完整的记忆体系，下面是一个典型的示意图</p>
<figure><img src="/imgs/column/llm/13-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h3> 8.6 本章小结：记忆层次决定系统上限</h3>
<p>通过本章的分析，我们可以明确：企业知识库助手的 “记忆” 是分层的策略组合，不同层次解决不同问题，三者协同，才能构建稳定、高效、用户体验好的记忆体系：</p>
<ul>
<li>短期记忆：通过受控的上下文拼接，解决 “当前几轮对话的连贯性”；</li>
<li>中期记忆：通过状态摘要，解决 “会话级关键信息的一致性”；</li>
<li>长期记忆：通过外部存储与检索，解决 “跨时间、跨任务的信息召回”。</li>
</ul>
<p>这三层记忆共同构成了系统在时间维度上的可靠性基础。但还有一个关键问题尚未解决：</p>
<blockquote>
<p><em>当用户的问题超出模型自身的知识范围（比如最新的公司政策），仅靠记忆策略如何保证回答准确？</em></p>
</blockquote>
<p>而这自然引出了下一部分的讨论主题：我们将深入探讨 RAG（检索增强生成）技术如何与上下文工程结合，让系统的知识边界可控、可扩展。</p>
<p><strong>扩展思考</strong></p>
<ol>
<li>
<p>你所开发的 LLM 应用，会话持续时间通常是多久？如果是跨天对话，长期记忆的“不活跃阈值”（如24小时）如何设定更合理？</p>
</li>
<li>
<p>中期记忆的会话状态摘要，每轮都调用 LLM 更新会增加成本，如何设计“更新触发条件”（比如仅当有新的确认项时才更新），平衡成本与效果？</p>
</li>
<li>
<p>如果没有向量数据库，能否用“关键词匹配”替代向量检索，实现长期记忆的召回？这种方式的局限性是什么？</p>
</li>
</ol>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/llm/13-0.webp" type="image/webp"/>
    </item>
    <item>
      <title>06.SpringAI智能体模式：使用Skills</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E8%BF%9B%E9%98%B6%E7%AF%87/A06.SpringAI%E6%99%BA%E8%83%BD%E4%BD%93%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%BD%BF%E7%94%A8Skills.html</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E8%BF%9B%E9%98%B6%E7%AF%87/A06.SpringAI%E6%99%BA%E8%83%BD%E4%BD%93%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%BD%BF%E7%94%A8Skills.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">06.SpringAI智能体模式：使用Skills</source>
      <description>SpringAI Skills模式：AI应用开发的下一个风口，你跟上了吗？ 要收最近AI相关话题中什么最火，毫无疑问是Claude Skills，让我感到震惊的倒不是它为什么火爆，而是SpringAI居然已经迅速支持上Skills了，这效率真的是堪比🚀了。 谁说AI时代java开发者要掉队了？ 肉虽然不一定吃得上，但是喝口汤还是妥妥的 接下来我们通过构建一个code reviewer, 来实际体验一把，如何将SpringAI和Skills结合起来使用 一、项目创建 1. 基础环境要求</description>
      <category>SpringAI</category>
      <pubDate>Tue, 27 Jan 2026 11:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> SpringAI Skills模式：AI应用开发的下一个风口，你跟上了吗？</h1>
<p>要收最近AI相关话题中什么最火，毫无疑问是<strong>Claude Skills</strong>，让我感到震惊的倒不是它为什么火爆，而是SpringAI居然已经迅速支持上Skills了，这效率真的是堪比🚀了。</p>
<p>谁说AI时代java开发者要掉队了？ 肉虽然不一定吃得上，但是喝口汤还是妥妥的</p>
<p>接下来我们通过构建一个code reviewer, 来实际体验一把，如何将SpringAI和Skills结合起来使用</p>
<h2> 一、项目创建</h2>
<h3> 1. 基础环境要求</h3>
<p>要体验SpringAI &amp; Skills，目前需要升级到SpringAI 2.x版本，同时我们的SpringBoot也可以升级到4.x</p>
<ul>
<li>SpringAI: 2.0.0-M2</li>
<li>JDK21</li>
<li>SpringBoot: 4.0.1</li>
</ul>
<p>除了这几个基本依赖之外，我们可以选择一个支持Function Tool的大模型来作为这个实现的大脑中枢</p>
<p>我们这里选择智谱的大模型<code>GLM-4.5-Flash</code> （原因就是因为它免费，且效果还行，对所有想体验的小伙伴没有任何额外成本投入）</p>
<h3> 2. 项目创建</h3>
<p>接下来我们创建一个SpringAI应用，对于一个标准的SpringAI应用，在<code>pom.xml</code>配置中，你会看到下面这些基础版本指定，这个也没什么好说的</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来重点看一下我们这个项目所用到的几个核心依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>spring-ai-agent-utils: 这个就是SpringAI进行agent开发的关键依赖包</li>
<li>spring-ai-starter-model-zhipuai: 这个是智谱大模型进行交互的依赖包</li>
</ul>
<h3> 3. 项目配置</h3>
<p>依赖搞定之后，接下来就是在配置文件中，配置LLM访问的相关信息、以及agent相关配置参数，对应的配置文件 <code>resources/application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这几个配置看起来和之前SpringAI相关的并没有太多的区别，其中 <code>agent</code> 相关的配置中，主要设置了skills的存放路径，使用的model</p>
<p>根据上面的定义，我们将skills信息，放在<code>resources/.claude/skills</code>目录下</p>
<p>新增一个目录<code>code-reviewer</code>，目录下的文件为 <code>SKILL.md</code></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的内容如下</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. Skills简要说明</h3>
<p>我们上面的Skill比较简单，就是一个markdown文档，SpringAI支持的Skills中，除了包含基本的<code>SKILL.md</code>文件（包含元数据（名称和描述）以及指导代理如何执行特定任务的说明）之外，还可以有相关的脚本、模板和参考资料</p>
<p>一个常见的skills结构如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 二、核心实现</h2>
<p>现在前置准备已经完成，接下来开始正式的体验吧</p>
<h3> 2.1 交互日志打印 MyLoggingAdvisor</h3>
<p>为了让系统与大模型之间的交互更清晰，我们将双方交互的日志进行更友好的打印（也顺便看一下，一次用户感知的问答过程中，实际上有几次交互）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.2 准备用于评审的代码</h3>
<p>我们直接使用 <a href="https://mp.weixin.qq.com/s/NHqLJbos-_nrxNNmhg7IBQ" target="_blank" rel="noopener noreferrer">实战 | 零基础搭建知识库问答机器人：基于SpringAI+RAG的完整实现</a> 中的代码分块的内容作为待评审的内容，看下这段简单的文本分块工具会评审出什么内容</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.3 核心实现</h3>
<p>配置Agent实现代码评审</p>
<p><strong>Bean定义与依赖注入</strong></p>
<ul>
<li>CommandLineRunner: Spring启动后自动执行的接口</li>
<li>ChatClient.Builder: 用于构建聊天客户端</li>
<li>@Value("${agent.skills.dirs:Unknown}"): 注入配置属性，获取技能目录资源列表</li>
</ul>
<p><strong>ChatClient配置链</strong></p>
<ul>
<li>系统提示词配置：</li>
<li>技能工具配置：
<ul>
<li>SkillsTool.builder().addSkillsResources(agentSkillsDirs).build(): 动态加载预定义的技能资源</li>
<li>FileSystemTools.builder().build(): 提供文件系统访问能力</li>
<li>ShellTools.builder().build(): 提供命令行执行能力</li>
</ul>
</li>
<li>Advisor配置:
<ul>
<li>ToolCallAdvisor.builder().build(): 处理工具调用逻辑</li>
<li>MyLoggingAdvisor.builder().showAvailableTools(false).showSystemMessage(false).build(): 自定义日志记录，隐藏工具和系统消息详情</li>
</ul>
</li>
</ul>
<p><strong>代码评审执行流程</strong></p>
<p>请求执行</p>
<ul>
<li>prompt(): 构建提示词</li>
<li>.call(): 发起AI请求</li>
<li>.content(): 获取返回结果</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.4 执行演示</h3>
<p>接下来我们启动项目，验证一下效果如何（在启动命令行参数中，配置上大模型的api-key，当然也可以直接在yml配置文件中进行配置）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/A06-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="/imgs/column/springai/A06-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的截图也可以看出，系统与大模型之间进行了三轮对话，</p>
<ol>
<li>第一轮： 用户的原始诉求 -&gt; 大模型</li>
</ol>
<ul>
<li>大模型识别到需要进行代码评审，给系统响应 <code>{"command":"code-reviewer"}</code></li>
</ul>
<ol start="2">
<li>第二轮：系统接收到响应之后，读取skills的约束进行响应</li>
</ol>
<ul>
<li>大模型返回需要读取需要评审的代码内容，对应的响应为 <code>{"filePath":"D:\\Workspace\\hui\\project\\spring-ai-demo\\v2\\T01-agentic-skills-simple-design\\src\\main\\java\\com\\git\\hui\\springai\\app\\demo\\DocumentChunker.java"}</code></li>
</ul>
<ol start="3">
<li>第三轮：系统读取代码内容，发送给大模型</li>
</ol>
<ul>
<li>大模型返回评审结果</li>
</ul>
<p>下面是完整的返回文本，有兴趣的小伙伴可以看看</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 三、小结</h2>
<p>SpringAI的Agent开发范式配合Skills机制，非常简单就实现了AI应用的工程化。整个过程实现下来，门槛还是比较低的。 不得不赔付Spring🐂🍺</p>
<p>实现方式虽然简单，但是这个背后的设计哲学、开发思维的转变，还是很值得我们学习参考的——我们不再是在构建"会说话的程序"，而是在创造"能做事的智能代理"。</p>
<p>那么这一套是怎么实现的呢？</p>
<figure><img src="/imgs/column/springai/A06-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>Spring AI采用基于工具的集成方法，通过实现各种工具，使任何LLM都能回调执行，Skills的运行过程，通常是下面三步：</p>
<ol>
<li>发现（启动阶段）</li>
</ol>
<ul>
<li>通过<code>SKILL.md</code>文件中的元数据，快速实现技能的安装注册</li>
</ul>
<ol start="2">
<li>语义匹配（对话过程中）</li>
</ol>
<ul>
<li>当用户发出请求时，LLM 会检查工具定义中嵌入的技能描述。如果 LLM 判断用户请求在语义上与某个技能的描述匹配，则会调用该技能工具，并将技能名称作为参数传递给它。</li>
</ul>
<ol start="3">
<li>执行（技能调用时）</li>
</ol>
<ul>
<li>当调用技能工具时，SkillsTool会从磁盘加载完整的SKILL.md内容，并将其与技能的基础目录路径一起返回给大型语言模型（LLM）。然后，LLM会按照技能内容中的指令执行。如果技能引用了其他文件或辅助脚本，LLM会使用<code>FileSystemTools</code>的<code>Read</code>函数或<code>ShellTools</code>的<code>Bash</code>函数来按需访问它们</li>
</ul>
<hr>
<p>项目源码：</p>
<ul>
<li><a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/v2/T01-agentic-skills-simple-design" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo/tree/master/v2/T01-agentic-skills-simple-design</a></li>
</ul>
<p>零基础入门：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/qCn8x2XO2shA8MheYbHq0w" target="_blank" rel="noopener noreferrer">LLM 应用开发是什么：零基础也可以读懂的科普文(极简版)</a></li>
<li><a href="https://mp.weixin.qq.com/s/2GXBNOUq3jlysipftz8TpA" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：序-为什么你“会用 LLM”，但做不出复杂应用？</a></li>
<li><a href="https://mp.weixin.qq.com/s/v-z6EHY300ElOxdGPdzc0w" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第一章LLM到底在做什么？</a></li>
<li><a href="https://mp.weixin.qq.com/s/t_BuAW9i0npcaJdua3Am2Q" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第二章 模型不是重点，参数才是你真正的控制面板</a></li>
<li><a href="https://mp.weixin.qq.com/s/vzt0bGwcfnASOiBa0Kc7VQ" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第三章 为什么我的Prompt表现很糟？</a></li>
<li><a href="https://mp.weixin.qq.com/s/Nk-N34TLJVCTI5F4k5rGaQ" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第四章Prompt 的工程化结构设计</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZQbztqBq7_PzynG06N4-mg" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第五章 从 Prompt 到 Prompt 模板与工程治理</a></li>
<li><a href="https://mp.weixin.qq.com/s/nnKspRO87xbrn4-LBV3RNA" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第六章 上下文窗口的真实边界</a></li>
<li><a href="https://mp.weixin.qq.com/s/_5D2tF6CPnafj5mlmlwLNw" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第七章：从 “堆上下文” 到 “管理上下文”</a></li>
</ul>
<hr>
<p>实战</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/96rHyp_gBUgmA2dhSbzNww" target="_blank" rel="noopener noreferrer">大模型应用开发实战：两百行实现一个自然语言地址提取智能体</a></li>
<li><a href="https://mp.weixin.qq.com/s/SnXdTB6tYqAzG7HgbnTSAQ" target="_blank" rel="noopener noreferrer">大模型应用开发实战：基于SpringAI与大模型的零配置发票智能提取架构</a></li>
<li><a href="https://mp.weixin.qq.com/s/NHqLJbos-_nrxNNmhg7IBQ" target="_blank" rel="noopener noreferrer">实战 | 零基础搭建知识库问答机器人：基于SpringAI+RAG的完整实现</a></li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://spring.io/blog/2026/01/13/spring-ai-generic-agent-skills" target="_blank" rel="noopener noreferrer">Spring AI Agentic Patterns (Part 1): Agent Skills - Modular, Reusable Capabilities</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/A06-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>第 7 章：从 “堆上下文” 到 “管理上下文”</title>
      <link>https://ppai.top/ai-guides/tutorial/hello-llm/12.%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86.html</link>
      <guid>https://ppai.top/ai-guides/tutorial/hello-llm/12.%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">第 7 章：从 “堆上下文” 到 “管理上下文”</source>
      <description>在上一章中，我们已经明确否定了一种做法： 把上下文当作“无限可用的记忆容器”。 在大模型应用给开发时，上下文窗口的限制是一个不得不考虑的问题，不管是哪个模型，终究是有一个长度上限，显然有上限那么就不可能满足无限轮次的对话存储，因此一个更难、也更重要的问题也就出来了： 在有限的上下文窗口里，哪些信息值得被保留？ 首先我们的明确，这不是大模型需要关注的事情，而是我们这种基于大模型做应用开发的苦逼码农需要重点考虑的系统设计决策 —— 它的具体设计，直接决定了多轮对话中系统的稳定性、准确性，甚至是用户对我们产品的信任度</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 14:25:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>在上一章中，我们已经明确否定了一种做法：</p>
<blockquote>
<p><strong>把上下文当作“无限可用的记忆容器”。</strong></p>
</blockquote>
<p>在大模型应用给开发时，上下文窗口的限制是一个不得不考虑的问题，不管是哪个模型，终究是有一个长度上限，显然有上限那么就不可能满足无限轮次的对话存储，因此一个更难、也更重要的问题也就出来了：</p>
<blockquote>
<p><strong>在有限的上下文窗口里，哪些信息值得被保留？</strong></p>
</blockquote>
<p>首先我们的明确，这不是大模型需要关注的事情，而是我们这种基于大模型做应用开发的苦逼码农需要重点考虑的<strong>系统设计决策</strong> —— 它的具体设计，直接决定了多轮对话中系统的稳定性、准确性，甚至是用户对我们产品的信任度</p>
<hr>
<h3> 7.1 技术决策的第一步：承认信息是有“等级”的</h3>
<p>在企业知识库助手、智能客服、私域助手等真实对话场景中，并不是所有信息都同等重要。如果我们不主动对信息进行区分，模型就会被迫“平均对待”，从而导致核心规则被冗余内容所稀释</p>
<p>从工程化实践角度出发，我们至少需要区分三类信息，它们的优先级和保留策略完全不同：</p>
<figure><img src="/imgs/column/llm/12-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 1.不变约束（最高优先级）</h4>
<p>指系统必须始终遵守的核心规则，不随对话内容变化而改变。</p>
<p>例如：</p>
<ul>
<li><em>系统角色定义（“你是 XX 公司的内部知识库助手，不对外提供服务”）</em></li>
<li><em>行为边界（“仅回答员工手册、财务制度中的内容，超出范围需明确拒绝”）</em></li>
<li><em>安全规则（“禁止泄露员工个人信息、未公开的业务数据”）</em></li>
</ul>
<p>这类信息必须<strong>永远保留在上下文窗口中</strong>，且位置要尽可能靠前（减少注意力衰减影响）,不可也不应该被压缩或删除</p>
<h4> 2.会话状态（中高优先级）</h4>
<p>指当前对话中形成的关键共识、未完成的任务或用户的核心意图，是维持对话连贯性的基础。</p>
<p>例如：</p>
<ul>
<li><em>当前讨论主题（“用户正在咨询 2025 年新版差旅报销政策”）</em></li>
<li><em>已确认事实（“用户是销售部员工，经常出差至华东地区”）</em></li>
<li><em>待解决问题（“需确认‘高铁一等座是否可报销’”）</em></li>
</ul>
<p>这类信息需要<strong>持续维护和更新</strong>，实时同步对话进度，移除已闭环的内容，保留未完成事项和核心共识，确保大模型能准确识别到“当前阶段”</p>
<h4> 3. 瞬时上下文（低优先级）</h4>
<p>指对话中的临时交互、举例说明或过渡性内容，对长期连贯性影响较小。例如：</p>
<ul>
<li>用户的临时追问（“那二等座呢？”）</li>
<li>辅助说明（“比如我上次去上海的高铁票是一等座”）</li>
<li>无关寒暄（“谢谢，我再看看”）</li>
</ul>
<p>这类信息可以<strong>按需保留最近几轮（通常是2-3轮）</strong>，超出范围后可直接丢弃，避免占用上下文和分散注意力</p>
<hr>
<p>接下来我们通过一个模拟的对话案例，来辅助说明一下</p>
<p><strong>对话场景</strong>：销售部员工小李咨询差旅报销政策，过程中穿插寒暄和临时追问。</p>
<p><strong>未分层上下文管理（反面案例）</strong>：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>问题分析</strong>：未分层导致“系统角色”（不变约束）被瞬时内容挤压，需重复提醒；同时未聚焦“销售部+华东出差”（会话状态），对话连贯性差。</p>
<p><strong>已分层上下文管理（正面案例）</strong>：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p><strong>上下文失控的本质，不是信息太多，而是信息没有被分层。</strong></p>
<p>让低优先级的内容挤占了高优先级信息的 “生存空间”。</p>
</blockquote>
<hr>
<h3> 7.2 为什么“直接摘要历史”并不是银弹？</h3>
<p>在意识到上下文有限后，很多小伙伴的第一直觉就是：</p>
<blockquote>
<p><em>那就把历史对话总结一下，再塞回去。</em></p>
</blockquote>
<p>这个思路的方向是对的（减少冗余信息），但如果不区分信息等级，简单做 “全量摘要”，会引入新的系统风险：</p>
<ul>
<li>约束信息被压缩：比如原系统提示中的 “5 条核心规则” 可能被摘要简化为 “遵守公司规定”，丢失关键细节。</li>
<li>错误结论被固化：如果某轮回答存在错误（比如 “年假可累计 15 天” 实际应为 10 天），摘要可能会保留这个错误并持续传递。</li>
<li>决策过程被抹平：用户曾明确拒绝的方向（比如 “我不想了解北京的政策”）可能在摘要中被忽略，导致模型重复无效信息。</li>
</ul>
<p>以差旅报销助手为例，对比两种方式的上下文处理结果：</p>
<table>
<thead>
<tr>
<th><strong>全量摘要（错误示范）</strong></th>
<th><strong>结构化状态（正确示范）</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>摘要内容：“销售部小李咨询2024年差旅报销政策，关心华东地区高铁一等座和飞机经济舱报销问题，助手已告知可报销，需提供凭证。”<br><strong>问题</strong>：未保留“高铁一等座仅限华东地区”“飞机经济舱4小时以上可升舱”等关键会话状态，也未体现“逾期报销需补报”的不变约束，后续对话易出错。</td>
<td>【不变约束】：差旅报销需在返程后7天内提交，逾期走补报流程；仅回答2024年新版政策。 <br>【会话状态】：用户小李（销售部），核心需求为华东地区差旅交通报销；已确认高铁一等座可报销（需凭证+审批单）；待补充飞机经济舱升级规则。<br> 【瞬时上下文】：忽略“上次上海一等座票”“寒暄问候”等内容。</td>
</tr>
</tbody>
</table>
<p>这意味着：</p>
<blockquote>
<p><strong>我们需要的不是“一个摘要”，而是“结构化状态”。</strong> —— 即针对不同等级的信息，设计专门的保留和更新策略。</p>
</blockquote>
<p>一个常见的结构化状态管理流程如下</p>
<figure><img src="/imgs/column/llm/12-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h3> 7.3 本章小结：上下文开始变成工程对象</h3>
<p>到这里，你应该已经意识到：</p>
<p>上下文不再是自然增长的聊天记录，而是一个<strong>需要被主动设计、分层管理、动态维护的系统状态</strong></p>
<p>多轮对话的可靠性，从来不取决于“上下文窗口有多大”，而取决于“高优先级信息是否能稳定地影响模型决策”。不变约束的坚守、会话状态的精准同步、瞬时内容的合理舍弃，三者共同构成了上下文管理的核心工程逻辑。</p>
<p>这一步认知转变，会直接引出下一个问题：</p>
<blockquote>
<p><strong>既然信息需要被分层管理，那“记忆”是否也应该分层？</strong></p>
</blockquote>
<p>这正是下一章要探讨的核心问题 —— 如何通过短期记忆、长期记忆的分层设计，实现上下文管理的工程化落地，让 LLM 应用具备更稳定、更智能的多轮对话能力。</p>
<h4> 思考题</h4>
<ol>
<li>
<p>在你的 LLM 应用场景中，哪些信息属于“不变约束”？如何确保这些信息不被压缩或丢失？</p>
</li>
<li>
<p>针对“会话状态”的更新，你会设计哪些规则来判断“内容是否已闭环”？</p>
</li>
<li>
<p>如果上下文窗口极度紧张（如仅 4k  tokens），你会优先舍弃哪类信息，如何平衡准确性与连贯性？</p>
</li>
</ol>
<blockquote>
<p>（注：文档部分内容可能由 AI 生成）</p>
</blockquote>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/llm/12-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>D04.从0到1实现一个支持RAG的问答机器人</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E5%BA%94%E7%94%A8%E7%AF%87/D04.%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81RAG%E7%9A%84%E9%97%AE%E7%AD%94%E6%9C%BA%E5%99%A8%E4%BA%BA.html</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E5%BA%94%E7%94%A8%E7%AF%87/D04.%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81RAG%E7%9A%84%E9%97%AE%E7%AD%94%E6%9C%BA%E5%99%A8%E4%BA%BA.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">D04.从0到1实现一个支持RAG的问答机器人</source>
      <description>基于Spring AI实现RAG知识库问答机器人：从零到一的完整教程 一、引言 随着大语言模型的快速发展，RAG（Retrieval-Augmented Generation）技术已成为构建知识库问答系统的核心技术之一。本文将带领大家从零开始，使用Spring AI框架构建一个支持文档上传的知识库问答机器人，帮助大家深入理解RAG技术的核心原理和实践应用。 1.1 什么是RAG？ RAG（检索增强生成）是一种结合了信息检索和文本生成的技术。它的基本工作流程是： 用户提出问题 系统从知识库中检索相关信息 大语言模型基于检索到的信息生成答案</description>
      <category>SpringAI</category>
      <pubDate>Thu, 22 Jan 2026 17:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 基于Spring AI实现RAG知识库问答机器人：从零到一的完整教程</h1>
<h2> 一、引言</h2>
<p>随着大语言模型的快速发展，RAG（Retrieval-Augmented Generation）技术已成为构建知识库问答系统的核心技术之一。本文将带领大家从零开始，使用Spring AI框架构建一个支持文档上传的知识库问答机器人，帮助大家深入理解RAG技术的核心原理和实践应用。</p>
<h3> 1.1 什么是RAG？</h3>
<p>RAG（检索增强生成）是一种结合了信息检索和文本生成的技术。它的基本工作流程是：</p>
<ol>
<li>用户提出问题</li>
<li>系统从知识库中检索相关信息</li>
<li>大语言模型基于检索到的信息生成答案</li>
</ol>
<p>从系统设计角度触发，RAG 的核心作用可以被描述为：</p>
<blockquote>
<p><strong>在LLM调用生成响应之前，由系统动态构造一个“最小且相关的知识上下文”。</strong></p>
</blockquote>
<p>请注意两个关键词：</p>
<ul>
<li><strong>动态</strong>：每次问题都不同，检索的知识也不同（比如用户问 A 产品时找 A 的文档，问 B 产品时找 B 的文档）</li>
<li><strong>最小</strong>：只注入必要信息（比如用户问 “A 产品的定价”，就只塞定价相关的片段，而非整份产品手册）</li>
</ul>
<p>RAG可以有效的弥补上下文窗口的先天不足：不再需要把所有知识塞进窗口，而是只在需要时 “临时调取” 相关部分，既避免了窗口溢出，又减少了注意力竞争。</p>
<h3> 1.2 RAG在交互链路中的位置</h3>
<p>接下来我们以RAG的经典应用场景——企业知识库为例，来看一下RAG在这个流程中所处的位置</p>
<figure><img src="/imgs/column/llm/17-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在这个结构中，RAG主要就是在用户提问与向LLM发起请求这个中间段，用于检索关联的文档构建上下文</p>
<h3> 1.3 RAG工作原理</h3>
<p>我们以一张图来介绍RAG的工作原理，具体的RAG详细介绍，请参照文末引用</p>
<figure><img src="/imgs/column/springai/D04-1.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 二、核心实现</h2>
<h3> 2.1 项目结构概览</h3>
<p>项目源码可以在 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/app-projects/D05-rag-qa-bot" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a> 获取，文末有所有相关的参考信息</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.2 项目初始化</h3>
<h4> 2.2.1 Maven依赖配置</h4>
<p>首先，我们需要在<code>pom.xml</code>中配置必要的依赖：</p>
<ul>
<li>其中关于向量数据库、tika的文档解析属于核心依赖项</li>
<li>hanlp适用于无法直接使用EmbeddingModel的场景，在我们的示例中，会实现一个基础的文档向量化方案，其中会采用Hanlp来做中文分词</li>
<li>使用智谱的免费大模型来体验我们的RAG知识库问答（当然也可以基于OpenAI-Starter来切换其他的大模型，使用层面并没有改变，只需要替换依赖、api配置即可）</li>
</ul>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们引入了Spring AI的核心依赖，以及用于文档处理的Tika和PDF读取器，还特别加入了HanLP中文分词库来优化中文处理效果。</p>
<h4> 2.2.2 应用配置</h4>
<p>在<code>application.yml</code>中配置API密钥和相关参数：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.3 自定义向量存储实现</h3>
<p>通常RAG会使用一些成熟的向量数据库（如Pinecone、weaviate、qdrant、milvus或者es、redis等），但是考虑到安装、环境配置等成本，我们接下来会实现一个基础的自定义的文本向量库 <code>TextBasedVectorStore</code>，基于内存实现，无需额外的外部依赖，单纯的用来体验RAG并没有太大问题</p>
<p>SpringAI原生提供了一个基于内存的向量数据库<code>SimpleVectorStore</code>，在它的实现中，向量数据写入，依赖向量模型，因此如果有额度使用大模型厂家提供的EmbeddingModel时，直接用它进行测试即可；</p>
<p>当然如果你现在并没有渠道(💰)使用向量模型的，那也没关系，接下来我们将参照SpringAI的<code>SimpleVectorStore</code>实现的一个自定义的向量库<code>TextBasedVectorStore</code>，提供一套不依赖向量模型的解决方案，特别适合快速原型开发，核心实现如下（当然你也完全可以忽略它，它不是我们的重点）</p>
<h4> 2.3.1 TextBasedVectorStore - 文本匹配向量存储</h4>
<p>在下面的实现中，重点体现了两个方法</p>
<ul>
<li>doAdd: 将文档保存到向量数据库中（文档分片 -&gt; 向量化 -&gt; 存储）</li>
<li>doSimilaritySearch: 基于相似度的搜索</li>
</ul>
<blockquote>
<p>需要注意一点，文档的向量化与搜索时传入文本的向量化，需要采用同一套向量化方案（why?）</p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.3.2 DocumentChunker - 文档分块器</h4>
<blockquote>
<p>合理地将长文档分块是RAG系统的关键环节，合理的分块大小，可以有效的增加检索效率、提高准确率、减少上下文长度</p>
</blockquote>
<p>在真实的RAG应用中，这一块具体的方案挺多的，比如固定尺寸（下面的方案）、地柜拆分、语义拆分、结构化拆分（如结构化的markdown文档就很适合）、延迟拆分、自适应拆分、层级拆分、LLM驱动拆分、智能体拆分等（具体这一块我也没有深入学习，有兴趣的小伙伴问下AI吧~🤣）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.3.3 DocumentQuantizer - 文档量化器</h4>
<p>使用HanLP进行中文分词，实现了一个简单的文档向量化工具类（同样的你也完全可以忽略它的具体实现，因为它的效果显然比使用EmbedingModel要差很多很多，但用于学习体验RAG也基本够用）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.3.4 注册向量库</h4>
<p>接下来就是注册使用这个向量库，在配置类or启动类中，添加下面这个声明即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.4 SpringAI向量存储</h3>
<p>上面2.3适用于无法直接使用大模型厂家的向量模型的场景，如果可以直接使用，那么上面的全部可以直接忽略掉，直接使用下面的方式进行声明向量库即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.5 问答服务实现</h3>
<p>接下来我们进入核心的基于RAG的QA问答机器人的实现</p>
<h4> 2.5.1 QaBoltService - 核心问答服务</h4>
<h5> Pre. 问答服务流程</h5>
<p>我们先从时序的角度来看一下这个问答服务的核心交互流程</p>
<figure><img src="/imgs/column/springai/D04-2.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在这个时序过程中，为了简化大家的理解，我们将文档的向量化存储与问答进行了拆分</p>
<p><strong>第一步：文档向量化</strong></p>
<p>这一部分包含RAG应用数据准备阶段的完整过程</p>
<ul>
<li>数据提取</li>
<li>文本分割</li>
<li>向量化</li>
</ul>
<p><strong>第二步：问答</strong></p>
<ul>
<li>应用层响应用户提问</li>
<li>从向量数据库检索相似度高的文档信息</li>
<li>注入提示词</li>
<li>访问大模型，获取答案</li>
</ul>
<h5> Impl. 核心实现</h5>
<p>接下来我们看一下具体的实现（上面的步骤分割得很清楚，但是实际使用时，用户可以在问答中上传附件，这个附件也会作为我们知识库的一部分，因此具体的实现中，你会发现这两部耦合在一起了，请不要惊讶）</p>
<p><strong>step1: 初始化ChatClient</strong></p>
<p>在开始之前，我们首先参照SpringAI的官方教程，通过Advisor来初始化支持RAG的<code>ChatClient</code></p>
<blockquote>
<p>官方文档：<a href="https://docs.spring.io/spring-ai/reference/api/retrieval-augmented-generation.html" target="_blank" rel="noopener noreferrer">https://docs.spring.io/spring-ai/reference/api/retrieval-augmented-generation.html</a></p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来就是响应问答的实现，这里分两步</p>
<p><strong>step2: 文档处理</strong></p>
<p>处理用户上传的附件，即上面时序图中的第一步，解析文档、切分、向量化、保存到向量库;</p>
<p>下面的实现中主要体现的是基于SpringAI封装的tika与pdf文档解析starter，来提取上传的文档，生成供向量数据库使用的<code>List&lt;Document&gt;</code>; 而具体的文档切分、向量化等则是在上面的<code>TextBasedVectorStore</code>实现</p>
<blockquote>
<p>注：为了一个文档，重复进行数据处理，我们在元数据中维护了文档的 md5，这样当添加到向量库中时，就可以基于这个md5来进行去重了（一个工程化实现方面的小技巧~）</p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>step3: 问答实现</strong></p>
<p>然后就是具体的问答实现，这里主要是借助 <code>QuestionAnswerAdvisor</code> 来封装RAG相关的信息</p>
<blockquote>
<p>说明：在下面的实现中，使用了自定义的提示词模板，当然也可以直接使用SpringAI默认的方案</p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到这里，一个基于RAG的问答机器人的核心逻辑，已经全部完成，接下来我们进入体验阶段</p>
<h4> 2.5.2 控制器实现</h4>
<p>QaApiController - API控制器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.6 前端界面</h3>
<p>交互式聊天界面，前端界面提供了文件上传和问答交互功能，具体的代码实现请参考文末的项目源码地址，这里就不贴了（主要是太长了~）</p>
<h2> 三、体验与小结</h2>
<h3> 3.1 启动类</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.2 问答提示词</h3>
<p>在 <code>resources/prompts/qa-prompts.pt</code> 中维护我们的qa机器人的系统提示词（DeepSeek生成的）</p>
<div class="language-pt line-numbers-mode" data-ext="pt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.3 运行与测试</h3>
<ol>
<li><strong>启动应用</strong>：运行<code>D05Application</code>主类</li>
<li><strong>访问页面</strong>：打开<code>http://localhost:8080/chat</code></li>
<li><strong>上传文档</strong>：选择PDF、Word或文本文件</li>
<li><strong>提问测试</strong>：在输入框中输入关于文档的问题</li>
</ol>
<p>当然在启动时，可以在启动参数中指定大模型的ApiKey，也可以直接修改<code>applicatino.yml</code>，直接维护上apiKey也可以哦</p>
<figure><img src="/imgs/column/springai/D04-3.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在上面这个示意图中，我上传的是 <a href="https://mp.weixin.qq.com/s/1s8NC-dCNIfqTXAHyN2e1g" target="_blank" rel="noopener noreferrer">像Excel一样选择网页表格 &amp; 支持选中表单生成sql的神器：TableHelper</a> 的宣传文档，显然是没有被大模型检索、训练过的，从问答来看，效果还是不错的</p>
<p>但是请注意，这个只是给大家用来体验RAG的，用来学习验证还是不错的；但是真实场景显然比我们提到的内容还多很多，比如</p>
<ul>
<li>安全隐私：不同用户的知识库文件需要隔离</li>
<li>存储优化：上下文窗口的管理、对话历史的管理</li>
<li>检索优化：多路召回、查询语义理解、查询改写等</li>
<li>模型优化：成本、效率的权衡</li>
<li>监控体系：链路追踪、日志分析、告警等</li>
<li>DevOps: CI/CD，容器编排</li>
<li>体验、性能等</li>
</ul>
<h3> 3.4 核心技术要点小结</h3>
<h4> 1. RAG工作流程</h4>
<ul>
<li><strong>检索阶段</strong>：当用户提问时，系统首先将问题转换为向量，然后在文档向量库中查找相似的文档片段</li>
<li><strong>生成阶段</strong>：将检索到的相关文档内容与用户问题一起输入大语言模型，生成最终答案</li>
</ul>
<h4> 2. 文档处理优化</h4>
<ul>
<li><strong>中文分词</strong>：使用HanLP进行精确的中文分词，提高语义理解准确性</li>
<li><strong>文档分块</strong>：将长文档合理分块，保持语义完整性的同时便于检索</li>
<li><strong>去重机制</strong>：通过MD5哈希避免重复上传相同的文档</li>
</ul>
<h4> 3. 性能优化</h4>
<ul>
<li><strong>相似度计算</strong>：使用余弦相似度算法计算文本相似度</li>
<li><strong>缓存机制</strong>：对已处理的文档进行缓存，避免重复处理</li>
<li><strong>流式响应</strong>：使用SSE实现答案的流式返回，提升用户体验</li>
</ul>
<p>本文通过一个最小成本（技术和资金成本都很小）的方案，我们实现了一个完整的RAG知识库问答机器人。</p>
<p>通过这个项目，相信对RAG感兴趣，想快速体验一下完成流程的小伙伴，可以有一个动手实操的机会。</p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/llm/17-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>SpringAI</title>
      <link>https://ppai.top/ai-guides/ai-dev/</link>
      <guid>https://ppai.top/ai-guides/ai-dev/</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">SpringAI</source>
      <description>这里主要介绍的是SpringAI进行AI应用开发的系列教程 注意：在使用SpringAI时，对jdk和springboot有最低的版本要求 jdk: 17+/21 SpringBoot: 3+ 核心技术栈： SpringAI 1.1.2/2.0.0-M2 LangGraph4J 本篇专栏将从四个系列出发 1.基础教程 主要介绍SpringAI的基础使用，对应的项目工程以 Sxx- 开头，通过这些实例，您将掌握SpringAI的基础知识（如提示词、上下文、架构化输出、tool calling, MCP, advise, ChatClient, 多模型等），并开始使用SpringAI进行大模型应用开发</description>
      <pubDate>Thu, 22 Jan 2026 08:45:40 GMT</pubDate>
      <content:encoded><![CDATA[<p>这里主要介绍的是SpringAI进行AI应用开发的系列教程</p>
<p>注意：在使用SpringAI时，对jdk和springboot有最低的版本要求</p>
<ul>
<li>jdk: 17+/21</li>
<li>SpringBoot: 3+</li>
</ul>
<p>核心技术栈：</p>
<ul>
<li>SpringAI 1.1.2/2.0.0-M2</li>
<li>LangGraph4J</li>
</ul>
<p>本篇专栏将从四个系列出发</p>
<h3> 1.基础教程</h3>
<p>主要介绍SpringAI的基础使用，对应的项目工程以 <code>Sxx-</code> 开头，通过这些实例，您将掌握SpringAI的基础知识（如提示词、上下文、架构化输出、tool calling, MCP, advise, ChatClient, 多模型等），并开始使用SpringAI进行大模型应用开发</p>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">01.创建一个SpringAI-Demo工程.md</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/02.%E6%8F%90%E7%A4%BA%E8%AF%8D%E8%AE%BE%E7%BD%AE.html" target="blank">02.提示词的使用.md</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-2" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-2"> <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/03.%E7%BB%93%E6%9E%84%E5%8C%96%E8%BF%94%E5%9B%9E.html" target="blank">03.结构化返回</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-3" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-3"> <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/04.%E8%81%8A%E5%A4%A9%E4%B8%8A%E4%B8%8B%E6%96%87.html" target="blank">04.聊天上下文实现多轮对话</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-4" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-4"> <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/05.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5.html" target="blank">05.自定义大模型接入</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-5" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-5"> <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/06.%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8FunctionCalling.html" target="blank">06.Function Tool工具调用</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-6" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-6"> <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/07.%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84McpServer.html" target="blank">07.实现一个简单的McpServer</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-7" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-7"> <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/08.MCP%20Server%E7%AE%80%E5%8D%95%E9%89%B4%E6%9D%83%E7%9A%84%E5%AE%9E%E7%8E%B0.html" target="blank">08.MCP Server简单鉴权的实现</a>]</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-8" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-8"> <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/09.ChatClient%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.html" target="blank">09.ChatClient使用说明</a>]</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-9" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-9"> <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/10.Advisor%E5%AE%9E%E7%8E%B0SpringAI%E4%BA%A4%E4%BA%92%E5%A2%9E%E5%BC%BA.html" target="blank">10.Advisor实现SpringAI交互增强</a>]</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-10" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-10"> <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/11.%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%9E%8B.html" target="blank">11.图像模型-生成图片</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-11" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-11"> <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/12.%E5%A4%9A%E6%A8%A1%E6%80%81%E5%AE%9E%E7%8E%B0%E9%A3%9F%E6%9D%90%E5%9B%BE%E7%89%87%E5%8D%A1%E8%B7%AF%E9%87%8C%E8%AF%86%E5%88%AB%E7%A4%BA%E4%BE%8B.html" target="blank">12.多模态实现食材图片卡路里识别示例</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-12" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-12"> <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/13.%E6%94%AF%E6%8C%81MCP%20Client%E7%9A%84AI%E5%AF%B9%E8%AF%9D%E5%AE%9E%E7%8E%B0.html" target="blank">13.支持MCP Client的AI对话实现</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-13" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-13"> <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/14.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AALanggraph4j%E5%AE%9E%E4%BE%8B%E5%B7%A5%E7%A8%8B.html" target="blank">14.创建一个LangGraph4J示例工程</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-14" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-14"> <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/15.%E6%8E%A5%E5%85%A5OpenAI%E6%8E%A5%E5%8F%A3%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%A4%A7%E6%A8%A1%E5%9E%8B.html" target="blank">15.接入OpenAI接口风格大模型</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-15" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-15"> <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/16.%E5%BC%82%E6%AD%A5%E6%B5%81%E5%BC%8F%E6%A8%A1%E5%9E%8B%E8%B0%83%E7%94%A8.html" target="blank">16.异步流式模型调用</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-16" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-16"> <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/17.%E6%8E%A8%E7%90%86%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5%E4%B8%8E%E6%8E%A8%E7%90%86%E8%BF%87%E7%A8%8B%E8%BF%94%E5%9B%9E.html" target="blank">17.推理大模型接入与推理过程返回</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-17" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-17"> <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/18.%E8%AF%AD%E9%9F%B3%E6%A8%A1%E5%9E%8B%E4%B9%8B%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB.html" target="blank">18.语音模型之语音识别</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-18" disabled="disabled"><label class="task-list-item-label" for="task-item-18"> <a href="">检索增强生成RAG</a></label></li>
</ul>
<h3> 2.进阶教程</h3>
<p>进阶相关将主要介绍如何更好的使用SpringAI进行大模型应用开发，对应的实例工程都放在 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/advance-projects" target="_blank" rel="noopener noreferrer">advance-projects</a> 下</p>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-19" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-19"> <a href="/ai-guides/ai-dev/%E8%BF%9B%E9%98%B6%E7%AF%87/A01.%E4%BD%BF%E7%94%A8MySql%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html" target="blank">01.使用MySql持久化对话历史</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-20" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-20"> <a href="/ai-guides/ai-dev/%E8%BF%9B%E9%98%B6%E7%AF%87/A02.%E4%BD%BF%E7%94%A8H2%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html" target="blank">02.使用H2持久化对话历史</a>]</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-21" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-21"> <a href="/ai-guides/ai-dev/%E8%BF%9B%E9%98%B6%E7%AF%87/A03.%E4%BD%BF%E7%94%A8Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html" target="blank">03.使用Redis持久化对话历史</a>]</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-22" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-22"> <a href="/ai-guides/ai-dev/%E8%BF%9B%E9%98%B6%E7%AF%87/A04.%E4%BD%BF%E7%94%A8LangGraph4J%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%BD%AE%E5%AF%B9%E8%AF%9D.html" target="blank">04.使用LangGraph4J实现多伦对话</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-23" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-23"> <a href="/ai-guides/ai-dev/%E8%BF%9B%E9%98%B6%E7%AF%87/A05.%E4%BD%BF%E7%94%A8LangGraph4J%E5%AE%9E%E7%8E%B0Agent%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9.html" target="blank">05.使用LangGraph4J实现Agent路由选择</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-24" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-24"> <a href="https://mp.weixin.qq.com/s/ujxVleNhjxzUgL-rjfFcVA" target="_blank" rel="noopener noreferrer">06.告别传统AI开发！SpringAI Agent + Skills重新定义智能应用</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-25" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-25"> <a href="https://mp.weixin.qq.com/s/LcvmiIERs6aOIlRAKGGnFg" target="_blank" rel="noopener noreferrer">07.Spring AI中的多轮对话艺术：让大模型主动提问获取明确需求</a></label></li>
</ul>
<h3> 3.应用教程</h3>
<p>以搭建完整可用的SpringAI应用为目的，演示SpringAI的业务边界和表现，对应项目工都放在 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/app-projects" target="_blank" rel="noopener noreferrer">app-projects</a> 下</p>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-26" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-26"> <a href="/ai-guides/ai-dev/%E5%BA%94%E7%94%A8%E7%AF%87/D01.%E4%BB%8E0%E5%88%B01%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8E%E5%A4%A9%E6%B0%94%E7%9A%84%E6%97%85%E6%B8%B8%E7%BE%8E%E9%A3%9F%E6%8E%A8%E8%8D%90%E6%99%BA%E8%83%BD%E4%BD%93.html" target="blank">从0到1创建一个基于天气的旅游美食推荐智能体</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-27" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-27"> <a href="https://mp.weixin.qq.com/s/96rHyp_gBUgmA2dhSbzNww" target="_blank" rel="noopener noreferrer">大模型应用开发实战：两百行实现一个自然语言地址提取智能体</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-28" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-28"> <a href="https://mp.weixin.qq.com/s/SnXdTB6tYqAzG7HgbnTSAQ" target="_blank" rel="noopener noreferrer">再见，OCR模板！你好，发票智能体：基于SpringAI与大模型的零配置发票智能提取架构</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-29" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-29"> <a href="https://mp.weixin.qq.com/s/NHqLJbos-_nrxNNmhg7IBQ" target="_blank" rel="noopener noreferrer">实战 | 零基础搭建知识库问答机器人：基于SpringAI+RAG的完整实现</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-30" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-30"> <a href="https://mp.weixin.qq.com/s/QyuWZ4EZ32pbcWn3fVphHQ" target="_blank" rel="noopener noreferrer">我用SpringAI造了个「微信红包封面设计师」</a></label></li>
</ul>
<h3> 4.源码解读</h3>
<p>以源码的视角，介绍SpringAI的核心实现，对应的项目工程以 <code>Yxx-</code> 开头</p>
]]></content:encoded>
    </item>
    <item>
      <title>LLM教程</title>
      <link>https://ppai.top/ai-guides/tutorial/</link>
      <guid>https://ppai.top/ai-guides/tutorial/</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">LLM教程</source>
      <description>技术专栏 ❤️ 扫盲 hello llm:零基础入门大模型应用开发 📝 AiCoding ai coding:氛围编程、项目实战</description>
      <pubDate>Thu, 22 Jan 2026 08:45:40 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 技术专栏</h1>
<h2> ❤️ 扫盲</h2>
<p><a href="/ai-guides/tutorial/hello-llm/" target="blank">hello llm:零基础入门大模型应用开发</a></p>
<h2> 📝 AiCoding</h2>
<p><a href="/ai-guides/tutorial/ai-coding/" target="blank">ai coding:氛围编程、项目实战</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>关于我</title>
      <link>https://ppai.top/ai-guides/me/</link>
      <guid>https://ppai.top/ai-guides/me/</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">关于我</source>
      <description>关于我</description>
      <pubDate>Thu, 22 Jan 2026 08:45:40 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 关于我</h2>
]]></content:encoded>
    </item>
    <item>
      <title>关于我</title>
      <link>https://ppai.top/ai-guides/me/about-me.html</link>
      <guid>https://ppai.top/ai-guides/me/about-me.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">关于我</source>
      <description>1. 自我介绍 不习惯分享私人相关的，简单说几个关键点 常用名：一灰，一灰灰，一灰灰blog 性别：男 工作：8+ 履历：一线大厂、千人规模、创业团队、国企都待过 2. 有啥成就 比较惭愧，没有太大的成就，业内也不算出名，甚至是小透明 个人网站： www.hhui.top GitHub： https://github.com/liuyueyi 上架的app： https://play.google.com/store/apps/details?id=com.yhh.zhongdian 活跃网站： https://juejin.cn/user/377887729916126</description>
      <pubDate>Thu, 22 Jan 2026 08:45:40 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 1. 自我介绍</h2>
<p>不习惯分享私人相关的，简单说几个关键点</p>
<ul>
<li>常用名：一灰，一灰灰，一灰灰blog</li>
<li>性别：男</li>
<li>工作：8+</li>
<li>履历：一线大厂、千人规模、创业团队、国企都待过</li>
</ul>
<h2> 2. 有啥成就</h2>
<p>比较惭愧，没有太大的成就，业内也不算出名，甚至是小透明</p>
<ul>
<li>个人网站： <a href="www.hhui.top">www.hhui.top</a></li>
<li>GitHub： <a href="https://github.com/liuyueyi" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi</a></li>
<li>上架的app： <a href="https://play.google.com/store/apps/details?id=com.yhh.zhongdian" target="_blank" rel="noopener noreferrer">https://play.google.com/store/apps/details?id=com.yhh.zhongdian</a></li>
<li>活跃网站： <a href="https://juejin.cn/user/377887729916126" target="_blank" rel="noopener noreferrer">https://juejin.cn/user/377887729916126</a></li>
</ul>
<h2> 3. 什么时候开始的分享</h2>
<p>最早是在16、17年的时候开始在开源中国上分享一些自己的笔记，然后就一直坚持了下来，至今所有的文章加起来应该也有五六百篇了，当然其中有很多比较水；但也有不少文章是注入了心血的</p>
<p>有到我站点逛的小伙伴可能也看到了，有几个分站</p>
<ul>
<li><a href="https://blog.hhui.top" target="_blank" rel="noopener noreferrer">https://blog.hhui.top</a> ： 最早搭建的博客站点，记录的内容多，且零散，检索阅读并不友好，虽然东西很多，但是很多时候我自己都找不到，更何况其他的小伙伴呢</li>
<li><a href="https://spring.hhui.top" target="_blank" rel="noopener noreferrer">https://spring.hhui.tpp</a>： 这个站点相比于上面一个更垂直一点，全是spring相关的博文，每一篇文章都搭配有对应的项目源码，目前也在持续更新迭代中</li>
<li><a href="https://hhui.top" target="_blank" rel="noopener noreferrer">https://hhui.top</a>：主站点，为了解决上面说到的知识点分散的问题，近期我也在做知识汇总，形成一个一个专栏性质的小册，后续也会逐渐整理为pdf，供有离线学习诉求的小伙伴查阅</li>
</ul>
<h2> 4. 最近在干什么</h2>
<p>在22年中开始，和楼仔（强烈推荐关注他的公众号“楼仔”，分享的都是技术干活）凑一起搞事情，目前项目已上线，一个开源的博客论坛系统，将会围绕这个项目，出一版相关的教程，希望能基于此为各位有志于从事编程事业的小伙伴，提供一个极佳的练手项目、学习平台</p>
<ul>
<li>源码地址：<a href="https://github.com/itwanger/paicoding" target="_blank" rel="noopener noreferrer">https://github.com/itwanger/paicoding</a></li>
<li>论坛地址：<a href="https://paicoding.com/" target="_blank" rel="noopener noreferrer">https://paicoding.com/</a></li>
</ul>
<h2> 5. 有公众号么</h2>
<p>我的公众号是："一灰灰blog"， 有兴趣的小伙伴可以关注一波</p>
<figure><img src="https://spring.hhui.top/spring-blog/imgs/info/info.png" alt="一灰灰的公众号" tabindex="0" loading="lazy"><figcaption>一灰灰的公众号</figcaption></figure>
<p>我的小伙伴楼仔的公众号： "楼仔" 同时也推荐各位</p>
<figure><img src="https://files.mdnice.com/user/13837/4b47ac79-8256-47cf-ac1a-036729635246.png" alt="楼仔的公众号" tabindex="0" loading="lazy"><figcaption>楼仔的公众号</figcaption></figure>
<h2> 6. 有什么学习的资料么</h2>
<p>找楼仔，他有很多pdf</p>
<h2> 7. 有什么学习的建议么</h2>
<p>我一般做不来指路明灯，或者导师的角色；一个建议就是跟着大佬后面走</p>
<h2> 8. 怎么联系我</h2>
<ul>
<li>QQ : 3302797840</li>
<li>微信 : liuyueyi25</li>
<li>邮箱 : <a href="mailto:bangzewu@126.com">bangzewu@126.com</a></li>
<li>微博 : 一灰灰blog (基本上不活跃)</li>
</ul>
]]></content:encoded>
      <enclosure url="https://spring.hhui.top/spring-blog/imgs/info/info.png" type="image/png"/>
    </item>
    <item>
      <title>01.创建一个SpringAI的示例工程</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">01.创建一个SpringAI的示例工程</source>
      <description>01. 创建一个SpringAI的示例工程 下面介绍一下，如何快速借助官方的启动方式进行快速搭建一个用于体验SpringAI的示例工程 一、项目创建 https://spring.io/projects/spring-ai 借助Spring官方提供的快速创建项目功能，创建一个SpringBoot项目，点击下面的连接进入快速创建Spring-Ai项目</description>
      <category>SpringAI</category>
      <pubDate>Fri, 11 Jul 2025 08:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 01. 创建一个SpringAI的示例工程</h1>
<p>下面介绍一下，如何快速借助官方的启动方式进行快速搭建一个用于体验SpringAI的示例工程</p>
<h2> 一、项目创建</h2>
<blockquote>
<p><a href="https://spring.io/projects/spring-ai" target="_blank" rel="noopener noreferrer">https://spring.io/projects/spring-ai</a></p>
</blockquote>
<p>借助Spring官方提供的快速创建项目功能，创建一个SpringBoot项目，点击下面的连接进入快速创建Spring-Ai项目</p>
<ul>
<li><a href="https://start.spring.io/#!type=maven-project&amp;language=java&amp;platformVersion=3.3.4&amp;packaging=jar&amp;jvmVersion=17&amp;groupId=spring.ai.example&amp;artifactId=spring-ai-demo&amp;name=spring-ai-demo&amp;description=Spring%20AI%20%2C%20getting%20started%20example%2C%20using%20Open%20AI&amp;packageName=spring.ai.example.spring-ai-demo&amp;dependencies=web,spring-ai-openai" target="_blank" rel="noopener noreferrer">start.spring.io</a></li>
</ul>
<figure><img src="/imgs/column/springai/01-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在表格中，填写关键的信息（Group, Artifact, Name, Description, Version, PackageName）</p>
<h2> 二、项目初始化</h2>
<p>将上面生成的工程，解压之后，导入IDEA开发工具，你会得到一个空的Spring项目</p>
<figure><img src="/imgs/column/springai/01-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 1. 配置账号信息</h3>
<p>上面创建的默认是OpenAI(Chatgpt)的大模型访问，这个需要我们提前备好梯子和密钥，账号充值才能使用，只需要在<code>applicatin.properties</code>文件中添加密钥即可</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote>
<p>出于安全考虑，可以通过配置环境变量的方式来配置密钥，如下</p>
</blockquote>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后设置环境变量</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 使用免费的智普大模型体验</h3>
<p>当然若条件不允许，我们可以考虑智普清言的免费大模型</p>
<p>替换依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在智普的开放平台获取密钥：<a href="https://open.bigmodel.cn/usercenter/proj-mgmt/apikeys" target="_blank" rel="noopener noreferrer">https://open.bigmodel.cn/usercenter/proj-mgmt/apikeys</a></p>
<figure><img src="/imgs/column/springai/01-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后在配置文件中，添加智普的密钥，并指定免费的大模型</p>
<blockquote>
<p>在官网的定价中可以找到免费的模型：<a href="https://www.bigmodel.cn/pricing" target="_blank" rel="noopener noreferrer">https://www.bigmodel.cn/pricing</a></p>
</blockquote>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 密钥注入方式</h3>
<p>密钥除了直接再配置文件中写死之外，也可以通过前面介绍的环境变量的方式来注入，除此之外，下面介绍一种本地开发时命令行参数注入的方式</p>
<p>为了避免<code>api-key</code>的泄露，我们借助SpEL的方式来注入，通过在启动时，添加参数来设置apiKey，如下</p>
<ul>
<li>唤起编辑启动命令行窗口</li>
<li>点击<code>Modify options</code></li>
<li>在弹窗中选中 <code>Program arguments</code>，然后会看到再启动类右边新增一个输入框</li>
<li>再输入框中添加<code>--spring.ai.zhipuai.api-key=&lt;your-zhipuai-api-key&gt;</code></li>
</ul>
<figure><img src="/imgs/column/springai/01-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>说明：为什么不建议直接在配置文件中写密钥？</strong></p>
<ul>
<li>因为非常容易泄露，本地测试时，最简单的当然是直接在配置文件中写密钥，但是当我们将项目推送到git时，很容易忘了将密钥删除，这样，密钥就泄露了（即便你后续发现了再删除，但是git的历史提交中依然能找到你的密钥，你就只能删除它了）</li>
</ul>
<h2> 三、项目运行</h2>
<p>再上面初始化完成之后，接下来我们写一个简单的Chat服务，用于体验与大模型对话的感觉</p>
<p>新建一个ChatController类，用于接收用户的提问，并返回模型生成的答案</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面分别提供同步/流式调用大模型两种方式，测试时，你可以选择任意一种方式</p>
<figure><img src="/imgs/column/springai/01-5.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 四、小结</h2>
<p>从本文搭建的一个示例工程可以看出，借助SpringAI与大模型进行交互可以说是非常简单了，比基于db的CURD效率要高多了。相比起我们自己的实现（比如技术派的大模型调用就是手撸的代码直接实现与大模型交互），实在是轻松太多</p>
<p>文中所有代码可以在<a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S01-chat-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a> 获取</p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/01-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>02.提示词的使用</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/02.%E6%8F%90%E7%A4%BA%E8%AF%8D%E8%AE%BE%E7%BD%AE.html</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/02.%E6%8F%90%E7%A4%BA%E8%AF%8D%E8%AE%BE%E7%BD%AE.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">02.提示词的使用</source>
      <description>02. 提示词的使用 上一篇文章快速带大家基于SpringAi创建了一个调用大模型的示例工程，接下来我们将进入一些大模型交互的细节，这里主要介绍如何使用提示词，以使大模型的输出更加符合我们的需求 一、基础知识 1. 提示词（Prompt） 提示词：Prompt，也可以理解为预设，是模型在开始对话时，预先设定的一些内容，这些内容会作为模型输入，从而影响模型输出的结果。 SpringAI中，我们使用 Prompt 类来表示一个提示词，Prompt 类中包含一个 List&amp;lt;Message&amp;gt; 属性，用于表示提示词中的消息列表。</description>
      <category>SpringAI</category>
      <pubDate>Fri, 11 Jul 2025 10:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 02. 提示词的使用</h1>
<p>上一篇文章快速带大家基于SpringAi创建了一个调用大模型的示例工程，接下来我们将进入一些大模型交互的细节，这里主要介绍如何使用提示词，以使大模型的输出更加符合我们的需求</p>
<h2> 一、基础知识</h2>
<h3> 1. 提示词（Prompt）</h3>
<p>提示词：Prompt，也可以理解为预设，是模型在开始对话时，预先设定的一些内容，这些内容会作为模型输入，从而影响模型输出的结果。</p>
<p>SpringAI中，我们使用 <code>Prompt</code> 类来表示一个提示词，<code>Prompt</code> 类中包含一个 <code>List&lt;Message&gt;</code> 属性，用于表示提示词中的消息列表。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 消息（Message）</h3>
<p>用户与大模型中间的对话，通常是由一个或多个消息组成，其中每个消息都需要与一个角色关联；角色表示消息作者的角色。</p>
<p>SpringAI中，我们使用 <code>Message</code> 类来表示一个消息，<code>Message</code> 类中包含一个 <code>MessageType</code> 属性，用于表示消息的类型。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面定义的<code>MessageType</code>定义消息类型，和大模型中定义的角色进行映射，ChatGPT了解它应该如何行为以及谁在发起调用</p>
<figure><img src="/imgs/column/springai/02-1.webp" alt="https://docs.spring.io/spring-ai/reference/api/prompt.html#_prompt" tabindex="0" loading="lazy"><figcaption><a href="https://docs.spring.io/spring-ai/reference/api/prompt.html#_prompt" target="_blank" rel="noopener noreferrer">https://docs.spring.io/spring-ai/reference/api/prompt.html#_prompt</a></figcaption></figure>
<p>通常有四种角色：</p>
<ul>
<li>system: 系统角色，用于通过分配特定行为给大模型来创建对话的上下文或范围，通常我们预设的提示词会和 <code>system</code> 角色关联</li>
<li>user: 用户角色，用于表示用户输入的文本，通常我们输入的提问也会和 <code>user</code> 角色关联</li>
<li>assistant: 助手角色，用于表示模型生成的文本，通常大模型生成的答案也会和 <code>assistant</code> 角色关联</li>
<li>tool: 工具角色，用于表示模型调用的函数返回的内容，会和 <code>tool</code> 角色关联</li>
</ul>
<h3> 3. 提示词模板</h3>
<p>提示词实际上是一个字符串，若提示词全部由程序预设，会导致提示词的复用性差，因此，SpringAI提供了一种模板语法，用于生成提示词，模板语法如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>模板语法中，<code>{name}</code> 和 <code>{voice}</code> 是模板变量，模板变量的值会根据调用时传入的参数进行替换</p>
<p>关联的类定义如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 二、实例演示</h2>
<p>首先我们需要创建一个SpringAI的项目，基本流程同 <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 1. 提示词基础使用</h3>
<p>我们这里同样基于智普的免费大模型进行演示，首先创建一个Controller控制器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后再定义一个对话的接口，还是与之前的demo工程的一样，接收用户的传入文本，不同的地方在于我们再方式实现中，显示创建一个提示词</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>提示词的创建方式比较简单，直接new一个对象，如上面的示例</p>
<ul>
<li>第一个参数：string类型：默认表示用户输入的消息</li>
<li>第二个参数：ChatOptions类型：表示模型调用的参数，如模型名称、温度、用户名称等</li>
</ul>
<ol>
<li>
<p><strong><code>temperature</code> 参数作用</strong>：</p>
<ul>
<li>用于控制生成文本的<strong>随机性或创造性</strong>。</li>
<li>数值范围一般在 <code>0.0</code> 到 <code>1.0</code> 之间（有时也可超出该范围）：
<ul>
<li>当 <code>temperature</code> 接近 <code>0.0</code> 时，输出会趋于确定性和保守，通常选择概率最高的词；</li>
<li>当 <code>temperature</code> 接近 <code>1.0</code> 或更高时，输出更具多样性和创造性，可能会选择低概率但更有趣的词。</li>
</ul>
</li>
<li>示例中设置为 <code>0.7d</code>，表示适度平衡确定性与多样性。</li>
</ul>
</li>
<li>
<p><strong><code>user</code> 参数作用</strong>：</p>
<ul>
<li>用于标识请求的发起者，通常是<strong>用户的唯一标识符</strong>（如用户名、ID 等）。</li>
<li>主要用途包括：
<ul>
<li><strong>日志记录和审计</strong>：便于追踪哪个用户触发了此次 AI 调用；</li>
<li><strong>配额管理</strong>：某些平台依据 <code>user</code> 字段进行使用量统计与限制；</li>
<li><strong>行为分析</strong>：用于后续的数据分析或个性化推荐等场景。</li>
</ul>
</li>
<li>示例中设置为 <code>"一灰灰"</code>，可能代表当前请求来源的用户身份标识。</li>
</ul>
</li>
</ol>
<p>如果我们希望预设一个系统的提示词，比如给大模型定义一个身份：“你现在是一个专注于给3-5岁儿童聊天的助手”，那么我们可以这样创建一个提示词：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们访问对比一下上面两个接口的返回情况，很明显<code>childGenerate</code>生成的笑话内容更适合3-5岁小朋友</p>
<figure><img src="/imgs/column/springai/02-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>小结一下，提示词的使用方式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 提示词模板</h3>
<p>接下来我们再来看一下提示词模板的使用示例，创建一个角色扮演的接口，我们预设的系统提示词模板为</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>直接借助SpringAI提供的 <code>PromptTemplate</code> 来实现提示词模板的解析，常见的使用方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们创建一个接口，接收三个参数，分别表示角色的个性、角色名称、用户角色名称，然后使用模板渲染，并创建一个系统提示词，实现与用户的对话</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们看看传入不同的参数的表现情况</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/02-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的输出也可以看出，当我传入不同的角色描述，返回的对话信息也会根据我的描述进行显著的变化</p>
<h3> 3. 提示词高级使用</h3>
<p>通过提示词模板<code>promptTemplate.create</code>创建的提示词，默认是创建<code>UserMessage</code>类型的消息；如果我们希望创建的是系统提示词呢？可以使用<code>SystemPromptTemplate</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>默认情况下，提示词模板中需要替换的内容是放在<code>{}</code>中的，当然我们也可以自定义替换的内容，比如使用<code>&lt;&gt;</code>来替换，此时我们需要在创建<code>PromptTemplate</code>的时候传入一个参数<code>delimiter</code>，表示替换内容的分隔符</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>提示词的使用，除了上面的字符串硬编码方式之外，SpringAI还提供了资源注入的方式，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 三、小结</h2>
<p>本文主要介绍在SpringAI中提示词的使用方式，如最基本的大模型交互时，由SpringAI默认根据文本封装一个用户消息</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当然也可以手动创建</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如提示词有复用的场景，则优先考虑提示词模板</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S02-prompt-demo" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/02-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>03.结构化返回</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/03.%E7%BB%93%E6%9E%84%E5%8C%96%E8%BF%94%E5%9B%9E.html</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/03.%E7%BB%93%E6%9E%84%E5%8C%96%E8%BF%94%E5%9B%9E.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">03.结构化返回</source>
      <description>03. 结构化返回 通常情况下，在我们不显示要求大模型返回什么样的数据结构时，大模型返回的大多不是结构化的数据；对于上层的业务开发来说，将大模型返回的关键信息映射为结构化的数据模型是一个非常难受的事情 SpringAI提供了一系列的返回结果结构化转换器来实现上面的痛点；接下来我们来具体看一下，可以怎么处理返回结果 一、实例演示 首先我们需要创建一个SpringAI的项目，基本流程同 创建一个SpringAI-Demo工程</description>
      <category>SpringAI</category>
      <pubDate>Fri, 11 Jul 2025 12:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 03. 结构化返回</h1>
<p>通常情况下，在我们不显示要求大模型返回什么样的数据结构时，大模型返回的大多不是结构化的数据；对于上层的业务开发来说，将大模型返回的关键信息映射为结构化的数据模型是一个非常难受的事情</p>
<p>SpringAI提供了一系列的返回结果结构化转换器来实现上面的痛点；接下来我们来具体看一下，可以怎么处理返回结果</p>
<h2> 一、实例演示</h2>
<p>首先我们需要创建一个SpringAI的项目，基本流程同 <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 1. 初始化</h3>
<p>创建一个MVC的API，用于提供与大模型的交互</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. BeanOutputConverter</h3>
<p>借助<code>BeanOutputConverter</code>来实现返回结果映射为java的POJO类，首先我们定义一个提示词模板，主要用于查询某个导演的作品</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们希望返回的结构如下:</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此我们可以定义一个record，用于承接返回的结果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>借助<code>ChatClient</code>来实现结果解析</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为什么上面的方式就可以实现结果映射为java的POJO类呢？ 我们可以debug一下<code>ChatClient.create(chatModel).prompt(prompt).call()</code>返回的对象</p>
<p>从下面的截图中可以看到，在传递给大模型的请求中，context参数中，指定了要求大模型返回的数据格式（这里基于Advisors来实现的上下文数据附加/扩充提示词的功能）</p>
<figure><img src="/imgs/column/springai/03-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>当然也可以显示使用<code>BeanOutputConverter</code>基于<code>ChatModel</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，在提示词模板中，新增了 <code>{format}</code>，其值由 <code>BeanOutputConverter</code> 的 <code>getFormat()</code> 方法获取；其实现原理是直接在提示词中添加了结构化的返回结果格式，因此，大模型返回的数据结构，会按照这个格式进行解析</p>
<p>接下来实际访问看看表现情况</p>
<figure><img src="/imgs/column/springai/03-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从多次体验的结果来看，结果的格式与定义的POJO类一致，因此，基于BeanOutputConverter的实现，可以达到我们想要的结果；但是在有限的几次访问尝试中，返现<code>ChatClient</code>方式，返回的结果中actor可能为null，没有正确获取到值，这也侧面说明，大模型返回数据的不可控性</p>
<h3> 3. 属性排序</h3>
<p>借助<code>@JsonPropertyOrder</code>来实现排序，这个注解适用于record和普通的class</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/03-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. MapOutputConverter</h3>
<p>上面介绍的是返回一个POJO，接下来看一下直接基于<code>MapOutputConverter</code>来实现用map接收返回结果</p>
<p>这里使用的是上面用过的 <code>ParameterizedTypeReference</code> 来指定返回结果的类型</p>
<p>基于 <code>ChatClient</code> 的方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基于<code>MapOutputConverter</code>结合<code>ChatModel</code>来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两个接口的返回结果如下图，虽然都是返回的Map，但是仔细看之后，会发现他们的层级并不一样，基于<code>ChatClient</code>返回的层级会多一层，返回的电影被放在了<code>movie</code>属性下，以列表的方式组织；而基于<code>MapOutputConverter</code>返回的就是一层的map，key为数字；</p>
<p>至于孰优孰劣，这里就不予置评，看个人喜好了</p>
<figure><img src="/imgs/column/springai/03-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. ListOutputConverter</h3>
<p>除了上面返回Map的case之外，再看一下返回列表的场景，借助<code>ListOutputConverter</code>来实现，基本上和前面介绍的差异不大</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>返回实例如下（你会发现返回数据的不准，当然这个就不属于我们这里的范畴了）</p>
<figure><img src="/imgs/column/springai/03-5.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 二、小结</h2>
<p>本文主要介绍在SpringAI中如何结构化的处理大模型返回的结果，从使用方式来看，区分<code>ChatClient</code>和<code>ChatModel</code>两种不同的使用姿势；其中前者更简单</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，核心发挥作用的是<code>Converter</code>，SpringAI官方提供了下面这些具体的实现，基本上可以覆盖我们90%以上的业务场景； 若覆盖补全，则考虑通过自定义Converter来实现</p>
<figure><img src="/imgs/column/springai/03-6.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S03-structured-output" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/03-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>04.聊天上下文</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/04.%E8%81%8A%E5%A4%A9%E4%B8%8A%E4%B8%8B%E6%96%87.html</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/04.%E8%81%8A%E5%A4%A9%E4%B8%8A%E4%B8%8B%E6%96%87.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">04.聊天上下文</source>
      <description>04.聊天上下文 大模型本身是无状态的，即你每次和它聊天，对它而言都是一轮全新的对话。但是，这个和我们实际体验大模型产品时，似乎不一样，在聊天的过程中，大模型明显是知道我们之前的问答内容、并可以基于之前的问答进行多伦的沟通，那这是怎么实现的呢？ 具体实现的原理也很简单，你和大模型的对话时，会将你们之前的对话内容也一并传给大模型，即：对于大模型而言，你的一次新的对话，它实际上把你们之前的所有对话都过了一遍；更专业一点的说法是你们的对话 是基于一个上下文，这个上下文会包含你之前和模型交互的所有内容。 若希望实现多轮对话，则每次和模型进行对话时，需要将之前和模型交互的所有内容都传递给模型，这样模型才能基于这些内容进行多轮的沟通。</description>
      <category>SpringAI</category>
      <pubDate>Mon, 14 Jul 2025 14:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 04.聊天上下文</h1>
<p>大模型本身是无状态的，即你每次和它聊天，对它而言都是一轮全新的对话。但是，这个和我们实际体验大模型产品时，似乎不一样，在聊天的过程中，大模型明显是知道我们之前的问答内容、并可以基于之前的问答进行多伦的沟通，那这是怎么实现的呢？</p>
<p>具体实现的原理也很简单，你和大模型的对话时，会将你们之前的对话内容也一并传给大模型，即：对于大模型而言，你的一次新的对话，它实际上把你们之前的所有对话都过了一遍；更专业一点的说法是你们的对话
是基于一个上下文，这个上下文会包含你之前和模型交互的所有内容。</p>
<p>若希望实现多轮对话，则每次和模型进行对话时，需要将之前和模型交互的所有内容都传递给模型，这样模型才能基于这些内容进行多轮的沟通。</p>
<h2> 一、实例演示</h2>
<h3> 1. 基础知识点</h3>
<p>SpringAI提供了自动装备的<code>ChatMemory</code> bean供我们直接注入使用</p>
<p>默认底层使用基于内存的方式存储聊天上下文(<code>InMemoryChatMemoryRepository</code>)，除了它之外，SpringAI还提供了基于数据库的存储方式</p>
<ul>
<li><code>JdbcChatMemoryRepository</code>:
支持多种关系型数据库，适用于需要持久化存储聊天记忆的场景，使用时需要添加 <code>org.springframework.ai:spring-ai-starter-model-chat-memory-repository-jdbc</code>
的依赖</li>
<li><code>CassandraChatMemoryRepository</code>: 基于 Apache Cassandra 实现消息存储，适用于需要高可用、持久化、可扩展及利用 TTL
特性的聊天记忆持久化场景；采用时间序列
Schema，完整记录历史聊天窗口，使用时添加 <code>org.springframework.ai:spring-ai-starter-model-chat-memory-repository-cassandra</code>
的依赖</li>
<li><code>Neo4jChatMemoryRepository</code>: 利用 Neo4j 将聊天消息存储为属性图中的节点与关系，适用于需发挥 Neo4j 图数据库特性的聊天记忆持久化场景。
使用时添加 <code>org.springframework.ai:spring-ai-starter-model-chat-memory-repository-neo4j</code>的依赖</li>
</ul>
<p>为了避免对话内容超过大模型的上下文限制， 使用<code>MessageWindowChatMemory</code>实现管理对话历史，<code>MessageWindowChatMemory</code>
维护固定容量的消息窗口（默认 20 条）。当消息超限时，自动移除较早的对话消息（始终保留系统消息）。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此为 Spring AI 自动配置 ChatMemory Bean 时采用的默认消息类型。</p>
<p>在使用 <code>ChatClient API</code>时，可通过注入 <code>ChatMemory</code> 实现来维护跨多轮交互的会话上下文。接下来我们通过一个案例体验一下实际的效果</p>
<h3> 2. 项目初始化</h3>
<p>首先我们需要创建一个SpringAI的项目，基本流程同 <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<p>创建一个MVC的API，用于提供与大模型的交互</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的初始化中，我们制定了ChatClient的默认系统角色，指定了两个<code>Advisor</code></p>
<ul>
<li>SimpleLoggerAdvisor: 主要用于打印大模型的输入输出，以及一些额外的信息</li>
<li>MessageChatMemoryAdvisor: 主要用于从默认的<code>ChatMemory</code>中获取历史消息，并将其作为消息集合注入提示词</li>
</ul>
<h3> 3. 实现测试接口</h3>
<p>基于上面实例的ChatClient，我们来创建一个与大模型进行多轮对话的接口，这个实现与前面介绍的demo并无区别</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们访问接口，并输入内容，看看效果</p>
<figure><img src="/imgs/column/springai/04-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的截图中打印的大模型交互日志也可以看出，大模型会基于我们之前输入的内容进行多轮的沟通，并返回结果</p>
<p>因为默认的ChatMemory是基于内存的（ConcurrentHashMap），所以每次重启服务，都会丢失之前的对话内容，有兴趣的小伙伴可以试试</p>
<h3> 4. 会话隔离</h3>
<p>上面虽然实现了多伦对话，但是有一个比较大的问题，就是多个用户之间会话内容会相互干扰，比如用户A和用户B进行对话，用户B的会话内容会干扰用户A的会话内容，这显然是不符合实际需求的。</p>
<p>为了做好身份隔离，我们希望在记忆库中检索历史对话时，可以有一个区分，同样是借助 <code>advisor</code> 来实现</p>
<p>为了与上面的进行区分，我们调整一下ChatClient的初始化，对话角色可以由用户自由指定</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，我们创建一个会话隔离的接口，这个接口会根据用户ID进行会话隔离，即同一个用户ID的会话内容不会相互干扰</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/04-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的实现也可以看出，通过设置会话ID，实现了会话的隔离，用户A和用户B的会话内容不会相互干扰</p>
<h3> 5. ChatModel显示管理上下文</h3>
<p>上面介绍的是封装后的ChatClient，我们也可以直接使用<code>ChatModel</code>进行会话，显示管理上下文</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 其他Advisor</h3>
<p>上面介绍的是基于<code>MessageChatMemoryAdvisor</code>将ChatMemory注入到大模型，除此之外，SpringAI还内置了</p>
<ul>
<li><code>PromptChatMemoryAdvisor</code>: 区别于<code>MessageChatMemoryAdvisor</code>将多伦对话（包含内容、角色）返回给大模型，<code>PromptChatMemoryAdvisor</code>主要是将消息内容以文本的方式追加到系统提示词中</li>
<li><code>VectorStoreChatMemoryAdvisor</code>: 通过指定 <code>VectorStore</code> 实现管理会话记忆。每次交互时从向量存储检索历史对话，并以纯文本形式追加至系统（system）消息。</li>
</ul>
<p>还是根据一个实际的对比看看<code>MessageChatMemoryAdvisor</code>与<code>PromptChatMemoryAdvisor</code>的区别：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/04-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>系统提示词的文本内容如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的内容也可以看出，<code>PromptChatMemoryAdvisor</code>将多轮对话（包含内容、角色）拼接成文本的方式，放进了系统提示词中；从数据结构上看 <code>List&lt;Message&gt;</code> 只有两个，一个是System消息，一个是用户新加的User消息</p>
<h2> 二、小结</h2>
<p>本文主要从使用层面介绍了SpringAI中如何实现多伦对话，其中有几个关键概念</p>
<ul>
<li>ChatMemory: 会话记忆，SpringAI内置了基于内存的会话记忆，也可以基于其他数据源进行会话记忆，如向量存储、数据库、Redis等</li>
<li>ChatMemoryRepository：会话记忆的存储，SpringAI内置了基于内存的会话记忆存储，默认使用基于<code>ConcurrentHashMap</code>的会话记忆存储 <code>InMemoryChatMemoryRepository</code>
<ul>
<li>对于有持久化诉求的，可以考虑 <code>JdbcChatMemoryRepository</code>, <code>CassandraChatMemoryRepository</code>, <code>Neo4jChatMemoryRepository</code></li>
</ul>
</li>
<li>MessageWindowChatMemory：会话记忆的窗口</li>
<li>Advisor: 会话记忆的注入，SpringAI内置了多种会话记忆的注入方式，常见的有<code>MessageChatMemoryAdvisor</code>、<code>PromptChatMemoryAdvisor</code>、<code>VectorStoreChatMemoryAdvisor</code></li>
</ul>
<p>使用<code>ChatMemory</code>进行会话记忆时，推荐使用<code>ChatClient</code>方式，借助<code>Advisor</code>进行注入</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S04-chat-memory" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/04-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>05.自定义大模型接入</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/05.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5.html</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/05.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">05.自定义大模型接入</source>
      <description>05.自定义大模型接入 SpringAI已经集成了很多主流大模型的交互，封装成starter供我们直接使用；比如前面几篇的demo使用的智普大模型，就是直接利用spring-ai-starter-model-zhipuai来进行大模型的交互 但总有例外，比如星火的免费模型Spark Lite(非免费的也没有😂)，在官方的教程中我们就没有找到可以直接使用的starter 接下来我们看一下，基于SpringAI，如果我们要接入一个自定义的大模型，可以怎么处理 一、大模型接入申请 首先是准备好大模型需要的信息(核心就是apiKey)</description>
      <category>SpringAI</category>
      <pubDate>Mon, 21 Jul 2025 14:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 05.自定义大模型接入</h1>
<p>SpringAI已经集成了很多主流大模型的交互，封装成starter供我们直接使用；比如前面几篇的demo使用的智普大模型，就是直接利用<code>spring-ai-starter-model-zhipuai</code>来进行大模型的交互</p>
<p>但总有例外，比如星火的免费模型Spark Lite(非免费的也没有😂)，在官方的教程中我们就没有找到可以直接使用的starter</p>
<p>接下来我们看一下，基于SpringAI，如果我们要接入一个自定义的大模型，可以怎么处理</p>
<h2> 一、大模型接入申请</h2>
<p>首先是准备好大模型需要的信息(核心就是apiKey)</p>
<h3> 1. 星火ApiKey申请</h3>
<p>注册、登录账号相关流程省略，请直接在官网自助完成</p>
<p>进入开放平台: <a href="https://console.xfyun.cn/services/cbm" target="_blank" rel="noopener noreferrer">https://console.xfyun.cn/services/cbm</a></p>
<figure><img src="/imgs/column/springai/05-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>选择 Spark Lite 模型，上图中因为我已经开通了；对于没有开通的场景，可以看到上图中 <code>领取无限量</code> 这个按钮是激活状态，点击之后对于已认证账号即可获取了（未认证的，直接跳转到认账账号进行认证，支持个人/企业认证）</p>
<p>领取之后，在右边的缱绻信息中，将 ApiPassword 复制出来待用</p>
<h3> 2. 阅读官方接口文档</h3>
<p>由于并不是所有的大模型的规范都一样，无法确保它们都能直接适配SpringAI的传入/传出，因此在后续的接入需要重点阅读官方接口文档，对大模型的交互进行适配</p>
<p>所以，我们这里就以星火模型为例，阅读官方接口文档，这里我们使用的是Spark Lite模型，文档地址为：<a href="https://www.xfyun.cn/doc/spark/HTTP%E8%B0%83%E7%94%A8%E6%96%87%E6%A1%A3.html" target="_blank" rel="noopener noreferrer">https://www.xfyun.cn/doc/spark/HTTP调用文档.html</a></p>
<h2> 二、项目创建</h2>
<p>项目创建方式与之前并无差别，创建一个SpringBoot项目，并引入SpringAI的依赖，有需要的小伙伴参考 <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 1. 依赖配置</h3>
<p>由于我们不直接使用官方的starter, 因此需要主动依赖SpringAI的一些核心包</p>
<p>在pom配置文件中添加</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 配置参数</h3>
<p>同样的，我们可以将大模型的一些参数，统一维护在<code>application.yml</code>配置文件中，关键的信息为 <code>api-key</code></p>
<p>关于配置的维护，我们可以直接参考官方提供的starter的实现（比如智普的starter）</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：本文以实现一个最基础的大模型交互为例，因此更多的参数相关组织配置，将留待后续的文章进行扩充实现；这里只介绍最核心的参数</p>
<h3> 3. 实现大模型接口</h3>
<p>对于自定义的大模型的接口实现，最最核心的，就是实现<code>ChatModel</code>接口，这个接口定义了模型交互的参数，以及模型交互的返回结果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于这个<code>ChatModel</code>的实现，关键在于 <code>public ChatResponse call(Prompt prompt)</code> 这个方法的实现，其他的都非必须</p>
<p>对于<code>call(Prompt prompt)</code>方法，内部需要实现的就是和大模型的交互，以同步的http协议的方式，我们需要干的事情，就三个</p>
<ul>
<li>将 <code>prompt</code> 转换为大模型的传入参数</li>
<li>发起<code>http</code>请求</li>
<li>将大模型的返回对象封装为 <code>ChatResponse</code> 对象</li>
</ul>
<p>在上面的具体实现中，我们直接使用Spring的<code>restClient</code>作为http交互的工具(对于需要流式异步交互的场景，可以考虑WebClient)，麻烦的点(或者说脏活累活)就是请求返回的解析映射</p>
<p>对于此，我们定义一个<code>SparkPOJO</code>来保存讯飞大模型的返回结果；</p>
<p>如下面这个json为大模型的真实返回结果</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基于上面的json，我们你定义的POJO，可以分为</p>
<ul>
<li><code>ChatCompletionChunk</code>对应完整的返回</li>
<li><code>Choice</code> 对应大模型返回结果中的<code>choices</code>数组，<code>SparkMsg</code>对应choices数组中的message元素；</li>
<li><code>Usage</code> 对应大模型返回结果中的<code>usage</code>元素</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>定义 <code>POJOConvert</code> 来实现请求返回的对象转换为 <code>ChatResponse</code></p>
<ul>
<li><code>List&lt;Generation&gt;</code> 生成的结果
<ul>
<li>ChatGenerationMetadata： 返回的元数据</li>
<li>AssistantMessage：包含具体返回的文本</li>
</ul>
</li>
<li><code>ChatResponseMetadata</code>: 返回的元数据</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 大模型使用示例</h3>
<p>上面完成了自定义大模型的交互，接下来我们试试效果；使用方法基本上和前面介绍的没有任何区别</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/05-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 三、小结</h2>
<p>本文通过非官方提供的start，实现了一个自定义大模型的接入过程，其核心关键在于 <code>ChatModel</code> 接口的实现，小结一下自定义大模型接入的关键点</p>
<ul>
<li>继承 <code>ChatModel</code> 接口，实现 <code>ChatModel</code> 接口的 <code>call</code> 方法，返回 <code>ChatResponse</code> 对象</li>
<li>实现SpringAI定义的<code>Prompt</code>对象转大模型传参</li>
<li>实现大模型的返回结果转 <code>ChatResponse</code></li>
</ul>
<p>本文仅作为参考，目前只实现了基础的大模型聊天问答，接下来我们将介绍了SpringAI的更多高级功能（比如Function tool工具调用, 多模态, MCP, RAG等）；</p>
<p>同时也会在介绍这些高级功能时 ，给出自定义的大模型接入的相关能力扩展，辅助加深理解。</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S05-self-model" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/05-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>06.工具调用 FunctionCalling</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/06.%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8FunctionCalling.html</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/06.%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8FunctionCalling.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">06.工具调用 FunctionCalling</source>
      <description>06.工具调用 FunctionCalling 我们知道大模型是基于一系列数据进行训练的，且每次训练的成本很高；那么大模型是怎么样表现得十八般武艺样样精通的呢？ function calling就是设计出来给大模型当外挂的瑞士工具包，通过给大模型设计一个与外部工具进行交互的方式，来扩展大模型在训练时缺失或者不够与时俱进的能力 一、工作原理 SpringAi 提供了完备工具调用封装，可以非常方便的将本地方法封装成工具，供大模型调用 1. 工具调用流程 Spring AI工具调用流程</description>
      <category>SpringAI</category>
      <pubDate>Mon, 28 Jul 2025 08:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 06.工具调用 FunctionCalling</h1>
<p>我们知道大模型是基于一系列数据进行训练的，且每次训练的成本很高；那么大模型是怎么样表现得十八般武艺样样精通的呢？</p>
<p>function calling就是设计出来给大模型当外挂的瑞士工具包，通过给大模型设计一个与外部工具进行交互的方式，来扩展大模型在训练时缺失或者不够与时俱进的能力</p>
<h2> 一、工作原理</h2>
<p>SpringAi 提供了完备工具调用封装，可以非常方便的将本地方法封装成工具，供大模型调用</p>
<h3> 1. 工具调用流程</h3>
<figure><img src="/imgs/column/springai/06-1.webp" alt="Spring AI工具调用流程" tabindex="0" loading="lazy"><figcaption>Spring AI工具调用流程</figcaption></figure>
<p>工具调用流程如下：</p>
<ol>
<li>在向大模型发起请求时，将工具信息传递给大模型
<ul>
<li>每个工具的定义都包含名称、描述、输入参数</li>
</ul>
</li>
<li>大模型根据工具信息，会发送包含工具名称、亲求参数的请求给工具服务</li>
<li>应用程序根据工具名称，识别到对应的工具，调用工具方法</li>
<li>工具执行结果返回给应用程序进行处理（可能是直接返回给用户，也可能是返回给大模型）</li>
<li>应用程序将工具执行结果返回给大模型</li>
<li>大模型利用工具返回的结果，构建返回结果给用户</li>
</ol>
<h3> 2. SpringAI关键实现</h3>
<p>SpringAI主要提供了两种内置方式将本地方法封装成工具</p>
<ul>
<li>声明式：通过注解 <code>@Tool</code></li>
<li>编程式：通过底层的 <code>MethodToolCallback</code> <code>FunctionToolCallback</code></li>
</ul>
<figure><img src="/imgs/column/springai/06-2.webp" alt="https://java2ai.com/docs/dev/tutorials/function-calling/" tabindex="0" loading="lazy"><figcaption><a href="https://java2ai.com/docs/dev/tutorials/function-calling/" target="_blank" rel="noopener noreferrer">https://java2ai.com/docs/dev/tutorials/function-calling/</a></figcaption></figure>
<p>上图中橙色的部分，就是SpringAI将我们本地方法封装成工具，供大模型进行交互；接下来我们看一下SpringAI的关键类</p>
<h4> a. ToolCallback</h4>
<p>ToolCallback 接口提供了定义 AI 模型可调用工具的方式，包含工具定义和执行逻辑。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>SpringAI提供了两种内置实现</p>
<ul>
<li>MethodToolCallback: 将本地方法定义为AI模型可调用的工具</li>
<li>FunctionToolCallback: 将函数定义为AI模型可调用的工具</li>
</ul>
<h4> b. ToolDefinition</h4>
<p>ToolDefinition 接口提供 AI 模型识别工具可用性所需的信息，包括工具名称、描述及输入模式。每个 ToolCallback 实现必须提供 ToolDefinition 实例来定义工具。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>若需要手动创建的工具定义，可以使用<code>ToolDefinition.Builder</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了上面的方式，对于本地java方法，可以直接通过反射的方式来生成基于方法的工具定义</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> c. JSON Schema</h4>
<p>向 AI 模型提供工具时，模型需要知道工具调用输入类型的模式，Spring AI 通过 JsonSchemaGenerator 类内置支持生成工具输入类型的 JSON Schema</p>
<p>下面是一个json schema的示例（在前面<a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/03.%E7%BB%93%E6%9E%84%E5%8C%96%E8%BF%94%E5%9B%9E.html" target="blank">结构化返回</a>中，实际上也用到了 JSON Schema，用于告知大模型如何返回我们希望格式的数据）</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的json schema主要用于方法/函数调用的传参定义，SpringAI内置支持下面四种基于注解升成输入参数描述、是否必传</p>
<ul>
<li><code>Spring AI</code> 的 <code>@ToolParam(description = "…", required=false)</code>： 参数描述 + 是否必传</li>
<li><code>Jackson</code> 的 <code>@JsonClassDescription(description = "…)</code>: 参数描述</li>
<li><code>Jackson</code> 的 <code>@JsonPropertyDescription(description = "…")</code> : 参数描述</li>
<li><code>Jackson</code> 的 <code>@JsonProperty(required = false)</code> : 参数是否必传</li>
<li><code>Swagger</code> 的<code> @Schema(description = "…", required = false)</code> ： 参数描述 + 是否必传</li>
<li><code>Spring</code> 的 <code>@Nullable</code> ： 参数是否必传</li>
</ul>
<p>示例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> d. 结果转换</h4>
<p>通常方法/函数返回的是Object对象，需要转换给大模型使用，SpringAI定义<code>ToolCallResultConverter</code>对返回进行序列化，实现将返回结果转换为String对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>SpringAI默认的结果转换为基于Jackson的json序列化（<code>DefaultToolCallResultConverter</code>），当然如果你喜欢，也可以换成gson、fastjson或者自定义的转换实现</p>
<h4> e. ToolContext</h4>
<p>Spring AI 支持通过 <code>ToolContext</code> API向工具传递额外的上下文信息，ToolContext 中的数据由用户调用 ChatClient 时提供。后面的使用示例会进行案例介绍</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ToolContext的实现也非常简单，一个不可变对象Map来承接工具调用上下文数据</p>
<h2> 二、使用示例</h2>
<h3> 1. 项目创建</h3>
<p>项目创建方式与之前并无差别，创建一个SpringBoot项目，并引入SpringAI的依赖，有需要的小伙伴参考 <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<p>在pom中添加相关依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们这里使用智谱的免费大模型，虽然免费但它依然支持工具调用（请注意，并不是所有的模型都支持工具调用的，在使用之前到官方的说明确认是否支持）</p>
<h3> 2. 声明式使用方式</h3>
<p>我们定义一个简单、基础可用的工具方法，主要用于获取当前时间，核心点就是在方法上添加注解 <code>@Tool</code></p>
<ul>
<li>注解的 description 属性非常重要，用于知道模型判断何时调用这个工具；当描述不够清晰时，可能导致模型在该调用工具时没有调用，或者调用错了工具</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于使用 <code>ChatClient</code> 来使用工具调用，就非常简单了，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面有提供了两个接口， getTime 接口使用了工具，getTimeNoTools 接口没有使用工具；使用方式形如</p>
<ul>
<li><code>chatClient.prompt().tools(xxx)</code>：通过tools方法注入工具</li>
</ul>
<p>接下来我们看一下表现情况</p>
<figure><img src="/imgs/column/springai/06-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<blockquote>
<p>说明：虽然上面的访问对比中，在请求 <code>time</code> 接口时，正确的返回了时间，但是大模型并不总是和我们预期的一致，同样的提问，它有时不会主动调用我们注入的工具</p>
</blockquote>
<h3> 3. 带参数的工具方法</h3>
<p>前面定义的工具没有参数，接下来我们在看一下带参数的工具方法</p>
<p>在方法参数上，可以通过 <code>@ToolParam</code> 注解对参数进行解释说明（这个注解是非必填的）,注解内有两个属性</p>
<ul>
<li><code>description</code>：参数描述，用于帮助模型更准确地理解如何使用该参数。例如：参数格式要求、允许取值范围等。</li>
<li><code>required</code>：指定参数是否为必需项（默认值：<code>true</code>，即所有参数默认必需）。</li>
</ul>
<p>比如我现在定义一个返回不同时区的当前时间的工具，供大模型调用，参数是时区，同样放在 <code>DateTimeTools</code> 类中，这样就可以直接使用上面的api</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/06-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的访问示例也可以看出，我们询问某个地区的时间时，大模型会自动根据地区找到时区，然后调用我们的工具返回结果</p>
<p>但是一个问题来了，直接问时间时，它不会调用我们之前定义的那个方法，返回时间，这是为什么呢？</p>
<p>我们尝试调整一下，之前定义获取当前时间的工具方法说明</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后再多问几次，你就会发现大模型会主动调用我们定义的这个方法，返回时间（但是并不能始终保证它总是表现正确）</p>
<ul>
<li>所以一个何时的、精确的工具描述，对于大模型的决策是否调用，非常重要</li>
</ul>
<figure><img src="/imgs/column/springai/06-5.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 添加默认工具</h3>
<p>上面介绍的是在用户发起对话时，设置Prompt时指定工具调用，同样的，SpringAI也提供了默认工具的设置方式，在<code>ChatClient</code>创建时，指定默认的工具，这样只要用这个<code>ChatClient</code>进行对话，这些工具都会提供给大模型，而不在需要单独进行设置</p>
<p>使用方式形如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个就不做具体的演示了，没有什么特殊的地方</p>
<h3> 5. ChatModel 添加工具</h3>
<p>如果某些场景下，我们不是通过<code>ChatClent</code>而是直接借助<code>ChatModel</code>进行对话，同样也可以添加工具，通过 ChatOptions 来实现</p>
<p>具体的使用姿势如下，借助<code>ToolCallbacks</code>来获取工具集，借助<code>ToolCallingChatOptions</code>来添加工具集</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 编程式使用方式</h3>
<p>前面介绍的都是基于<code>@Tool</code>注解的声明式定义工具，这种适用于工具实现完全由我们掌控的场景；对于一些非控制的工具实现（如三方sdk），或者需要动态获取工具参数的场景，我们可以使用编程式定义工具</p>
<p>编程式的使用方式，主要是借助<code>MethodToolCallback.Builder</code>来构建我们需要的<code>MethodToolCallback</code></p>
<p>使用这种方式时，需要重点看一下前面第一节的内容，<code>ToolCallback</code> <code>ToolDefinition</code>的类结构定义，清楚之后，再看下面的参数设置就会更轻轻松（也知道为什么要这么实现）</p>
<ul>
<li><code>toolDefinition</code>：定义工具名称、描述及输入模式的 <code>ToolDefinition</code> 实例（必需项）
<ul>
<li>可通过 <code>ToolDefinition.Builder</code> 类构建。</li>
</ul>
</li>
<li><code>toolMetadata</code>: 定义额外设置的 <code>ToolMetadata</code> 实例，非必需
<ul>
<li>可通过 <code>ToolMetadata.Builder</code> 类构建</li>
<li>returnDierect<code>: 是否直接返回结果（默认为 </code>false`），为true时表示直接将结果返回给用户、而不是给大模型进行调用</li>
</ul>
</li>
<li><code>toolMethod</code>: 工具方法的<code>Method</code>实例 （必需项）</li>
<li><code>toolObject</code>: 包含工具方法的对象实例（若方法为静态方法则可省略此参数）</li>
<li><code>toolCallResultConverter</code>：用于将工具调用结果转换为 <code>String</code> 对象并返回 AI 模型
<ul>
<li><code>ToolCallResultConverter</code> 实例（未配置时默认使用 <code>DefaultToolCallResultConverter</code>）。</li>
</ul>
</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在使用方法工具时，需要注意一些限制</p>
<p>以下类型目前不支持作为工具方法的参数或返回类型：</p>
<ul>
<li>Optional</li>
<li>异步类型（如 CompletableFuture、Future）</li>
<li>响应式类型 （如 Flow、Mono、Flux）</li>
<li>函数式类型（如 Function、Supplier、Consumer）</li>
</ul>
<h3> 7. 函数作为工具调用的使用示例</h3>
<p>到现在为止，我们都是将方法作为工具给大模型进行调用，在java8+之后，除了方法还有些函数式接口，比如<code>Function</code>、<code>Consumer</code>、<code>Supplier</code>、<code>Predicate</code>等，这些函数式接口也可以作为工具进行调用，使用方式如下：</p>
<p>通过 <code>FunctionToolcallback</code> 来将函数式类型，转换为工具</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>具体的使用方式，和上面介绍的方法的编程式相差不大，但是有一个需要格外注意的事项</p>
<ul>
<li>函数输入和输出可以是 Void 或 POJO。输入和输出的 POJO 必须是可序列化的，因为结果将被序列化并发送回模型。</li>
<li>函数及输入输出类型必须是 public 的。</li>
</ul>
<p>以下类型目前不支持作为工具函数的输入或输出类型：</p>
<ul>
<li>基本类型</li>
<li>Optional</li>
<li>集合类型 （如 List、Map、Array、Set）</li>
<li>异步类型（如 CompletableFuture、Future）</li>
<li>响应式类型（如 Flow、Mono、Flux）</li>
</ul>
<h3> 8. 动态范式 @Bean</h3>
<p>这种类似于声明式的函数工具，Spring AI 通过 <code>ToolCallbackResolver</code> 接口（SpringBeanToolCallbackResolver具体实现），在运行时动态解析</p>
<p>可以将任意 <code>Function</code>、<code>Supplier</code>、<code>Consumer</code> 或 <code>BiFunction</code> 类型的 <code>Bean</code> 作为工具使用。</p>
<ul>
<li><code>Bean</code> 名称将作为工具名称`</li>
<li><code>Spring Framework</code> 的 <code>@Description</code> 注解提供工具描述</li>
</ul>
<p>实测，没有成功，待后续确认这个逻辑是否和官网说的一致</p>
<h2> 三、小结</h2>
<p>本篇文章主要介绍了SpringAI如何定义、使用工具调用，包括方法工具/函数工具两类，有基于@Tool注解的声明式，也有借助 <code>MethodToolCallback</code> 和 <code>FunctionToolCallback</code> 实现的编程式</p>
<p>在工具的定义上，我们需要额外关注工具的描述，传参和返回；其中传参是通过 <code>Json Schema</code> 的形式给到的大模型</p>
<p>默认行为时，Spring AI 会自动拦截模型的工具调用请求，执行工具并将结果返回模型。这些操作均由各 ChatModel 实现通过 ToolCallingManager 透明完成，如下图</p>
<figure><img src="/imgs/column/springai/06-6.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol>
<li>当需要向模型提供工具时，我们将其定义包含在聊天请求（Prompt）中，并调用 ChatModel API 将请求发送至 AI 模型。</li>
<li>当模型决定调用工具时，它会发送包含工具名称及符合定义模式的输入参数的响应（ChatResponse）。</li>
<li>ChatModel 将工具调用请求发送至 ToolCallingManager API。</li>
<li>ToolCallingManager 负责识别需调用的工具并使用提供的输入参数执行该工具。</li>
<li>工具调用结果返回至 ToolCallingManager。</li>
<li>ToolCallingManager 将工具执行结果返回给 ChatModel。</li>
<li>ChatModel 将工具执行结果返回AI模型（ToolResponseMessage）。</li>
<li>AI 模型利用工具调用结果作为附加上下文生成最终响应，并通过 ChatClient 将其返回调用方（ChatResponse）。</li>
</ol>
<p>目前与模型交互的工具执行，是由SpringAI托管的，内部的工具选择等逻辑对用户是不透明的，当然也可以通过将 <code>ToolCallingChatOptions</code> 的 <code>internalToolExecutionEnabled</code> 属性设为 <code>false</code>，来实现自行控制工具执行的生命周期；这块的内容，将在下一章节进行介绍</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S06-function-tool" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/06-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>07.实现一个查询不同时区当前时间的MCP Server</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/07.%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84McpServer.html</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/07.%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84McpServer.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">07.实现一个查询不同时区当前时间的MCP Server</source>
      <description>07.实现一个查询不同时区当前时间的MCP Server MCP可以说是25年最火的协议来了，MCP（Model Context Protocol，模型上下文协议）是由 Anthropic 公司于 2024 年底开源的标准化通信协议，旨在解决大模型与外部工具、数据源之间的碎片化集成问题，被誉为 “AI 领域的 USB-C 接口”。 其核心作用是通过统一的协议规范，让大模型（如 Claude、GPT-4、LLaMA 等）能够安全、高效地连接任意工具和数据，而无需为每个系统单独开发适配代码 一、MCP简介 在正式创建一个MCP Server之前，我们先了解一下mcp的相关概念</description>
      <category>SpringAI</category>
      <pubDate>Mon, 28 Jul 2025 11:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 07.实现一个查询不同时区当前时间的MCP Server</h1>
<p>MCP可以说是25年最火的协议来了，MCP（Model Context Protocol，模型上下文协议）是由 Anthropic 公司于 2024 年底开源的标准化通信协议，旨在解决大模型与外部工具、数据源之间的碎片化集成问题，被誉为 “AI 领域的 USB-C 接口”。</p>
<p>其核心作用是通过统一的协议规范，让大模型（如 Claude、GPT-4、LLaMA 等）能够安全、高效地连接任意工具和数据，而无需为每个系统单独开发适配代码</p>
<h2> 一、MCP简介</h2>
<p>在正式创建一个MCP Server之前，我们先了解一下mcp的相关概念</p>
<h3> 1.1 MCP是什么</h3>
<blockquote>
<p>MCP （Model Context Protocol，模型上下文协议），它提供了一个通用的开放标准，用于将 AI 系统与数据源连接起来，用单一协议取代碎片化的集成。结果是一种更简单、更可靠的方法，使 AI 系统能够访问所需的数据。这是一种将 AI 助手连接到数据所在的系统（包括内容存储库、业务工具和开发环境）的新标准。其目的是帮助前沿模型产生更好、更相关的响应。</p>
</blockquote>
<p>简单来讲，mcp就是定义了标准，对于所有希望给大模型提供能力的小伙伴来说，只要按照这个标准完成能力封装，那么大模型就可以直接加载这些能力从而实现某些特定的功能。</p>
<p>举一个例子，usb大家应该都不陌生，如果你只买一个台式机主机，这个时候你会发现我除了按它的开关按钮之外，好像什么也干不了。然后我买了键盘、鼠标、显示器、摄像头等外设，然后通过usb接口插上之后就可以操作电脑了，电脑是怎么识别这些外接设备（键盘、鼠标、摄像头等）的呢？ 这就是usb协议的作用了，外接设备和电脑，都遵循usb协议，然后大家就可以在同一个频道进行交流了；同样的MCP就是为了干这件事情，让大模型和给大模型提供增强能力的服务能同频进行交流</p>
<figure><img src="/imgs/column/springai/07-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 1.2 MCP总体架构</h3>
<p>MCP遵循客户端-服务端（CS）的架构，一个主机可以连接多个MCP服务端</p>
<figure><img src="/imgs/column/springai/07-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的描述和整体架构图，可以看到在MCP的架构中，有三个重要的角色</p>
<ul>
<li>MCP Hosts(MCP主机)： 通过mcp协议获取数据的程序（比如 Claude Desktop, IDE 或者 ai工具）</li>
<li>MCP Clients(MCP客户端): mcp协议客户端，作为调用者，通常与mcp服务端是成对出现，用于连接mcp server，实现双方通信</li>
<li>MCP Servers(MCP服务端): mcp协议服务端，作为提供者，实现MCP协议提供特定的功能</li>
</ul>
<p>除了上面三个角色之外，在架构图中，还有两个</p>
<ul>
<li>Local Data Sources: MCPServer所在的计算机上本地的资源信息，如文件、数据库、应用服务等，即MCP通过操作(读取、访问、写入等)这些本地资源来提供特定能力</li>
<li>Remote Service: MCPServer通过调用远程的服务来提供能力</li>
</ul>
<h3> 1.3 MCP工作原理</h3>
<p>mcp只是一个协议，和http协议一样，本身不直接提供能力或者服务，我们能实际感知到的服务表现只是协议上层的应用封装</p>
<p>比如http协议，常见的工作流程是我们打开浏览器，点开网页，通过http协议访问到对应的后台服务器，然后对方将网页信息传输到我们的浏览器上展示为可视化的网页内容，从而实现信息的曝光</p>
<p>那么mcp协议是怎么工作的呢？</p>
<ol>
<li>用户通过客户端发起提问</li>
<li>客户端将问题传递给 LLM</li>
<li>LLM 分析并选择合适的工具</li>
<li>通过 MCP 协议向服务端发送工具执行指令</li>
<li>工具执行后结果返回给 LLM</li>
<li>LLM 生成最终回复</li>
<li>回复通过客户端展示给用户</li>
</ol>
<figure><img src="/imgs/column/springai/07-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 1.4 SpringAI MCP 实现</h3>
<p>SpringAI提供了MCP的Client/Server的集成，对于上层业务而言，要想实现一个MCP Server/Client比较简单</p>
<p><strong>MCP客户端</strong></p>
<p>MCP 客户端是 Model Context Protocol（MCP）架构的核心组件，负责建立并管理与 MCP 服务器的连接。它实现协议的客户端逻辑，主要处理以下功能：</p>
<ul>
<li>协议版本协商以确保与服务器的兼容性</li>
<li>功能协商以确定可用特性</li>
<li>消息传输及 JSON-RPC 通信</li>
<li>工具发现与执行</li>
<li>资源访问与管理</li>
<li>提示词系统交互</li>
<li>可选功能
<ul>
<li>根目录管理</li>
<li>采样支持</li>
</ul>
</li>
<li>同步与异步操作</li>
<li>传输协议选项：
<ul>
<li>基于 Stdio 的进程间通信传输协议</li>
<li>基于 Java HttpClient 的 SSE 客户端传输协议</li>
<li>WebFlux SSE 客户端传输协议（用于响应式 HTTP 流式通信）</li>
</ul>
</li>
</ul>
<figure><img src="/imgs/column/springai/07-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>MCP服务端</strong></p>
<p>MCP 服务器是 Model Context Protocol（MCP）架构的基础组件，用于向客户端提供工具、资源和功能。它实现协议的服务端逻辑，主要职责包括：</p>
<ul>
<li>服务端协议操作的实现
<ul>
<li>工具暴露与发现</li>
<li>基于 URI 的资源管理及访问</li>
<li>提示（Prompt）模板的提供与处理</li>
<li>与客户端的功能协商</li>
<li>结构化日志记录与通知</li>
</ul>
</li>
<li>并发客户端连接管理</li>
<li>同步与异步 API 支持</li>
<li>传输协议实现：
<ul>
<li>基于 Stdio 的进程间通信传输协议</li>
<li>基于 Servlet 的 SSE 服务器传输协议</li>
<li>WebFlux SSE 服务器传输协议（用于响应式 HTTP 流式通信）</li>
<li>WebMVC SSE 服务器传输协议（用于基于 Servlet 的 HTTP 流式通信）</li>
</ul>
</li>
</ul>
<figure><img src="/imgs/column/springai/07-5.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 二、创建一个MCP Server</h2>
<p>接下来我们进入正文，如何创建一个MCP Server，并且让我们的大模型能够访问这个MCP Server</p>
<h3> 1. 项目创建</h3>
<p>项目创建方式与之前并无差别，创建一个SpringBoot项目，并引入SpringAI的依赖，有需要的小伙伴参考 <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 1. 依赖配置</h3>
<p>在pom配置文件中需要添加核心的依赖，这里是 <code>spring-ai-starter-mcp-server-webmvc</code></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在<code>application.yml</code>配置文件中，设置MVC Server的相关参数 (下面基本都是默认配置)</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点参数说明：</p>
<ul>
<li>sse-endpoint: 用于 <code>Web</code> 传输的自定义 <code>SSE</code> 端点路径，MCP Client主要连接的就是这个端点</li>
<li>sse-message-endpoint: 客户端用于发送消息的端点路径,如后续大模型调用工具时，走的就是这个端点</li>
<li>type: 服务器类型（同步/异步）</li>
</ul>
<h3> 2. 创建一个MCP Server</h3>
<p>对于SpringAI而言，创建MCP Server和Function calling有点相似，也是通过 <code>@Tool</code> 注解将方法声明为工具，区别是一个作为mcp的工具，一个是作为function calling的回调方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后将这个工具注册为MCP工具暴露给大模型</p>
<p>SpringAI的自动配置将检测并注册来自以下组件的所有工具回调</p>
<ul>
<li>独立的 ToolCallback Bean</li>
<li>ToolCallback Bean 列表</li>
<li>ToolCallbackProvider Bean</li>
</ul>
<p>工具按名称去重，每个工具名称仅保留首次出现的实例，如下创建一个<code>ToolCallbackProvider</code>的 <code>@Bean</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 启动项目</h3>
<p>启动项目，访问<a href="http://localhost:8080/sse" target="_blank" rel="noopener noreferrer">http://localhost:8080/sse</a>, 可以看到MCP Server已经启动了</p>
<figure><img src="/imgs/column/springai/07-6.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. Trae配置MCP</h3>
<p>接下来我们使用Trae来连接上面实现的mcp server，并使用mcp server提供的工具</p>
<p>以 TraeCN 2.0 为例，下面介绍下具体的配置过程</p>
<figure><img src="/imgs/column/springai/07-7.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>需要贴在trae中的mcp server的json配置如下</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后再来访问看看实际的效果</p>
<figure><img src="/imgs/column/springai/07-8.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>大模型准确的调用了我们刚才创建的MCPServer，分别返回了伦敦和巴黎的时间</p>
<h3> 5. 小结</h3>
<p>到这里我们已经实现了一个功能齐备的MCPServer，整体的代码实现非常简单，在需要作为MCP工具的，在方法上添加<code>@Tool</code>注解，然后借助创建<code>ToolCallbackProvider</code>将这些工具注册出来即可</p>
<p>本文介绍的是MCP通过http sse实现的，创建MCP Server的实现方式有很多种，这里只是介绍最简单的一种web同步请求，且没有权限管控</p>
<p>在创建一个生成可用的mcp server，目前还缺一个非常关键的认证机制，这个会在接下来的文章进行说明</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S07-mcp-server" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/07-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>08.MCPServer简单鉴权的实现</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/08.MCP%20Server%E7%AE%80%E5%8D%95%E9%89%B4%E6%9D%83%E7%9A%84%E5%AE%9E%E7%8E%B0.html</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/08.MCP%20Server%E7%AE%80%E5%8D%95%E9%89%B4%E6%9D%83%E7%9A%84%E5%AE%9E%E7%8E%B0.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">08.MCPServer简单鉴权的实现</source>
      <description>08.MCPServer简单鉴权的实现 上面一篇 实现一个简单的McpServer 带大家构建了一个自己的McpServer，其功能非常简单，接下来我们尝试逐步进行补全，我们下来看一下，如何给其加上权限管控，避免服务被白嫖 一、MCP Server搭建</description>
      <category>SpringAI</category>
      <pubDate>Mon, 28 Jul 2025 14:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 08.MCPServer简单鉴权的实现</h1>
<p>上面一篇 <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/07.%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84McpServer.html" target="blank">实现一个简单的McpServer</a> 带大家构建了一个自己的McpServer，其功能非常简单，接下来我们尝试逐步进行补全，我们下来看一下，如何给其加上权限管控，避免服务被白嫖</p>
<h2> 一、MCP Server搭建</h2>
<p>我们直接在前面的搭建的McpServer基础上进行能力扩展，因此整个项目的搭建和相关配置与上文一致，这里不再赘述过程，只贴下核心的信息</p>
<h3> 1. 项目配置</h3>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置文件指定mcp server相关参数：<code>application.yml</code></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. MCP Server创建</h3>
<p>一个根据传入时区，返回对应的时间的工具</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 二、权限管控</h2>
<h3> 1. 权限管理</h3>
<p>我们这里直接采用Http的权限管控，即在请求头中添加<code>Authorization</code>字段，值为<code>Bearer &lt;token&gt;</code> 或者 <code>Basic &lt;user:password&gt;</code>方式</p>
<p>为了针对MCP Server的权限进行管理，我们考虑通过自定义的<code>Filter</code>来实现，具体的逻辑为：</p>
<ul>
<li>拦截 <code>/sse</code>, <code>/mcp/messages</code>请求</li>
<li>校验请求头中的<code>Authorization</code>字段，判断是否满足要求</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的实现中，注意两点：</p>
<ul>
<li>注解<code>@WebFilter</code>，表示这是一个过滤器，并且异步支持（这个异步支持必须开启，否则mcp客户端无法正常连接）</li>
<li>拦截的url为<code>/sse</code>或者<code>/mcp/messages</code>: 这里我们分别处理sse请求和mcp请求，将他们与其他的请求区分开
<ul>
<li>鉴权逻辑：从请求头中获取<code>Authorization</code>字段，判断是否满足要求</li>
</ul>
</li>
</ul>
<p>然后调整启动类，支持扫描自定义的过滤器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. Trae调整MCP配置</h3>
<p>因为添加了权限管控，所以需要调整MCP的配置，在之前的基础上，加一个请求头</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来走一个验证对比，分别是没有添加权限的以及加了权限管控的</p>
<figure><img src="/imgs/column/springai/08-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>说明：如果是用户名+密码的鉴权方式，则可以将上面json配置中的 <code>Authorization</code>相关内容替换为:</p>
<ul>
<li><code>"Authorization": "Basic eWlodWk6MTIzNDU2Nzg="</code></li>
<li><code>eWlodWk6MTIzNDU2Nzg=</code> 为用户名密码的base64编码，解码之后为 <code>yihui:12345678</code></li>
</ul>
<h3> 3. 小结</h3>
<p>这里我们实现了一个简单的权限管控，通过自定义的过滤器来实现，具体的逻辑为：</p>
<ul>
<li>拦截 <code>/sse</code>, <code>/mcp/messages</code>请求</li>
<li>校验请求头中的<code>Authorization</code>字段，判断是否满足要求</li>
<li>添加权限的MCP配置</li>
</ul>
<p>当然，这里只是简单的实现，实际生产中，我们可以通过数据库来实现权限的存储和查询，也可以通过其他方式来实现权限的验证，例如通过JWT+OAuth2.0的方式来实现；不管是哪种方式，核心的原理依然是web应用鉴权这一套，无非是应用的场景不同，一个是web用户、一个是mcp客户端而已</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S08-mcp-server-basic-auth" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/08-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>09.ChatClient使用说明</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/09.ChatClient%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.html</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/09.ChatClient%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">09.ChatClient使用说明</source>
      <description>09.ChatClient使用说明 SpringAI中，ChatModel作为与大模型交互的具体实现，更上一层的应用推荐则是使用ChatClient，特别是在结构化输出、多轮对话的场景，ChatClient提供了更方便的调用方式 如结构化输出，两者的写法对比如下 // 结构化返回场景: // chatModel方式 BeanOutputConverter&amp;lt;ActorsFilms&amp;gt; beanOutputConverter = new BeanOutputConverter&amp;lt;&amp;gt;(ActorsFilms.class); String format = beanOutputConverter.getFormat(); PromptTemplate template = new PromptTemplate(&amp;quot;&amp;quot;&amp;quot; 帮我返回五个{actor}导演的电影名 {format} &amp;quot;&amp;quot;&amp;quot;); Prompt prompt = template.create(Map.of(&amp;quot;actor&amp;quot;, actor, &amp;quot;format&amp;quot;, format)); Generation generation = chatModel.call(prompt).getResult(); if (generation == null) { return null; } return beanOutputConverter.convert(generation.getOutput().getText()); // ChatClient方式 PromptTemplate template = new PromptTemplate(&amp;quot;帮我返回五个{actor}导演的电影名，要求中文返回&amp;quot;); Prompt prompt = template.create(Map.of(&amp;quot;actor&amp;quot;, actor)); ActorsFilms films = ChatClient.create(chatModel).prompt(prompt).call().entity(ActorsFilms.class);</description>
      <category>SpringAI</category>
      <pubDate>Fri, 01 Aug 2025 18:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 09.ChatClient使用说明</h1>
<p>SpringAI中，<code>ChatModel</code>作为与大模型交互的具体实现，更上一层的应用推荐则是使用<code>ChatClient</code>，特别是在结构化输出、多轮对话的场景，<code>ChatClient</code>提供了更方便的调用方式</p>
<p>如结构化输出，两者的写法对比如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 一、基本使用</h2>
<h3> 1. 创建ChatClient</h3>
<p><strong>使用自动配置的<code>ChatClient.Builder</code></strong></p>
<p>如果你的项目中，只有一个大模型使用，且使用的是官方提供的<code>starter</code>进行的接入，那么你可以直接使用SpringBoot自动装配的<code>ChatClient.Builder</code>来创建<code>ChatClient</code></p>
<p>如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，请注意，当一个应用中需要使用多个聊天模型时，则不能使用上面这种方式了，因为很难知道底层到底用的是哪个模型，此时则建议使用<code>ChatModel</code>进行创建</p>
<p><strong>使用ChatModel创建ChatClient</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. OpenAI兼容API的客户端初始化方式</h3>
<p>借助 <code>OpenAiApi</code> 与 <code>OpenAiChatModel</code> 类提供的 mutate() 方法，来实现兼容OpenAI API 的调用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 提示词传入</h3>
<p>创建<code>ChatClient</code>时，需要传入的<code>Prompt</code>对象用于和大模型进行交互，提供了三种方式</p>
<p><strong>直接接收String</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这种表示传入的文本，作为用户消息传送给大模型</p>
<p><strong>接收Prompt对象</strong></p>
<p>直接接收<code>Prompt</code>对象，具体的交互信息封装在<code>Prompt</code>对象中，由用户来管控</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>Fluent式</strong></p>
<p>通过无参方式启动FluentAPI，支持逐步构建系统消息、用户消息提示词</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 响应</h3>
<p>AI 模型返回的 <code>ChatResponse</code> 对象，封装了模型返回的 <code>Generation</code> 对象，以及一些元数据、token统计</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如我们希望获取用户的token情况，则可以在元数据中获取</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>获取返回的消息</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结构化输出，如需将返回的String映射为实体类，则可以考虑使用 <code>entity()</code> 来实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/09-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>当然，前面介绍的结构化输出时，也提到了可以借助 <code>ParameterizedTypeReference</code> 来实现泛型等复杂类型的指定，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/09-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 流式调用</h3>
<p>流式调用，前面介绍的通过<code>call</code>方法实现同步请求大模型，等待模型返回结果，然后进行结果处理。我们平时使用大模型时，更常见的是流式的交互方式，问一个问题，对方一点一点的返回结果</p>
<p>对于<code>ChtClient</code>而言，要想实现流式调用，则需要借助<code>stream()</code>方法，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>访问示例如下：</p>
<figure><img src="/imgs/column/springai/09-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 二、进阶使用</h2>
<h3> 1. 提示词模板</h3>
<p><code>ChatClient</code> <code>Fluent</code> 式 API 支持提供含变量的用户/系统消息模板，运行时进行替换。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>默认使用的是 <code>{}</code> 的模板变量替换，当然如果你有诉求，想用 <code>&lt;&gt;</code> 进行替换（如提示词中包含json时，<code>{}</code>的方式可能不太适合了），可以如下进行调整</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. stream结构化返回</h3>
<p>使用 <code>call()</code> 同步调用时，结构化输出比较简单，直接通过 <code>entity()</code> 方法传入对象类型即可；对于流式的场景，由于大模型是逐步返回的，没有获取到完整的内容直接转换为目标对象，基本就是序列化异常了</p>
<p>对于 <code>stream</code> 方式，需要接过话输出时，可以考虑使用下面的方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 默认值</h3>
<p>我们可以在<code>ChatClient</code>创建时，使用一些默认的系统消息、提示词设置（通过 <code>defaultXxx</code> 的方式）</p>
<p>如下面给出了提供默认的消息提示词（支持带参数） 和默认的模型参数设置</p>
<ul>
<li>说明：默认的配置，可以通过不带 <code>default</code> 前缀的相同方法进行覆盖</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/09-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. Advisor</h3>
<p><code>Advisor</code> API 为 Spring 应用中的 AI 驱动交互提供灵活强大的拦截、修改和增强能力。这个思路基本和AOP 类似，但是 <code>Advisor</code> 允许在运行时动态修改方法调用，从而实现更灵活的逻辑处理。</p>
<p>如我们希望在用户消息基础上追加或增强上下文数据时</p>
<ul>
<li>可以是RAG技术给大模型喂资料</li>
<li>也可以是集成聊天历史，实现多轮对话</li>
</ul>
<p>比如之前在介绍聊天上下文时，提到的借助<code>MessageChatMemoryAdvisor</code>来实现多轮对话</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/09-5.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>除了上面这个之外，另外一个记录<code>ChatClient</code>请求和返回的 <code>SimpleLoggerAdvisor</code> 也是常用的增强</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要查看日志，需要调整 advisor 包的日志级别设为 <code>DEBUG</code>，如下设置即可</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果觉得默认的输出不合心意，也可以在创建时，指定传参、返回的打印方式，如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，当传入多个 <code>advisor</code> 时，传入的顺序很重要，决定了它们的执行顺序。每个 Advisor 都会以某种方式修改提示词或上下文，且一个 Advisor 所做的更改会传递给链中的下一个 Advisor。</p>
<h2> 三、小结</h2>
<p>本文的内容主要是相对成体系的介绍了一下前面几篇文章示例中的 <code>ChatClient</code> 的使用方式，同时也将前面的内容或多或少都覆盖了一部分。 通常来讲，我们与大模型之间的交互，更推荐的是基于<code>ChatClient</code>来实现,SpringAI对其上层使用，封装的很是齐全了，有兴趣的小伙伴可以赶紧体验一下</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S09-chat-client" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/09-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>10.Advisor实现SpringAI能力增强</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/10.Advisor%E5%AE%9E%E7%8E%B0SpringAI%E4%BA%A4%E4%BA%92%E5%A2%9E%E5%BC%BA.html</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/10.Advisor%E5%AE%9E%E7%8E%B0SpringAI%E4%BA%A4%E4%BA%92%E5%A2%9E%E5%BC%BA.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">10.Advisor实现SpringAI能力增强</source>
      <description>10.Advisor实现SpringAI能力增强 SpringAI通过Advisor API为拦截、修改、增强Spring应用中的AI交互提供了灵活且强大的能力支撑 核心优势在于：封装可复用的生成式AI模式、转换与大语言模型（LLM）交互的数据、实现跨模型与用例的可移植性。 一、基础知识 1. 核心组件 因为大模型一般支持同步/异步流式两种访问方式，相应的SpringAI也提供同步调用call 和 流式调用 stream 两种方式；</description>
      <category>SpringAI</category>
      <pubDate>Mon, 04 Aug 2025 14:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 10.Advisor实现SpringAI能力增强</h1>
<p>SpringAI通过<code>Advisor API</code>为拦截、修改、增强Spring应用中的AI交互提供了灵活且强大的能力支撑</p>
<p>核心优势在于：封装可复用的生成式AI模式、转换与大语言模型（LLM）交互的数据、实现跨模型与用例的可移植性。</p>
<h2> 一、基础知识</h2>
<h3> 1. 核心组件</h3>
<p>因为大模型一般支持同步/异步流式两种访问方式，相应的SpringAI也提供同步调用<code>call</code> 和 流式调用 <code>stream</code> 两种方式；</p>
<p>这两种不同的方式，对应的<code>Advisor</code>也不太一样</p>
<ul>
<li>流式：<code>StreamAdvisor</code> 和 <code>StreamAdvisorChain</code></li>
<li>非流式：<code>CallAdvisor</code> 和 <code>CallAdvisorChain</code></li>
</ul>
<p>接口定义如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中<code>ChatClientRequest</code>表示未密封的请求参数，<code>ChatClientResponse</code>表示的聊天完成响应的结果</p>
<figure><img src="/imgs/column/springai/10-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的继承关系图也可以看出，核心的方法为 <code>adviseCall</code> 和 <code>adviseStream</code>，在这两个方法内，执行检查未密封的 Prompt 数据、定制与增强 Prompt 内容、调用 Advisor 链中的下一实体、选择性阻断请求、分析聊天完成响应，并通过抛出异常标识处理错误等步骤</p>
<ul>
<li>getOrder() 方法决定 Advisor 在链中的执行顺序</li>
<li>getName() 则提供唯一的 Advisor 标识名称</li>
</ul>
<h3> 2. Advisor执行流程</h3>
<p>下面流程图展示了 <code>Advisor</code> 链与聊天模型的交互过程：</p>
<figure><img src="/imgs/column/springai/10-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol>
<li>封装用户的提示词，创建 <code>ChatClientRequest</code> 对象，并创建一个空的 <code>Advisor</code>上下文对象</li>
<li>链中每个 <code>Advisor</code> 依次处理请求并可进行修改，也可选择阻断请求（不调用下一实体）。若选择阻断，该 <code>Advisor</code> 需负责填充响应内容。</li>
<li>链中的最后一个 <code>Advisor</code> 调用模型</li>
<li>聊天模型响应结果返回给 <code>Advisor Chain</code>，并被转换为包含共享 AdvisorContext 实例的 AdvisedResponse 对象。</li>
<li>链中每个 <code>Advisor</code> 一次处理或修改响应</li>
<li>通过提取 <code>ChatCompletion</code> 内容，最终生成的 <code>ChatClientResponse</code> 将返回给客户端</li>
</ol>
<h3> 3. 执行顺序</h3>
<p>链中 Advisor 的执行顺序由 getOrder() 方法决定</p>
<ol>
<li>数值越小，优先级越高</li>
<li><code>Advisor</code> 链采用栈式结构运作
<ul>
<li>链首的 <code>Advisor</code> 优先处理请求</li>
<li>链尾的 <code>Advisor</code> 优先处理响应</li>
</ul>
</li>
<li>控制执行顺序
<ul>
<li>通过调整 <code>order</code> 值，来控制执行顺序</li>
<li>当多个<code>Advisor</code>的<code>order</code>值相同时，则无法完全确认执行顺序</li>
</ul>
</li>
</ol>
<h2> 二、自定义<code>Advisor</code>开发</h2>
<p>接下来我们通过实现一个自定义的 <code>Advisor</code> 来实现大模型交互的耗时统计</p>
<h3> 1. 耗时统计Advisor</h3>
<p>接下来，我们实现一个简单的 <code>advisor</code> 用于统计大模型的耗时情况。首先创建一个 <code>CostAdvisor</code> 分别实现 <code>CallAdvisor</code> 和 <code>StreamAdvisor</code> 接口，让它同时适用于同步/流式场景</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来是关键的类实现，既然是耗时统计，那就设定这个 <code>Advisor</code> 优先级最高，在执行前后分别计时，用于获取耗时情况；并将相关信息写入到上下文中</p>
<p>因此一个完整的实现可以如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同步的实现比较好理解，重点说一下流式调用中，耗时时间的打印情况，这里借助的<code>MessageAggregator</code>工具类，用于将 Flux 响应聚合为 <code>AdvisedResponse</code>。适用于观察完整响应（即回答完毕之后），记录耗时时间</p>
<p>其次就是上下文的传递，可以通过 <code>chatClientRequest.context().put("start-time", start);</code> 和 <code>response.context().put("end-time", end);</code> 方式设置用于共享的上下文参数</p>
<h3> 2. 测试验证</h3>
<p>写一个简单的端点用于验证 CostAdvisor</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/10-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的访问截图也可以看出，<code>CostAdvisor</code> 拦截了请求，并记录了耗时情况，并打印在控制台</p>
<h2> 三、小结</h2>
<p>本篇文章主要介绍了SpringAI如何通过 <code>Advisor</code> 来实现大模型交互能力的增强，并通过实现了一个简单的 <code>CostAdvisor</code> 演示如何实现自定义的advisor</p>
<p>SpringAI 内置了一些常用的 advisor， 比如我们之前介绍过的上下文、日志打印等</p>
<ol>
<li>对话历史相关</li>
</ol>
<ul>
<li><code>MessageChatMemoryAdvisor</code>
<ul>
<li>检索记忆并将其作为信息集合添加到提示中。这种方法可以保持对话历史的结构。注意，并非所有人工智能模型都支持这种方法。</li>
</ul>
</li>
<li><code>PromptChatMemoryAdvisor</code>
<ul>
<li>检索记忆内容并将其整合到提示词的系统文本中。</li>
</ul>
</li>
<li><code>VectorStoreChatMemoryAdvisor</code>
<ul>
<li>从向量存储库检索记忆内容并注入提示词的系统文本。该 Advisor 能高效搜索海量数据集中的相关信息。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>问答相关</li>
</ol>
<ul>
<li><code>QuestionAnswerAdvisor</code>
<ul>
<li>该 Advisor 通过向量存储实现问答功能，采用检索增强生成（RAG）模式。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>内容安全</li>
</ol>
<ul>
<li><code>SafeGuardAdvisor</code>
<ul>
<li>基础防护型 Advisor，用于阻止模型生成有害或不恰当内容。</li>
</ul>
</li>
</ul>
<p>此外需要重点注意的是，我们实现的 <code>advisor</code> 需要同时考虑同步和流式的两种方式</p>
<figure><img src="/imgs/column/springai/10-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>非流式 Advisor 处理完整请求与响应。</li>
<li>流式 Advisor 采用响应式编程理念（如 Flux 处理响应），以连续流形式处理请求与响应。</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S10-cost-advise" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/10-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>11.图像模型生成图片</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/11.%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%9E%8B.html</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/11.%E5%9B%BE%E5%83%8F%E6%A8%A1%E5%9E%8B.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">11.图像模型生成图片</source>
      <description>11.图像模型生成图片 截止到目前为止，我们所有的体验的还仅限于聊天模型，一问一答，且都是基于文本的交互方式；现在主流的模型的应用场景，涉及图像识别、图像生成、图像检索、图像处理等等，SpringAI也提供了相应的模型接口，方便开发者进行图像模型应用的开发 接下来我们通过一个实例，来看一下在SpringAI中，如何接入图像模型 一、准备工作 首先还是得准备一个大模型的开发者账号，同样的为了简化大家的使用成本，我们依然采用免费的大模型 - 智谱 来完成</description>
      <category>SpringAI</category>
      <pubDate>Mon, 04 Aug 2025 15:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 11.图像模型生成图片</h1>
<p>截止到目前为止，我们所有的体验的还仅限于聊天模型，一问一答，且都是基于文本的交互方式；现在主流的模型的应用场景，涉及图像识别、图像生成、图像检索、图像处理等等，SpringAI也提供了相应的模型接口，方便开发者进行图像模型应用的开发</p>
<p>接下来我们通过一个实例，来看一下在SpringAI中，如何接入图像模型</p>
<h2> 一、准备工作</h2>
<p>首先还是得准备一个大模型的开发者账号，同样的为了简化大家的使用成本，我们依然采用免费的大模型 - <a href="https://www.bigmodel.cn/pricing" target="_blank" rel="noopener noreferrer">智谱</a> 来完成</p>
<h3> 1. 模型选择</h3>
<p>智谱官方提供了两个免费的多模态模型，分别为</p>
<ul>
<li>CogView-3-Flash: 生成图片</li>
<li>CogVideoX-Flash: 生成视频</li>
</ul>
<figure><img src="/imgs/column/springai/11-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 创建密钥</h3>
<p>在智普的开放平台获取密钥：<a href="https://open.bigmodel.cn/usercenter/proj-mgmt/apikeys" target="_blank" rel="noopener noreferrer">https://open.bigmodel.cn/usercenter/proj-mgmt/apikeys</a></p>
<figure><img src="/imgs/column/springai/01-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后在配置文件中，添加智普的密钥</p>
<h3> 3. 配置密钥</h3>
<p>在配置文件 <code>application.yml</code> 中，指定密钥和默认的模型</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的 model，这里使用是图像生成的模型，与前面介绍的聊天模型中的 <code>GLM-4-Flash</code> 不一致</p>
<h2> 二、图像模型使用</h2>
<p>接下来我们正式进入图像模型的使用环节，具体的项目创建过程，与之前的并无差别，基本流程同 <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 1. 依赖配置</h3>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 创建一个控制器</h3>
<p>我们创建一个文生图的控制器，定义一个基于智谱图像模型的端点 <code>/genImg</code>， 生成之后，将返回的图片链接下载图片文件，直接返回给前端</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：</p>
<ul>
<li>具体的使用方式，直接基于 <code>ImageModel</code> 的调用来实现图片生成</li>
<li>实测： <code>ImageOptions</code> 中 <code>model</code> 参数，比填，不然不会使用配置中默认指定的 <code>CogView-3-Flash</code></li>
</ul>
<p>官方实现这里存在bug，由于传参没指定model，被sdk中默认的<code>cogview-3</code>给覆盖了（而不是默认选项中的 <code>CogView-3-Flash</code>）</p>
<figure><img src="/imgs/column/springai/11-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="/imgs/column/springai/11-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 测试验证</h3>
<p>接下来我们启动项目，验证一下图像模型的实际表现</p>
<figure><img src="/imgs/column/springai/11-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>题外话：生成的卡通图片还差强人意，如果换成写实风，这个模型的表现效果就很不理想了😂 （不过毕竟是免费的，还能要求啥呢~）</p>
<p>请重点注意： 智谱的 <code>ImageModel</code> 的实现是不支持生成视频的，最直接的证据就是 <code>ZhiPuAiImageApi</code> 的实现中访问的path路径是 <code>/v4/images/generations</code>，而视频的访问路径应该是 <code>/v4/videos/generations</code>，且交互方式也不一致（视频是异步查询返回结果）;</p>
<p>目前<code>1.0.0</code>版本以及<code>1.1.0-SNAPSHOT</code>的<code>spring-ai-zhipuai</code>客户端，没有实现视频模型的访问；如有需要，需自己实现</p>
<h2> 三、小结</h2>
<p>本文主要介绍了图像模型的使用，虽然是以智谱为例进行的实例介绍；其他的模型使用姿势，实际也差不多，通用的使用方式如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S11-image-model" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/11-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>12.多模态实现图片卡路里识别</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/12.%E5%A4%9A%E6%A8%A1%E6%80%81%E5%AE%9E%E7%8E%B0%E9%A3%9F%E6%9D%90%E5%9B%BE%E7%89%87%E5%8D%A1%E8%B7%AF%E9%87%8C%E8%AF%86%E5%88%AB%E7%A4%BA%E4%BE%8B.html</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/12.%E5%A4%9A%E6%A8%A1%E6%80%81%E5%AE%9E%E7%8E%B0%E9%A3%9F%E6%9D%90%E5%9B%BE%E7%89%87%E5%8D%A1%E8%B7%AF%E9%87%8C%E8%AF%86%E5%88%AB%E7%A4%BA%E4%BE%8B.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">12.多模态实现图片卡路里识别</source>
      <description>12.多模态实现图片卡路里识别 现在大模型的快速发展，已经让其不仅只接受文本，也可以接受图像、音频、视频等多模态数据，SpringAI也提供了相应的模型接口，方便开发者进行多模态模型应用开发 如如 OpenAI 的GPT-4o、Google 的Vertex AI Gemini 1.5、Anthropic 的 Claude3，以及开源模型 Llama3.2、LLaVA 和 BakLLaVA，都能接受文本、图像、音频和视频等多种输入，并通过整合这些输入生成文本响应。 SpringAI提供了非常简单的多模态输入集成，接下来我们通过一个简单实例，来看一下在SpringAI中，如何接入多模态模型</description>
      <category>SpringAI</category>
      <pubDate>Mon, 04 Aug 2025 17:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 12.多模态实现图片卡路里识别</h1>
<p>现在大模型的快速发展，已经让其不仅只接受文本，也可以接受图像、音频、视频等多模态数据，SpringAI也提供了相应的模型接口，方便开发者进行多模态模型应用开发</p>
<p>如如 OpenAI 的GPT-4o、Google 的Vertex AI Gemini 1.5、Anthropic 的 Claude3，以及开源模型 Llama3.2、LLaVA 和 BakLLaVA，都能接受文本、图像、音频和视频等多种输入，并通过整合这些输入生成文本响应。</p>
<p>SpringAI提供了非常简单的多模态输入集成，接下来我们通过一个简单实例，来看一下在SpringAI中，如何接入多模态模型</p>
<h2> 一、准备工作</h2>
<p>首先还是得准备一个大模型开发者账号，同样的为了简化大家使用的成本，我们依然采用免费的大模型 - <a href="https://www.bigmodel.cn/pricing" target="_blank" rel="noopener noreferrer">智谱</a> 来完成</p>
<h3> 1. 模型选择</h3>
<p>我们这里选择的是官方提供的免费图像理解模型 <code>GLM-4V-Flash</code>，基于它来做一个食物图片的分类和卡路里计算</p>
<h3> 2. 项目创建</h3>
<p>创建一个SpringBoot项目，并引入SpringAI依赖，基本流程如 <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：我们这里使用 huttol-http 进行互联网的图片下载</p>
<h3> 3. 密钥配置</h3>
<p>在配置文件中，指定密钥和默认的模型</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 二、多模态使用</h2>
<p>接下来我们进入多模态的实例开发</p>
<h3> 1. 图片识别控制器</h3>
<p>定义一个图片识别控制器，接收图片的URL，并返回识别结果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的实现方式也可以看出，多模态的使用方式与<code>ChatModel</code>的使用方式基本一致，只是在构建用户消息的时候，携带了一个 <code>Media</code> 类型的输入</p>
<h3> 2. 测试</h3>
<p>为了测试，使用大模型帮我们生成一张食物图，避免版权纷争</p>
<figure><img src="/imgs/column/springai/12-1.webp" alt="待识别图" tabindex="0" loading="lazy"><figcaption>待识别图</figcaption></figure>
<p>然后访问测试接口，传入图片的URL，并指定识别的提示语</p>
<div class="language-curl line-numbers-mode" data-ext="curl"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/12-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 结构化输出</h3>
<p>上面直接返回的文本，不太方便我们的业务使用，因此可以考虑将返回结果进行结构化约束，比如，定义我们希望接受的对象（通过 <code>@JsonPropertyDescription</code> 注解来约束字段描述，在生成jsonSchema给大模型时，会将这些描述信息返回给模型）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后调整下多模态的调用，通过<code>entity()</code>来定义返回</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/12-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 三、小结</h2>
<p>本文主要介绍了多模态的使用，虽然以智谱为例进行了实例介绍；其他的模型使用姿势，实际也差不多，基本上都是<code>ChatModel/ChatClient</code>的使用方式，通过在构建用户消息的时候，携带一个 <code>Media</code> 类型的图片或者音视片资源，即可实现多模态的调用</p>
<p>但是，请注意，在使用多模态之前，前先确认对应的大模型是否支持多模态的调用，否则，可能会导致调用失败</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S12-multimodality-model" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/12-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>13.支持MCP Client的AI对话实现</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/13.%E6%94%AF%E6%8C%81MCP%20Client%E7%9A%84AI%E5%AF%B9%E8%AF%9D%E5%AE%9E%E7%8E%B0.html</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/13.%E6%94%AF%E6%8C%81MCP%20Client%E7%9A%84AI%E5%AF%B9%E8%AF%9D%E5%AE%9E%E7%8E%B0.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">13.支持MCP Client的AI对话实现</source>
      <description>13.支持MCP Client的AI对话实现 前面介绍了通过SpringAI来实现MCP Server，接下来我们再看一下，通过SpringAI来实现一个支持上次实现的MCP Client的AI对话 一、项目初始化 SpringAI MCP客户端的starter，提供了MCP客户端的自动配置，支持多种传输方式（本地+网络），支持同步、异步的调用 1. 项目创建 创建一个SpringBoot项目，并引入SpringAI依赖，基本流程如 创建一个SpringAI-Demo工程</description>
      <category>SpringAI</category>
      <pubDate>Tue, 05 Aug 2025 17:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 13.支持MCP Client的AI对话实现</h1>
<p>前面介绍了通过SpringAI来实现MCP Server，接下来我们再看一下，通过SpringAI来实现一个支持上次实现的<code>MCP Client</code>的<code>AI</code>对话</p>
<h2> 一、项目初始化</h2>
<p>SpringAI MCP客户端的starter，提供了MCP客户端的自动配置，支持多种传输方式（本地+网络），支持同步、异步的调用</p>
<h3> 1. 项目创建</h3>
<p>创建一个SpringBoot项目，并引入SpringAI依赖，基本流程如 <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中<code>spring-ai-starter-mcp-client</code>依赖，提供了MCP客户端的starter，使用的是智谱的免费大模型<code>GLM-4-Flash</code></p>
<p>其次我们使用 <code>thymeleaf + htmx</code> 来实现一个简单的聊天界面</p>
<h3> 2. 项目配置</h3>
<p>在配置文件中，除了指定大模型的密钥、模型之外，还需要配置MCP客户端的参数</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们这里的使用的<code>MCP Server</code>为<a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S07-mcp-server" target="_blank" rel="noopener noreferrer">S07-mcp-server</a>中实现的根据地区获取当前时间的服务</p>
<h2> 二、MCP Client实现</h2>
<p>SpringAI 对MCP Client 的实现封装的非常好了，对于上层应用而言，直接可以通过自定注入的 <code>ToolCallbackProvider</code>，将mcp client作为大模型的工具调用添加到模型中，然后通过模型调用，即可完成MCP的使用演示</p>
<h3> 1. 初始化ChatClient</h3>
<p>直接通过模型和<code>ToolCallbackProvider</code>，来创建支持mcp调用的 <code>ChatClient</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 实现聊天对话</h3>
<p>聊天对话的实现，非常简单，通过 <code>ChatClient</code> 调用模型，并返回结果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 前端聊天页面实现</h3>
<p>聊天主页 index.html</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对话历史 <code>chat.html</code></p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 使用测试</h3>
<p>首先，启动mcp server， 然后再启动聊天对话框；然后开始对话</p>
<figure><img src="/imgs/column/springai/13-1.webp" alt="直接询问当前时间" tabindex="0" loading="lazy"><figcaption>直接询问当前时间</figcaption></figure>
<figure><img src="/imgs/column/springai/13-2.webp" alt="业务场景中携带时间" tabindex="0" loading="lazy"><figcaption>业务场景中携带时间</figcaption></figure>
<h2> 三、小结</h2>
<p>本文主要介绍将MCP Client的使用，整体应用起来，比较简单，甚至是比function calling更简单（因为自动将mcp服务注入为<code>ToolCallbackProvider</code>，可以直接传入<code>ChatClient</code>用作大模型的工具调用）</p>
<p>当然除了上面这种方式之外，我们也可以直接使用MCP Client来进行交互</p>
<blockquote>
<p>MCPClient 使用姿势参考官方文档： <a href="https://modelcontextprotocol.io/sdk/java/mcp-client" target="_blank" rel="noopener noreferrer">java-mcp-client</a></p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/13-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S13-mcp-client-chat" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/13-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>14.创建一个Langgraph4j实例工程</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/14.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AALanggraph4j%E5%AE%9E%E4%BE%8B%E5%B7%A5%E7%A8%8B.html</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/14.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AALanggraph4j%E5%AE%9E%E4%BE%8B%E5%B7%A5%E7%A8%8B.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">14.创建一个Langgraph4j实例工程</source>
      <description>14.创建一个Langgraph4j实例工程 沿用阿里的智能体定义，我们将基于SpringAI ChatClient开发的AI应用叫做单智能体应用；对于更复杂的应用场景，比如需要多个工具辅助工作，存在工作流切换的场景（举一个例子：输入一段评价，判断是好评还是差评，如果是好评，则自动回复多谢好评；如果是差评，则提取关键信息，将评价信息转发给人工客服，进行后续的售后维护等）称为多智能体应用 对于多智能体应用，使用python开发的小伙伴，更常接触的是LangGraph；对于java的生态下，目前也有两个替代的选择项</description>
      <category>SpringAI</category>
      <pubDate>Tue, 12 Aug 2025 17:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 14.创建一个Langgraph4j实例工程</h1>
<p>沿用阿里的智能体定义，我们将基于<code>SpringAI ChatClient</code>开发的AI应用叫做单智能体应用；对于更复杂的应用场景，比如需要多个工具辅助工作，存在工作流切换的场景（举一个例子：输入一段评价，判断是好评还是差评，如果是好评，则自动回复多谢好评；如果是差评，则提取关键信息，将评价信息转发给人工客服，进行后续的售后维护等）称为多智能体应用</p>
<p>对于多智能体应用，使用python开发的小伙伴，更常接触的是<code>LangGraph</code>；对于java的生态下，目前也有两个替代的选择项</p>
<ul>
<li><a href="https://github.com/langgraph4j/langgraph4j" target="_blank" rel="noopener noreferrer">LangGraphJ</a></li>
<li><a href="https://java2ai.com/docs/1.0.0.2/get-started/agent/" target="_blank" rel="noopener noreferrer">阿里智能体</a></li>
</ul>
<p>接下来我们来体验一下如何使用<code>LangGraph4J</code>来进行多智能体的开发</p>
<h2> 一、项目创建</h2>
<h3> 1. 创建一个SpringAI项目</h3>
<p>创建一个SpringAI项目，基本流程同 <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 2. 添加Langgraph4j依赖</h3>
<p>我们这里以智普大模型作为底层的LLM，因此对应的依赖除了langgraph4j之外就是智普的starter</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 参数配置</h3>
<p>在配置文件中 <code>application.yml</code>，设置大模型的访问密钥</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 创建工具</h3>
<p>我们这里创建一个工具类，内部提供两个工具，分别获取当前的时间和天气</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 创建智能体</h3>
<p>我们直接沿用官方的demo示例，来创建一个采用<code>langGraph4j</code>实现的基于智普大模型的智能体</p>
<figure><img src="/imgs/column/springai/14-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 测试验证</h3>
<p>在上面的Controller中，定义一个访问端点，实现智能体的访问</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/14-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的输出也可以看出，大模型有四次的工具调用，一次是获取北京当前时间，一次是获取北京当前天气，一次是获取伦敦当前时间，一次是获取伦敦当前天气</p>
<p>直接使用<code>langGraph4j</code>实现多轮对话，虽然效果是实现了，从直观感觉上和SpringAI的ChatClient好像没有太大的差别</p>
<p>对<code>langGraph4j</code>不太了解的小伙伴，可能会有很多疑问，工作流体现在什么地方呢，条件决策又该如何使用呢？这个框架是怎么工作的呢？又该如何使用它来开发Agent呢？</p>
<h2> 二、总结</h2>
<p><code>LangGraph4j</code> 是一个 Java 库，用于构建基于大型语言模型 (LLM) 的有状态多代理应用程序。它受 <code>Python</code> 库 <code>LangGraph</code> 的启发，旨在与 <code>Langchain4j</code> 和 <code>Spring AI</code> 等流行的 <code>Java LLM</code> 框架无缝协作。</p>
<p>LangGraph4j 的核心功能是定义循环图，使不同的组件（代理、工具或自定义逻辑）能够以有状态的方式进行交互</p>
<p>本文只能算是初步看了一眼<code>LangGraph4j</code>，演示了如何创建一个智能体开发的项目，接下来我们将逐渐深入探究一下这个框架的使用理念</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/advance-projects/A05-agent-langgraph-simple" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/14-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>15.接入OpenAI接口风格的大模型</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/15.%E6%8E%A5%E5%85%A5OpenAI%E6%8E%A5%E5%8F%A3%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%A4%A7%E6%A8%A1%E5%9E%8B.html</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/15.%E6%8E%A5%E5%85%A5OpenAI%E6%8E%A5%E5%8F%A3%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%A4%A7%E6%A8%A1%E5%9E%8B.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">15.接入OpenAI接口风格的大模型</source>
      <description>15.接入OpenAI接口风格的大模型 鉴于OpenAI在业内的地位，很多大模型的调用接口都是兼容OpenAI的，因此，在接入OpenAI的接口风格大模型时，若官方没有提供高可用的starter，那么直接使用OpenAI的starter就是一个非常好的选择了 接下来我们将演示一下，如何通过OpenAI的starter接入讯飞大模型 一、项目初始化 1. 项目创建 创建一个SpringBoot项目，并引入SpringAI依赖，基本流程如 创建一个SpringAI-Demo工程</description>
      <category>SpringAI</category>
      <pubDate>Tue, 26 Aug 2025 17:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 15.接入OpenAI接口风格的大模型</h1>
<p>鉴于OpenAI在业内的地位，很多大模型的调用接口都是兼容OpenAI的，因此，在接入OpenAI的接口风格大模型时，若官方没有提供高可用的starter，那么直接使用OpenAI的starter就是一个非常好的选择了</p>
<p>接下来我们将演示一下，如何通过OpenAI的starter接入讯飞大模型</p>
<h2> 一、项目初始化</h2>
<h3> 1. 项目创建</h3>
<p>创建一个SpringBoot项目，并引入SpringAI依赖，基本流程如 <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 2. 添加依赖</h3>
<p>我们这里直接使用OpenAI的starter作为大模型交互的工具，因此直接在依赖中，添加对应的stater即可</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 配置文件</h3>
<p>以讯飞星火为例，我们首先当官网申请对应的apiKey，并添加到配置文件中(或者通过环境变量、启动参数的方式传入)</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意看上面的配置，参数是放在 <code>spring.ai.openai</code> 下面的</p>
<p>另外一个需要注意的点就是 <code>base-url</code></p>
<figure><img src="/imgs/column/springai/15-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>虽然官方文档中给出的地址是 <a href="https://spark-api-open.xf-yun.com/v1/" target="_blank" rel="noopener noreferrer">https://spark-api-open.xf-yun.com/v1/</a>，但是我们不需要添加 <code>/v1</code>，原因在于OpenAI的实现中，已经自动补上了这个前缀</p>
<figure><img src="/imgs/column/springai/15-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 二、测试验证</h2>
<p>接下来我们验证一下大模型的调用</p>
<h3> 1. 联调接口实现</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用方式和前面介绍的SpringAI大模型调用没有任何区别，直接使用注入的<code>ChatModel</code>或者基于 <code>ChatModel</code> 创建 <code>ChatClient</code></p>
<h3> 2. 访问验证</h3>
<p>接下来直接访问这个接口，看看是否可以实现大模型的对话</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/15-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 手动创建模型</h3>
<p>上面介绍的是直接使用注入的<code>ChatModel</code>或者基于 <code>ChatModel</code> 创建 <code>ChatClient</code>；若我们一个项目中，存在多个满足OpenAi风格的大模型，则直接使用上面的方式不太优雅，因此，我们可以手动创建模型</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/15-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 三、总结</h2>
<p>本文主要介绍符合OpenAI接口风格的大模型接入方式，直接通过SpringAI-OpenAI的starter接入，或者手动创建模型，都可以实现便捷的大模型使用</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/S15-openai-style-model" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/15-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>16.异步流式模型调用</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/16.%E5%BC%82%E6%AD%A5%E6%B5%81%E5%BC%8F%E6%A8%A1%E5%9E%8B%E8%B0%83%E7%94%A8.html</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/16.%E5%BC%82%E6%AD%A5%E6%B5%81%E5%BC%8F%E6%A8%A1%E5%9E%8B%E8%B0%83%E7%94%A8.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">16.异步流式模型调用</source>
      <description>异步流式模型调用 前面介绍的教程中，更多的还是是同步调用，对于某些场景，同步调用可能无法满足，比如： 模型返回结果是流式数据，比如：图片生成、语音合成、视频生成等等； 模型返回结果是异步数据，比如：图片识别、语音识别、视频识别等等； 模型返回结果是分批次数据，比如：图片识别、语音识别、视频识别等等； 此外，同步调用需要等待LLM处理完，将所有的结果一并返回；因此对用户的体验并不友好，需要一直空等；因此通过流式的逐步返回，无疑是一个非常好的选择；接下来我们看一下SpringAI如何实现LLM的流式访问</description>
      <category>SpringAI</category>
      <pubDate>Thu, 11 Dec 2025 12:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 异步流式模型调用</h1>
<p>前面介绍的教程中，更多的还是是同步调用，对于某些场景，同步调用可能无法满足，比如：</p>
<ul>
<li>模型返回结果是流式数据，比如：图片生成、语音合成、视频生成等等；</li>
<li>模型返回结果是异步数据，比如：图片识别、语音识别、视频识别等等；</li>
<li>模型返回结果是分批次数据，比如：图片识别、语音识别、视频识别等等；</li>
</ul>
<p>此外，同步调用需要等待LLM处理完，将所有的结果一并返回；因此对用户的体验并不友好，需要一直空等；因此通过流式的逐步返回，无疑是一个非常好的选择；接下来我们看一下SpringAI如何实现LLM的流式访问</p>
<h2> 一、实例演示</h2>
<p>首先我们需要创建一个SpringAI的项目，基本流程同 <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 1. 初始化</h3>
<p>创建一个 <code>ChatController</code>，自动注入 ChatModel，并基于 <code>ChatModel</code> 实例化 <code>ChatClient</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. ChatModel流式访问</h3>
<p>对于ChatModel流式访问，与前面直接访问LLM的区别不大，只是将最后的 <code>call</code> 调用改成 <code>stream</code> 调用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过 stream() 方法调用，返回的是 <code>Flux&lt;ChatResponse&gt;</code>，我们定义返回头为 <code>text/event-stream</code>，这样客户端就可以接受流式的数据返回</p>
<figure><img src="/imgs/column/springai/16-1.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的截图中可以看到，返回的流式数据，每次返回一个 <code>ChatResponse</code> 对象，需要客户端从中解析 <code>output.text</code></p>
<h3> 3. ChatClient流式反问</h3>
<p>对于ChatClient的流式请求，同样是将发起请求的<code>call</code>调用改成<code>stream</code>调用</p>
<p>对于<code>ChatClient.stream()</code>后的结果调用，官方提供了三种方式</p>
<ol>
<li><code>stream().content()</code>: 返回 <code>Flux&lt;String&gt;</code></li>
<li><code>stream().chatClientResponse()</code>: 返回 <code>Flux&lt;ChatClientResponse&gt;</code></li>
<li><code>stream().chatResponse()</code>: 返回 <code>Flux&lt;ChatResponse&gt;</code></li>
</ol>
<p>下面我们使用最简单 <code>content()</code> 进行演示，只关注LLM的返回结果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/16-2.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 完整结果拼接</h3>
<p>对于某些场景，我们需要将流式数据拼接成完整结果然后再一次返回给客户端，即此时需要我们自己来解析 <code>Flux&lt;ChatReponse&gt;</code>，对于此，可以使用下面几种方式来实现</p>
<p>case1: 直接使用 <code>Flux.collectionList()</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>case2: 使用 <code>Flux.reduce()</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>case3: 使用 <code>subscribe() + SseEmitter</code> 实现更灵活的流式返回</p>
<p>这种方式依然是流式返回给调用方；但是借助SseEmitter，从而实现更灵活的定制化（如后台服务也希望使用LLM的返回结果，此时就可以在subscribe的逻辑中进行定制化开发）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 二、总结</h2>
<p>本文这里介绍了SpringAI通过stream的方式访问LLM的流式数据，从上面的实际体验来看，和同步访问相比，流式访问的体验更加友好，用户可以更早的看到结果，并且可以更灵活的定制化返回结果；但是从编码的角度出发，两者又没有太明显的区别，对于应用者而言，这一点可以说是非常友好了</p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/16-1.png" type="image/png"/>
    </item>
    <item>
      <title>17.推理大模型接入与推理过程返回</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/17.%E6%8E%A8%E7%90%86%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5%E4%B8%8E%E6%8E%A8%E7%90%86%E8%BF%87%E7%A8%8B%E8%BF%94%E5%9B%9E.html</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/17.%E6%8E%A8%E7%90%86%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%8E%A5%E5%85%A5%E4%B8%8E%E6%8E%A8%E7%90%86%E8%BF%87%E7%A8%8B%E8%BF%94%E5%9B%9E.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">17.推理大模型接入与推理过程返回</source>
      <description>17.推理大模型接入与推理过程返回 对于一些支持推理模型的LLM（如DeepSeekR1 带有推理解析器的vLLM），除了LLM的直接返回结果，推理结果往往也是一个非常有用的返回信息，对于SpringAI，我们可以通过从返回的 Metadata 中获取推理结果。 使用推理的前提是模型必须支持推理，我们可以使用阿里的 qwen-plus-latest 或者智谱的 glm-4.5-flash；这两个都是支持推理过程的模型。 一、实例演示 首先我们需要创建一个SpringAI的项目，基本流程同 创建一个SpringAI-Demo工程</description>
      <category>SpringAI</category>
      <pubDate>Thu, 11 Dec 2025 17:24:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 17.推理大模型接入与推理过程返回</h1>
<p>对于一些支持推理模型的LLM（如DeepSeekR1 带有推理解析器的vLLM），除了LLM的直接返回结果，推理结果往往也是一个非常有用的返回信息，对于SpringAI，我们可以通过从返回的 Metadata 中获取推理结果。</p>
<p>使用推理的前提是模型必须支持推理，我们可以使用阿里的 <code>qwen-plus-latest</code> 或者智谱的 <code>glm-4.5-flash</code>；这两个都是支持推理过程的模型。</p>
<h2> 一、实例演示</h2>
<p>首先我们需要创建一个SpringAI的项目，基本流程同 <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 1. 初始化</h3>
<p>我们借助OpenAI的接口风格来解析推理过程，因此需要引入对应的依赖：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后创建一个 <code>Controller</code> 用于测试</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现，我们基于 OpenAiApi 来创建 ChatModel，在创建创建ChatModel时，通过 <code>extraBody</code> 来传递额外参数，告诉大模型是否开启推理过程</p>
<p>但是请注意，这个推理是否开启的参数依然是取决于具体的模型提供商的要求</p>
<ul>
<li>阿里的百炼模型，推理参数为 <code>enable_thinking</code>，且必须显示传递 <code>.extraBody(Map.of("enable_thinking", true))</code></li>
<li>智谱的glm-4.5-flash模型，默认就是开启推理的，不需要额外传递参数；如果希望关闭，可以设置参数 <code>.extraBody(Map.of("thinking", Map.of("type", "disabled")))</code></li>
</ul>
<figure><img src="/imgs/column/springai/17-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 获取推理结果</h3>
<p>我们先使用同步调用智谱模型，看看表现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试一下，结果返现并没有推理过程；主要原因是推理过程需要是<code>stream()</code>方式调用，然后由用户在 <code>delta</code> 中进行获取</p>
<p>我们在改成 <code>.stream()</code> 方法来获取推理结果</p>
<p>获取推理结果的关键代码在： <code>generation.getOutput().getMetadata().get("reasoningContent");</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/17-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的结果也可以看出，对于推理过程，使用流式调用，然后再metadata中获取</p>
<p>上面是智谱的大模型；阿里百炼的模型，获取推理结果同样也是使用流式调用，区别在于，若开启了推理过程，那么必须使用流式调用；否则，会报错</p>
<h2> 二、小结</h2>
<p>本文介绍了如何与支持推理的LLM进行交互，并获取推理过程；从使用层面来看并没有太多的差异，只是需要注意</p>
<ol>
<li>推理过程需要使用流式调用</li>
<li>根据模型的传参定义，判断是否需要主动设置参数，以开启推理过程</li>
<li>从返回的<code>metadata</code>中，获取 <code>reasoningContent</code> 来获取推理过程</li>
</ol>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/17-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>基础篇</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">基础篇</source>
      <description>主要介绍SpringAI的基础使用，对应的项目工程以 Sxx- 开头，通过这些实例，您将掌握SpringAI的基础知识（如提示词、上下文、架构化输出、tool calling, MCP, advise, ChatClient, 多模型等），并开始使用SpringAI进行大模型应用开发</description>
      <pubDate>Thu, 22 Jan 2026 08:45:40 GMT</pubDate>
      <content:encoded><![CDATA[<p>主要介绍SpringAI的基础使用，对应的项目工程以 <code>Sxx-</code> 开头，通过这些实例，您将掌握SpringAI的基础知识（如提示词、上下文、架构化输出、tool calling, MCP, advise, ChatClient, 多模型等），并开始使用SpringAI进行大模型应用开发</p>
]]></content:encoded>
    </item>
    <item>
      <title>01.从0到1创建一个基于天气的旅游美食推荐智能体</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E5%BA%94%E7%94%A8%E7%AF%87/D01.%E4%BB%8E0%E5%88%B01%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8E%E5%A4%A9%E6%B0%94%E7%9A%84%E6%97%85%E6%B8%B8%E7%BE%8E%E9%A3%9F%E6%8E%A8%E8%8D%90%E6%99%BA%E8%83%BD%E4%BD%93.html</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E5%BA%94%E7%94%A8%E7%AF%87/D01.%E4%BB%8E0%E5%88%B01%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8E%E5%A4%A9%E6%B0%94%E7%9A%84%E6%97%85%E6%B8%B8%E7%BE%8E%E9%A3%9F%E6%8E%A8%E8%8D%90%E6%99%BA%E8%83%BD%E4%BD%93.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">01.从0到1创建一个基于天气的旅游美食推荐智能体</source>
      <description>01.从0到1创建一个基于天气的旅游美食推荐智能体 本文将演示如何借助LangGraph4j + SpringAI来开发一个完整的智能体应用，实现用户传入地址、大模型通过Function Calling来获取地址天气，调用大模型的旅游项目推荐能力、美食推荐能力，给用返回一个旅游攻略 一、项目创建 1. 工程创建 首先我们需要创建一个 LangGraph4j + SpringAI的项目，对这块不熟悉的小伙伴，请参考 创建一个Langgraph4j示例工程</description>
      <category>SpringAI</category>
      <pubDate>Wed, 13 Aug 2025 10:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 01.从0到1创建一个基于天气的旅游美食推荐智能体</h1>
<p>本文将演示如何借助LangGraph4j + SpringAI来开发一个完整的智能体应用，实现用户传入地址、大模型通过Function Calling来获取地址天气，调用大模型的旅游项目推荐能力、美食推荐能力，给用返回一个旅游攻略</p>
<h2> 一、项目创建</h2>
<h3> 1. 工程创建</h3>
<p>首先我们需要创建一个 LangGraph4j + SpringAI的项目，对这块不熟悉的小伙伴，请参考 <a href="../%E5%9F%BA%E7%A1%80%E7%AF%87/14.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AALanggraph4j%E5%AE%9E%E4%BE%8B%E5%B7%A5%E7%A8%8B">创建一个Langgraph4j示例工程</a></p>
<h3> 2. 核心依赖</h3>
<p>本工程主要使用框架为 <code>SpringAI1.0.1</code> + <code>LangGraph4j1.6.0-rc4</code> + <code>SpringBoot3.5.4</code></p>
<p>对应的大模型为： <code>zhipu</code>，通过SpringMVC提供访问接口</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 配置文件</h3>
<p>我们在配置文件<code>application.yml</code>中配置大模型密钥，使用其他大模型的小伙伴，请自行替换</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：大模型的选择时，需要判断是否支持FunctionCalling，如果不支持，则会影响本项目的实际运行效果</p>
<p>我们的密钥以启动参数的方式传递，方便测试（当然也可以直接写入配置文件、或者系统环境变量，大家按照自己的喜好即可）</p>
<h2> 二、智能体开发</h2>
<h3> 1. 核心功能描述</h3>
<p>智能体的主要功能为：</p>
<ol>
<li>用户传入地址</li>
<li>设计一个WeatherAgent，用于获取给定地方的实时天气情况</li>
<li>若不需要进行旅游推荐，则直接返回</li>
<li>若需要进行旅游推荐
<ul>
<li>调用 TravelAgent，获取给定地址的附近旅游项目推荐</li>
<li>根据选定的旅游项目，调用 FoodAgent，获取给定地址的附近美食推荐</li>
</ul>
</li>
<li>将上面的结果进行整合，以博文的方式返回给用户</li>
</ol>
<figure><img src="/imgs/column/springai/D01-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 实现通用的AgentService</h3>
<p>上面的几个Agent都需要与大模型进行交互，因此我们这里可以抽象出一个通用的AgentService，用于处理Agent与大模型的交互</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为大模型本身是无法获取天气信息的，因此我们这里使用FunctionCalling的方式，给大家装配上天气查询的能力（当然这里也可以直接使用天气相关的McpServer）</p>
<p>我们这里简单的实现一个 WeatherTools 来模拟天气的查询（真实场景中，可以实现第三方天气服务查询API）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 定义TravelState存储上下文</h3>
<p>我们这里定义一个 <code>TravelState</code> 继承自 <code>AgentState</code> 来实现多智能体之间的数据共享，由于我们这里存在4个智能体，我们为每个智能体的返回都定义一个对应的参数进行承接</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面定义了五个常量，其中 <code>INPUT</code> 为最开始的输入参数， <code>WEATHER</code> 为 WeatherAgent执行后的返回的天气信息， <code>TRAVEL</code> 为 TravelRecommendAgent 执行后返回推荐游玩项目， <code>FOOD</code> 为 FoodRecommendAgent 执行后返回推荐美食， <code>BLOG</code> 为 XhsBlogGenerateAgent 执行后汇总生成的小红书风格的博文内容</p>
<p>不同的Agent返回的数据内容并不相同，可以是基本类型、字符串，也可以是集合、Java POJO对象，由于<code>LangGraphJ</code>自己实现了一套序列化协议，因此我们这里先提供一个JsonSerializer，用于非简单的对象的序列化处理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 实现天气智能体 WeatherAgent</h3>
<p>接下来我们实现第一个智能体，用于获取给定地方的天气</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的整体实现比较简单，核心的在于方法 <code>callWeatherAgent</code>，我们会将它包装为<code>LangGraph4J</code>的Node，这个方法你可以理解为 <code>NodeAction</code> 的实现，对应的使用层Node的注册如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>同样的，我们可以在 <code>TravelState</code> 中，提供一个直接获取天气的方法，返回的类型为String字符串</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 实现推荐项目智能体 TravelRecommendAgent</h3>
<p>接下来我们实现第二个智能体，用于推荐给定地点的游玩项目，具体的实现方式可以参照上面天气智能体的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在旅游项目推荐的实现中，使用了前面返回的天气信息，作为提示词的输入，将大模型的返回结果保存到State中给后续的节点使用；同样的，我们可以在 <code>TravelState</code> 中，提供获取推荐项目的方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 实现美食智能体 FoodAgent</h3>
<p>接下来我们实现第三个智能体，基于旅游项目的美食推荐（如果条件允许，当然是推荐借助百度/高德地图的MCPServer来实现），具体的实现方式可以参照上面天气智能体的实现</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个实现，相比于前面的旅游项目Agent的实现会更复杂一点，利用了前面返回的天气和旅游项目，借助了SpringAI的提示词模板 + 结构化输出来实现美食推荐，我们可以在 <code>TravelState</code> 中，提供获取美食推荐列表的方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7. 实现小红书博文智能体 XhsBlogGenerateAgent</h3>
<p>最后我们实现第四个智能体，基于美食推荐，生成小红书的博文；我们这里做一个分支处理，如果是直接由WeatherAgent转过来的，那么我们作为一个天气预报的Agent；如果是由FoodAgent转过来的，那么我们作为一个小红书的旅游美食推荐Agent</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两个不同的分支，返回的内容稍有区别，定义如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样的，我们可以在 <code>TravelState</code> 中，提供获取最终博文数据的方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8. TravelState序列化</h3>
<p>当上面四个智能体实现完毕之后，<code>TravelState</code>中存储的上下文也都可以确定了，接下来我们定义它的序列化方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 9. 实现多智能体调用的 AgentExecutor</h3>
<p>上面的智能体实现之后，我们接下来需要实现 <code>AgentExecutor</code>，在这里定义<code>StateGraph</code>，执行多智能体的调用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的核心在与<code>GraphBuilder.build()</code>的实现，在这个实现中，定义了AgentState、Node、Edge、ConditionEdge，通过他们构建了一个有向图，我们可以通过下面这个方法打印下这个多智能体执行的PantUML</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-plantuml line-numbers-mode" data-ext="plantuml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/D01-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 10. 测试验证</h3>
<p>接下来我们实现一个端点，用于用户的推荐交互</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>小红书生成风格博文生成（传参中包含推荐二字）:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/D01-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>天气预报的信息生成（传参中不包含推荐二字）</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/D01-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 三、小结</h2>
<p>本文通过逐步拆解的方式，给大家演示了如何借助 <code>SpringAI</code> + <code>LangGraphJ</code> + <code>智普大模型</code> 从0到1创建一个多智能体应用，虽然现在的效果还一般，这个主要还是我的提示词和响应还不够优雅，整个业务的流程还是完整流畅的。有兴趣的小伙伴也可以实际的体验一下</p>
<p>上文虽然实现步骤相对清晰，但是内中原理和知识点，还是比较多的，对于上面实现的步骤有疑问的小伙伴，可以仔细阅读一下我的 <a href="https://hhui.top/tutorial/spring/springai/" target="_blank" rel="noopener noreferrer">SpringAI系列博文</a> 相信能解决你的大部分疑问</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/app-projects/D01-travel-recommend-agent" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/D01-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>D02.从0到1实现一个自然语言提取地址信息的智能体</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E5%BA%94%E7%94%A8%E7%AF%87/D02.%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E6%8F%90%E5%8F%96%E5%9C%B0%E5%9D%80%E4%BF%A1%E6%81%AF%E7%9A%84%E6%99%BA%E8%83%BD%E4%BD%93.html</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E5%BA%94%E7%94%A8%E7%AF%87/D02.%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E6%8F%90%E5%8F%96%E5%9C%B0%E5%9D%80%E4%BF%A1%E6%81%AF%E7%9A%84%E6%99%BA%E8%83%BD%E4%BD%93.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">D02.从0到1实现一个自然语言提取地址信息的智能体</source>
      <description>大概两年之前，我们有一个快递类型的业务场景，为了简化用户的操作，为用户提供了一个快捷功能，支持用户直接粘贴一段自然语言的文本，然后由程序后台基于这段文本自动提取出结构化的地址信息，在方式大模型还未普及，我们使用的是baidu的一个收费接口 虽然价格不贵，但总归也是收费不是；这个场景非常垂直聚焦，正好也可以作为我们应用集成LLM的一个实验田。接下来我将介绍下如何利用 Spring AI 框架结合大模型能力，实现从自然语言文本中自动提取结构化地址信息的完整方案，并且通过function call实时查询行政编码，从而打造一个完整可直接商用的 “地址提取智能体”</description>
      <category>SpringAI</category>
      <pubDate>Wed, 14 Jan 2026 10:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>大概两年之前，我们有一个快递类型的业务场景，为了简化用户的操作，为用户提供了一个快捷功能，支持用户直接粘贴一段自然语言的文本，然后由程序后台基于这段文本自动提取出结构化的地址信息，在方式大模型还未普及，我们使用的是baidu的一个收费接口</p>
<figure><img src="/imgs/column/springai/D02-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>虽然价格不贵，但总归也是收费不是；这个场景非常垂直聚焦，正好也可以作为我们应用集成LLM的一个实验田。接下来我将介绍下如何利用 Spring AI 框架结合大模型能力，实现从自然语言文本中自动提取结构化地址信息的完整方案，并且通过function call实时查询行政编码，从而打造一个完整可直接商用的 <code>“地址提取智能体”</code></p>
<h2> 一、整体架构设计</h2>
<h3> 1.1 技术栈选型</h3>
<ul>
<li><strong>SpringAI 1.1.2</strong>：统一AI调用框架</li>
<li><strong>ZhiPu</strong>：使用它的免费版大模型 <code>GLM-4-Flash</code></li>
<li><strong>Function Calling</strong>：让大模型具备调用外部API的能力</li>
<li><strong>SpringBoot 3.x</strong>：现代化Java框架</li>
<li><strong>JDK17+</strong>: java版本最低要求17</li>
<li><strong>行政区划编码库</strong>：<a href="https://github.com/modood/Administrative-divisions-of-China" target="_blank" rel="noopener noreferrer">Administrative-divisions-of-China</a></li>
</ul>
<h3> 1.2 系统架构</h3>
<p>从整体的视角来看，这个地址信息的提取结构相对清晰，基于用户输入的自然语言、通过LLM获取结构化的地址信息，然后返回给用户；</p>
<p>结合应用程序对地址的使用策略，我们在基本中文地址提取之外，通过Function Calling机制，实现让大模型返回的结构化信息中，包含行政区域代码，这样更方便将大模型返回的地址信息与项目中自己维护的地址信息进行映射；</p>
<blockquote>
<p>说明：返回行政区域编码，主要是为了避免出现 本地地址库中存 <code>湖北省、武汉市</code>，但是大模型返回的是 <code>湖北、武汉</code> 这类文本，导致后台程序无法精确根据地址文本进行映射的场景；通过统一的行政区域编码，则可以有效规避这种场景</p>
</blockquote>
<p>下面是整体的结构图</p>
<figure><img src="/imgs/column/springai/D02-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<div class="language-Mermaid line-numbers-mode" data-ext="Mermaid"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 二、核心实现步骤</h2>
<p>首先我们需要搭建要给SpringAI的项目，不太熟悉的小伙伴可以参照 <a href="https://hhui.top/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="_blank" rel="noopener noreferrer">01.创建一个SpringAI的示例工程 | 一灰灰的站点</a> 来完成</p>
<p>在下面的实现过程中，我们使用智谱的免费大模型作为我们的实际载体；若希望使用其他的模型的小伙伴，也可以直接替换（SpringAI对不同厂商的大模型集成得相当可以，切换成本较低）</p>
<h3> 2.1 环境配置与依赖</h3>
<p>我们使用的SpringAI的版本为最新的 <code>1.1.2</code> ，此外直接使用 zhipu 的starter来作为大模型的交互客户端</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在配置文件中，设置对应的配置信息，其中关键点为</p>
<ul>
<li>api-key: 可以通过启动参数、系统环境变量等方式注入key，从而避免硬编码导致的泄露问题</li>
<li>model: 选择的是免费的 <code>GLM-4-Flash</code>， 支持 <code>function call</code> （说明：若你选中的模型不支持函数调用，那么就无法实现后续的行政区域查询的工具注入）</li>
</ul>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.2 地址数据结构设计</h3>
<p>首先定义一下我们希望接受的结构化返回数据，以常见的快递物流的地址信息为例，关键信息包含：</p>
<ul>
<li>省</li>
<li>市</li>
<li>区</li>
<li>街道</li>
<li>详细地址</li>
<li>用户</li>
<li>手机号</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.3 快速原型实现</h3>
<p>接下来我们看一下直接使用大模型本身的文本提取能力，快速实现一个基础的原型</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的实现中，我们直接使用 <code>ChatModel</code> 进行大模型的交互，在这不到10行的代码中，主要使用到两个技术点</p>
<ul>
<li>提示词模板： PromptTemplate 实现占位替换</li>
<li>结果化返回： 通过<code>BeanOutputConverter</code>实现bean对象转json schema，然后通过提示词工程约束大模型返回；同时也通过Converter实现返回结果转Bean对象</li>
</ul>
<p>接下来看一下试验效果</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/D02-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的实际表现也可以看出，有两个明显的问题</p>
<ul>
<li>行政区域编码返回的不一定准确：如上面的 <code>长春市朝阳区</code> 的行政区域编码返回就不对</li>
<li>详细地址提取不一定准确：上图中广州市的这个地址，两次请求的返回不一样，且结果不完整</li>
</ul>
<p>从这个快速原型我们也可以看出，基于大模型做地址识别方向可行，但是还需要“调教” ———— 即需要有一个更稳定、高质量输出的提示词设计</p>
<h3> 2.4 Prompt工程：引导模型输出的准确的结果</h3>
<p>上面demo中的提示词过于简略，因此我们需要设计一个更符合工程化的提示词（有兴趣的小伙伴可以查看 <a href="https://mp.weixin.qq.com/s/ZQbztqBq7_PzynG06N4-mg" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程： 第五章 从 Prompt 到 Prompt 模板与工程治理</a> 看看如何设计更推荐的提示词）</p>
<p>由于这个场景的目标非常清晰，所以对应的设计可以从下面几个出发</p>
<ul>
<li>角色：地址信息提取专家</li>
<li>约束：一些地址相关的提取规则</li>
<li>结构化：返回的定义</li>
<li>少样本学习：提供示例，用于少样本学习</li>
</ul>
<p>然后在上面的基础上，我们改造一下具体的实现策略</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个实现中，我们直接提取了一个提示词模板 <code>SYSTEM_PROMPT</code> （虽然上面的代码是直接硬编码的方式写成的，但是更推荐的是使用更专业的提示词管理服务来维护、比如支持版本、灰度对比等）</p>
<p>其次就是具体的LLM交互中，我们使用 <code>ChatClient</code> 替换了更原生的 <code>ChatModel</code>，因为它对系统提示词、结构化返回从使用角度封装得更友好，使用起来更简单；从代码量也可以看出，三行就完前面同等的调用过程</p>
<p>同样的我们来看看具体表现，依然使用前面的测试文本</p>
<figure><img src="/imgs/column/springai/D02-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的结果来看，广州市这个文本的详细地址解析就稳定可靠多了；但是吉林这个地址行政区域编码错误的问题依旧，显然提示词本身是无法纠正大模型的错误资料库的</p>
<p>所以接下来我们就需要给大模型安上“作弊器”，让它有能力查询到正确的行政区域编码</p>
<h3> 2.5 Function Call实现：行政区划编码查询</h3>
<p>虽然有一些API提供了行政区域编码（比如高德），但是为了减少外部依赖（当然也是为了白嫖），我们选择使用标准的行政编码库来提供自己的查询服务</p>
<p>首先是从开源项目中获取数据集：<a href="https://github.com/modood/Administrative-divisions-of-China" target="_blank" rel="noopener noreferrer">https://github.com/modood/Administrative-divisions-of-China</a></p>
<blockquote>
<p>为了准确性，我们选择的是 <code>pca-code.json</code> 这个包含 省、市、区 三级联动的数据库（因为街道的变动频率相比较于这三级高太多了...）</p>
</blockquote>
<p>这个字典的数据模型形如</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此我们可以实现一个简单基于内存的行政区域查询服务</p>
<ul>
<li>读取字典、映射为结构化数据</li>
<li>解析为Map格式，方便快速查找</li>
</ul>
<p>下面就是一个基础的初始化实现过程（阅读起来有困难的小伙伴不妨结合AICoding解释一下）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>让后就是提供查询服务，并通过SpringAI 的 <code>@Tool</code> 注解来声明为大模型的回调工具</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.6 完全体智能地址提取</h3>
<p>上面虽然实现了行政区域查询服务，但是还需要把它提供给大模型使用，这一步我们需要怎么做呢？</p>
<p>看下面的实现，你会发现这个改动非常简单，只需两步：</p>
<ul>
<li>调整提示词约束：要求大模型必须通过提供的工具来获取行政区域编码</li>
<li>注册工具</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次试验一下实际表现</p>
<figure><img src="/imgs/column/springai/D02-5.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2.7 整体流程</h3>
<p>接下来我们从整体的视角回归一下这个智能地址提取的全流程，其中相关的技术点为</p>
<ul>
<li>提示词工程</li>
<li>结构化返回</li>
<li>Function Call工具调用</li>
</ul>
<figure><img src="/imgs/column/springai/D02-6.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<div class="language-Mermaid line-numbers-mode" data-ext="Mermaid"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 三、生产优化及部署</h2>
<h3> 3.1 调参：稳定性输出</h3>
<p>在实际的生产体验过程中，我们大概率会发现，同样一段自然语言，大模型提取的详细地址这块，可能并不总是相同的，why?</p>
<p>对于省市区这三个相对来说比较固定的地址信息，对于街道门牌号的可能性实在是太多，大模型中有一个参数 <code>temperature</code> 它会控制大模型预测结果的倾向，对此有兴趣的小伙伴可以参照 <a href="https://mp.weixin.qq.com/s/t_BuAW9i0npcaJdua3Am2Q" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第二章 模型不是重点，参数才是你真正的控制面板</a></p>
<p>在我们这个场景下，很明显不希望大模型自由发挥，所以我们可以将<code>temperature</code>设置较低，确保输出结果稳定</p>
<p>我们需要修改的就是配置文件中的<code>spring.ai.zhipuai.chat.options.temperature</code>，如下</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.2 Docker容器化部署</h3>
<div class="language-docker line-numbers-mode" data-ext="docker"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.3 Kubernetes部署配置</h3>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 四、小结</h2>
<h3> 4.1 智能体 or NO?</h3>
<p>从上到下顺下来，我们的智能地址提取基本已经完成，从本质上来说，这是一个大模型的能力包装服务，那么它算“智能体”吗？</p>
<p>好像也不太算<sub>，哪个智能体这么简单呢</sub>🤣</p>
<p>但若从下面这些角度出发，它又算是一个非常垂直的工具增强型智能体：</p>
<ol>
<li><strong>目标导向</strong>：用户输入的是<strong>自然语言目标</strong>——“从这段文字里提取地址并查清楚它的行政区划编码”，而不是“先调用NLP模型解析，再用结果里的省市去查XX API”。</li>
<li><strong>自主规划与推理</strong>：系统内部自动完成了规划：① 识别出这是地址提取任务 -&gt; ② 调用LLM进行结构化解析 -&gt; ③ 判断是否需要并请求行政编码 -&gt; ④ 调用外部函数获取编码 -&gt; ⑤ 整合结果。<strong>这个决策链条是智能体自主生成的</strong>。</li>
<li><strong>核心工具使用</strong>：其核心能力 <code>Function Calling</code> 正是智能体的标志性特征。LLM作为“大脑”，决定使用 <code>queryAdCode</code> 这个“工具”（手或脚）。</li>
<li><strong>可扩展的交互与记忆</strong>：虽然当前版本可能是单次查询，但它很容易扩展为多轮对话。例如，用户说“地址不对，我指的是杭州的西湖区”，智能体可以记住上下文，重新查询。</li>
</ol>
<p><strong>对比一个非智能体的传统方案：</strong></p>
<p>一个传统的地址解析服务可能提供一个复杂的API表单，要求用户自己先分词，然后分别填写<code>province</code>、<code>city</code>、<code>district</code>等字段来查询编码。</p>
<p>用户承担了所有的规划和推理工作；而这个智能地址提取，就很“智能”了</p>
<h3> 4.2 特点</h3>
<p>最后针对本文的内容，整体小结一下：通过本文介绍的方案，我们构建了一个端到端的智能地址解析系统，具备以下特点：</p>
<ol>
<li><strong>自然语言理解</strong>：利用大模型处理各种自由格式的地址输入</li>
<li><strong>提示词模板</strong>：通过构建结构化的提示词管理，提高大模型的返回质量</li>
<li><strong>结构化输出</strong>：确保输出符合标准化要求</li>
<li><strong>实时编码查询</strong>：通过function call动态获取行政区域编码</li>
</ol>
<h3> 4.3 未来扩展方向：</h3>
<ol>
<li><strong>多模型支持</strong>：集成本地化大模型降低API成本</li>
<li><strong>地址补全与纠错</strong>：对不完整或错误地址进行智能修正</li>
<li><strong>国际化支持</strong>：处理多语言地址解析</li>
<li><strong>GIS集成</strong>：结合地理信息系统提供坐标映射</li>
<li><strong>实时更新</strong>：自动同步最新的行政区划变更</li>
</ol>
<p>通过一个简单的场景，不到200行代码，实现一个“地址提取智能体”，给大家提供一个关于大模型应用开发的案例；当然本篇内容也是作为理论科普系列教程的实战篇，强烈建议对大模型应用开发感兴趣的小伙伴，看看以下几篇内容（每篇耗时不超过五分钟😊）</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/qCn8x2XO2shA8MheYbHq0w" target="_blank" rel="noopener noreferrer">LLM 应用开发是什么：零基础也可以读懂的科普文(极简版)</a></li>
<li><a href="https://mp.weixin.qq.com/s/2GXBNOUq3jlysipftz8TpA" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：序-为什么你“会用 LLM”，但做不出复杂应用？</a></li>
<li><a href="https://mp.weixin.qq.com/s/v-z6EHY300ElOxdGPdzc0w" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第一章LLM到底在做什么？</a></li>
<li><a href="https://mp.weixin.qq.com/s/t_BuAW9i0npcaJdua3Am2Q" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第二章 模型不是重点，参数才是你真正的控制面板</a></li>
<li><a href="https://mp.weixin.qq.com/s/vzt0bGwcfnASOiBa0Kc7VQ" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第三章 为什么我的Prompt表现很糟？</a></li>
<li><a href="https://mp.weixin.qq.com/s/Nk-N34TLJVCTI5F4k5rGaQ" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第四章Prompt 的工程化结构设计</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZQbztqBq7_PzynG06N4-mg" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第五章 从 Prompt 到 Prompt 模板与工程治理</a></li>
<li><a href="https://mp.weixin.qq.com/s/nnKspRO87xbrn4-LBV3RNA" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第六章 上下文窗口的真实边界</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/D02-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>D03.从0到1实现一个发票信息提取智能体</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E5%BA%94%E7%94%A8%E7%AF%87/D03.%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%91%E7%A5%A8%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96%E6%99%BA%E8%83%BD%E4%BD%93.html</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E5%BA%94%E7%94%A8%E7%AF%87/D03.%E4%BB%8E0%E5%88%B01%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%91%E7%A5%A8%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96%E6%99%BA%E8%83%BD%E4%BD%93.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">D03.从0到1实现一个发票信息提取智能体</source>
      <description>发票的OCR识别对于现今而言，可以说比较成熟了；今天我们来从0到1实现一个基于大模型的发票提取智能体，也基于此看看大模型开发和传统的开发之间，有什么区别 再见，OCR模板！你好，发票智能体：基于SpringAI与大模型的零配置发票智能提取架构 一、系统架构设计 1.1 设计目标</description>
      <category>SpringAI</category>
      <pubDate>Thu, 15 Jan 2026 17:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>发票的OCR识别对于现今而言，可以说比较成熟了；今天我们来从0到1实现一个基于大模型的发票提取智能体，也基于此看看大模型开发和传统的开发之间，有什么区别</p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/SnXdTB6tYqAzG7HgbnTSAQ" target="_blank" rel="noopener noreferrer">再见，OCR模板！你好，发票智能体：基于SpringAI与大模型的零配置发票智能提取架构</a></p>
</blockquote>
<h2> 一、系统架构设计</h2>
<h3> 1.1 设计目标</h3>
<p>大模型发票信息提取方案，主要基于SpringAI+多模态大模型，实现零配置、高泛化、端到端的发票智能提取系统，核心优势：</p>
<ul>
<li>无需模板：直接理解任意版式发票</li>
<li>语义理解：理解发票内容而非单纯OCR</li>
<li>结构化输出：直接生成可入库的数据结构</li>
</ul>
<h3> 1.2 系统整体架构</h3>
<p>对应的系统架构设计如下</p>
<figure><img src="/imgs/column/springai/D03-01.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从整体的分层结构来看，一个完整的发票提取包含：</p>
<ul>
<li>接入层：负责接收外部请求、做初步流量治理
<ul>
<li>定位：可以理解为全局网关，承接外部流量并过滤非法请求</li>
</ul>
</li>
<li>应用层：做发票的多模态解析（比如识别票据图片、解析文本） + 数据标准化（统一发票信息的格式）；
<ul>
<li>定位： “业务中枢”，串联下游服务、实现发票提取的核心流程</li>
</ul>
</li>
<li>服务层：把具体技术能力封装为独立服务，供应用层调用
<ul>
<li>定位：能力组件库，解耦业务逻辑与技术实现。</li>
</ul>
</li>
<li>存储层：按数据特性分两类存储：缓存存储（Redis）存高频访问的发票信息，提升查询效率  + 持久化存储（PostgreSQL）存全量发票数据，做长期归档。
<ul>
<li>定位：数据仓库，保障数据的高效访问与长期留存。</li>
</ul>
</li>
<li>运维层：监控与审计
<ul>
<li>定位：运维保障，确保全流程可观测、问题可追溯</li>
</ul>
</li>
</ul>
<h3> 1.3 业务流程</h3>
<p>基于上面的系统架构，我们可以串一下发票信息提取的全流程</p>
<ul>
<li>用户上传发票</li>
<li>后端应用接受请求，做一些基本过滤</li>
<li>应用层处理发票识别逻辑</li>
<li>服务层与大模型交互，提取识别结果，并存储相关的数据</li>
</ul>
<figure><img src="/imgs/column/springai/D03-02.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 二、数据结构设计</h2>
<p>一个完整的应用实现应该包含我们上面提到的六层结构；当然由于篇幅有限，我们这里则只抓重点，主要关注下大模型这一层的交互实现上；对于持久化、运维监控这块就一笔带过</p>
<h3> 2.1 发票核心数据模型</h3>
<p>发票本身的类型较多，不同的发票对应的信息也不太一样，这块的专业性有一点高；如果不太熟悉这块业务背景的小伙伴，直接对照发票来验证即可，比如下面这是一张从baidu上找到的专票</p>
<figure><img src="https://5b0988e595225.cdn.sohucs.com/images/20191017/c0cf274fec0141439a636ab0c353752a.jpeg" alt="来源于百度" tabindex="0" loading="lazy"><figcaption>来源于百度</figcaption></figure>
<p>从这个票面信息，我们可以定义销售方、购买方信息(核心是名称 + 纳税人识别号)</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>发票行信息（即商品、服务名称）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的发票信息</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.2 请求响应模型</h3>
<p>如果我们希望提供一个功能齐全的发票提取服务，那么有必要好好设计一下提供REST API（最好是基于真实的业务诉求来设计），我们先做一个非常基础简单的能力提供</p>
<p>上传方式：</p>
<ul>
<li>传发票文件</li>
<li>传base64图格式放票</li>
<li>传http格式发票</li>
<li>指定是否需要解析发票的商品行</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的返回比较常见了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 三、项目搭建</h2>
<p>首先我们需要搭建要给SpringAI的项目，不太熟悉的小伙伴可以参照 <a href="https://hhui.top/tutorial/spring/springai/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="_blank" rel="noopener noreferrer">01.创建一个SpringAI的示例工程 | 一灰灰的站点</a> 来完成</p>
<p>在下面的实现过程中，我们使用智谱的免费大模型作为我们的实际载体；若希望使用其他的模型的小伙伴，也可以直接替换（SpringAI对不同厂商的大模型集成得相当可以，切换成本较低）</p>
<h3> 3.1 基础环境</h3>
<p>我们使用的SpringAI的版本为最新的 <code>1.1.2</code> ，此外直接使用 zhipu 的starter来作为大模型的交互客户端</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在配置文件中，设置对应的配置信息，其中关键点为</p>
<ul>
<li>api-key: 可以通过启动参数、系统环境变量等方式注入key，从而避免硬编码导致的泄露问题</li>
<li>model: 选择的是免费的 <code>GLM-4.1V-Thinking-Flash</code>， 支持图片识别（相比较于 <code>GLM-4V-Flash</code> 上下文窗口更大，但是响应也更慢）</li>
<li>temperature: 0.1 低温度，保证提取的稳定性</li>
</ul>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.2 可选的发票提取工具页</h3>
<p>为了更好的进行交互体验，我们实现一个网页交互页面，用于上传发票、查看返回结果，直接基于 thymleaf 来实现</p>
<p>因此添加依赖 <code>spring-boot-starter-thymeleaf</code></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果本地开发，需要修改前端页面的小伙伴，可以考虑关闭缓存 （可选配置）</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 四、核心实现代码</h2>
<h3> 4.1 提示词管理</h3>
<p>首先我们需要制定大模型来提取结构化发票的提示词，区别于 <a href="https://mp.weixin.qq.com/s/96rHyp_gBUgmA2dhSbzNww" target="_blank" rel="noopener noreferrer">大模型应用开发实战：两百行实现一个自然语言地址提取智能体</a> 中的硬编码实现方式，我们将提示词统一放在资源目录下 <code>resources/prompt</code> 命名为 <code>xxx.pt</code>的文本中保存提示词模板</p>
<p>一个可用于大模型提取发票的提示词如下</p>
<div class="language-pt line-numbers-mode" data-ext="pt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.2 提示词注入</h3>
<p>然后在应用中，对应的提示词可以直接使用 <code>@Value</code> 注解进行注入，如提取服务的初始化</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.3 基于大模型的发票信息提取</h3>
<p>接下来就是核心的借助SpringAI实现大模型的交互，基于多模态的交互方案，传入系统提示词、用户消息+图片，定义结果化返回，以此来获取响应结果</p>
<blockquote>
<p>不到十行的代码，就可以实现提取逻辑（属实是有点夸张了啊~）</p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.4 验证接口</h3>
<p>接下来为了快速验证效果，我们可以整一个简单的验证接口，接收上传的发票，返回提取结果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后让AI帮我生成一个交互的前端页面， <code>invoice_extraction.html</code>，放在 <code>resources/template</code> 目录下</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际体验如下</p>
<figure><img src="/imgs/column/springai/D03-03.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>到这里，发票提取的核心服务层已基本满足要求，关于存储层的缓存和持久化，相对来说属于常见的后端实现技术栈，就不详细展开了； 那么这个实现是否可以直接应用于生产使用呢？</p>
<p>接下来我们看看若用于生产，还需要做哪些优化</p>
<h2> 五、生产优化</h2>
<h3> 5.1 发票行数据超过大模型上下文窗口</h3>
<h4> 5.1.1 问题描述</h4>
<p>发票上的基本票面信息数据量还算可控，但是开票行（即商品、服务明细）这里可能就非常多了，比如我一单买了五六十个商品、而这些商品全部放在一张发票上，当我们提取发票信息时，会发现大模型无法返回完整的数据结构（超出内容被截断了————即便我的提示词明确要求了，不要截断也没有效果）</p>
<p>如使用<code>GLM-4V-Flash</code> 对一张有十个开票行的发票进行提取时：</p>
<figure><img src="/imgs/column/springai/D03-04.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面的示例输出中，从大模型的返回也可以看出，返回结果被截断了，导致返回的是一个不完整的数据结构，因此在结构化为java bean对象时，就报错了</p>
<p>那么怎么解决呢？</p>
<blockquote>
<p>换上下文窗口更大的模型，比如 <code>GLM-4.1V-Thinking-Flash</code> ?</p>
</blockquote>
<p>这当然是一个解决方案，但是并不彻底，因为大模型的上下文窗口是有限的，但是发票行却是不固定的；简单来说，我没法保证，换一个模型之后，就不会再出现返回结果被截断的情况了</p>
<p>那么有没有更彻底的解决方案呢？</p>
<blockquote>
<p>分区域、分页提取</p>
</blockquote>
<p>怎么理解这个解决方案呢？</p>
<p>我们可以套用一下传统的开发模式，当一次返回的数据太多时，我们很容易想到的解决方法时将一次的返回</p>
<ul>
<li>改为分页返回，一次返回20条，若你需要再返回后20条 ———— 这种适用于列表的返回方式</li>
</ul>
<p>参照这种思路，那么我们可以先定大模型，不要一次提取所有的开票行信息，而是按照我给他要求的进行分页提取；开票行的信息改成分页提取之后，但是其他的票面信息实际上只需要提取一次，因此我们可以将一次的提取过程，改为</p>
<ul>
<li>只提取票面信息</li>
<li>分页提取开票行信息</li>
</ul>
<h4> 5.1.2 票面基本信息提取</h4>
<p>按照这种方式，我们可以重新设计两个提示词，只提取开票信息的提示词 <code>prompts/invoice-basic-extract.st</code></p>
<div class="language-tl line-numbers-mode" data-ext="tl"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的实现逻辑也比较简单了，因为我们返回不要开票行，所以我们可以将前面定义的数据结构 <code>InvoiceInfo</code> 进行改造，向上提取一层<code>BaseInvoiceInfo</code>基础类，相比于之前的实现，这个基础类中，不包含<code>List&lt;InvoiceItem&gt; items</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后参照上面的发票提取方案，实现对应的发票基本信息提取核心逻辑</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 5.1.3 分页提取发票行</h4>
<p>分页提取开票行的提示词 <code>prompts/invoice-items-extract.st</code></p>
<div class="language-tl line-numbers-mode" data-ext="tl"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>注意上面的提示词，因为返回提示词模板中，提供了<code>json</code>示例，如果此时我们依然使用默认的 <code>{}</code> 来表示模板变量，就会导致解析异常 (SpringAI的提示词模板解析器会将json样例中{}也认为需要进行变量替换)，为了避免这种问题，在这里，我们使用自定义的 <code>$$</code> 来包裹模板变量</p>
</blockquote>
<p>一个基础的分页提取发票行实现如</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 5.1.4 完整的大发票提取</h4>
<p>然后就是提供一个外部的访问入口，直接基于上面的两个基础实现，来获取大发票的完整信息提取</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们使用上下文窗口更小、响应更快的 <code>GLM-4V-Flash</code> 模型来演示这个分页提取，如使用项目中的<code>test/resources/pupiao.jpg</code>为例，即便这个发票中有十行，也可以一并输出</p>
<figure><img src="/imgs/column/springai/D03-05.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 5.1.5 方案优化</h4>
<p>虽然实现了分页的开票行信息提取，但是这个实现是一个明显的串行化方案；对应的当开票行数据越多，整个服务的耗时就会越大</p>
<p>自然，我们就会有一个改进方案，在返回发票基本信息的同时，返回总的开票行数，然后就可以基于这个总数来计算分页，这样就可以通过并行的方案，实现分页开票行提取，一个可行的实现流程图如下</p>
<figure><img src="/imgs/column/springai/D03-06.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>若是觉得上面这个看起来有些复杂的话，也可以看下面这个简版方案，思路实际上是一致的</p>
<figure><img src="/imgs/column/springai/D03-07.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>具体的实现就省略了，有兴趣的小伙伴可以自行补全🤣</p>
</blockquote>
<h3> 5.2 图片预处理</h3>
<p>在实际的生产场景中，我们没办法保证用户上传的始终时数电开出来的电子票原件，可能是经过打印、拍照等各种操作之后上传的图片，此时直接拿来解析一般效果较差，通常一个完整可直接商用的发票识别，很大概率会有第一步的图片预处理阶段，当然这一块不是大模型提取的关键点（非大模型的实现中也会有这一步），下面是一个可参考的预处理方案</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5.3 Function Calling实现数据验证</h3>
<p>对于大模型的返回，我们可以结合 Functino Calling的机制，来实现数据验证，从而实现 ReAct 的多轮交互，比如一个非常基础的字段合法性校验如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了上面这个之外，我们还可以对纳锐人识别号、企业名称进行合法性校验（比如通过内部维护的映射或者外部的企查查之类的接口来实现）</p>
<p>当然这些属于辅助手段，不加貌似也没有太大的问题🤣</p>
<h3> 5.4 降级策略：传统OCR备用方案</h3>
<p>最后在生产环境中，难免会有一些突发情况，所以一个健壮的系统，对应的降级方案是不可缺少的，比如加一个ocr的备用方案</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5.5 监控与指标</h3>
<p>如果有必要有条件，基于Prometheus的监控加上可以说是一个<code>资深程序猿</code>的基本素养了，同样给一个简单的示例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 六、部署方案</h2>
<h3> 6.1 Docker容器化</h3>
<div class="language-docker line-numbers-mode" data-ext="docker"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6.2 Kubernetes部署</h3>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 七、大模型提取方案 VS 传统OCR发票识别方案</h2>
<p>最后我们下来看一下，这个大模型的实现方案，与传统的发票识别方案两者之间有什么差异</p>
<h3> 7.1 传统方案技术架构</h3>
<p>下面是一个经典的传统发票识别方案</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/D03-08.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在传统的方案中，主要分五部分</p>
<ol>
<li>图像预处理</li>
<li>OCR字符识别</li>
<li>模板匹配提取</li>
<li>业务规则校验</li>
<li>结果处理</li>
</ol>
<p>其中核心的实现会聚焦在 <code>模板匹配 + 业务规则校验</code>，同样也因为不同的模板的差异性，导致整个方案的挑战点在于</p>
<table>
<thead>
<tr>
<th>问题类别</th>
<th>具体表现</th>
</tr>
</thead>
<tbody>
<tr>
<td>模板依赖</td>
<td>每新增一种发票类型需配置新模板</td>
</tr>
<tr>
<td>位置敏感</td>
<td>发票版式变化导致提取失败</td>
</tr>
<tr>
<td>泛化能力差</td>
<td>无法处理未见过的发票格式</td>
</tr>
<tr>
<td>规则复杂</td>
<td>维护大量正则表达式和规则</td>
</tr>
<tr>
<td>容错性差</td>
<td>OCR识别错误直接导致提取错误</td>
</tr>
<tr>
<td>语义理解缺失</td>
<td>无法理解字段间的关系和含义</td>
</tr>
<tr>
<td>维护成本高</td>
<td>需要持续维护模板和规则库</td>
</tr>
</tbody>
</table>
<h3> 7.2 大模型方案 VS 传统方案</h3>
<p>基于技术方案的对比</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>传统OCR方案</th>
<th>大模型智能体方案</th>
</tr>
</thead>
<tbody>
<tr>
<td>核心技术</td>
<td>图像处理 + 规则引擎</td>
<td>多模态大模型 + 语义理解</td>
</tr>
<tr>
<td>处理逻辑</td>
<td>"如果-那么"规则链</td>
<td>端到端语义理解</td>
</tr>
<tr>
<td>模板依赖</td>
<td>强依赖，每款发票需模板</td>
<td>零模板，通用处理</td>
</tr>
<tr>
<td>泛化能力</td>
<td>差，只能处理已知格式</td>
<td>强，能处理未见格式</td>
</tr>
<tr>
<td>语义理解</td>
<td>无，仅文本匹配</td>
<td>强，理解字段含义和关系</td>
</tr>
<tr>
<td>容错能力</td>
<td>差，OCR错误即失败</td>
<td>强，能根据上下文纠正</td>
</tr>
<tr>
<td>维护成本</td>
<td>高，需持续维护模板规则</td>
<td>低，基本无需维护</td>
</tr>
<tr>
<td>扩展性</td>
<td>差，新增类型需开发</td>
<td>强，通过Prompt调整即可</td>
</tr>
<tr>
<td>准确性</td>
<td>高</td>
<td>低，相较于传统方案每一次的输出都存在不确定性</td>
</tr>
</tbody>
</table>
<p>从性能、实现角度进行对比</p>
<table>
<thead>
<tr>
<th>指标</th>
<th>传统OCR方案</th>
<th>大模型智能体方案</th>
</tr>
</thead>
<tbody>
<tr>
<td>首次部署时间</td>
<td>2-4周（模板开发）</td>
<td>1-3天（Prompt调优）</td>
</tr>
<tr>
<td>新增模板时间</td>
<td>1-3天/模板</td>
<td>几乎为0</td>
</tr>
<tr>
<td>处理准确率</td>
<td>70-85%（复杂场景）</td>
<td>90-98%</td>
</tr>
<tr>
<td>泛化能力</td>
<td>只能处理已知模板</td>
<td>可处理未知格式</td>
</tr>
<tr>
<td>维护人力</td>
<td>全职1-2人</td>
<td>兼职0.5人</td>
</tr>
<tr>
<td>容错能力</td>
<td>低（严格依赖OCR质量）</td>
<td>高（语义纠错）</td>
</tr>
<tr>
<td>处理速度</td>
<td>快（2-5秒）</td>
<td>中等（3-10秒）</td>
</tr>
<tr>
<td>硬件成本</td>
<td>低（CPU即可）</td>
<td>高（需要GPU/API）</td>
</tr>
</tbody>
</table>
<p>从简单的方案对比，基于大模型的发票提取智能体，其**灵活性、可维护性、未来适应性（如国际业务）**方面明显由于传统的OCR方案，当然在准确度上，若有定向调教的小模型，其准确率完全有可能优于传统的OCR方案，当然它的成本比传统的要高，但若是考虑到维护的员工成本，那显然大模型的优势还是很明显的（当然如果已经有成熟可用的方案，能不改就不要改😊）</p>
<h2> 八、小结</h2>
<p>本文以发票提取为切入点，构建了一个可生产使用的基于大模型的发票提取智能体，从具体的路径来看，这个系统的普适性很高，同样可以用于其他基于图片的结构化信息提取场景（比如快递面单的信息提取、身份证信息提取、简历信息提取等）</p>
<h3> 系统的核心功能单元：</h3>
<ol>
<li><strong>多模态理解</strong>：基于大模型准确理解图片内容</li>
<li><strong>智能提取</strong>：零配置提取任意版式发票信息</li>
<li><strong>数据验证</strong>：通过Function Calling实现字段验证</li>
<li><strong>降级策略</strong>：传统OCR备用方案保证服务可用性</li>
<li><strong>生产就绪</strong>：包含缓存、监控、批量处理等企业级功能</li>
</ol>
<h3> 技术知识点</h3>
<p>下面是本文中涉及到的相关技术点（重点在大模型领域）</p>
<ul>
<li>多模态</li>
<li>图文识别</li>
<li>提示词工程</li>
<li>大模型的分页交互如何实现</li>
<li>Function Call</li>
<li>结构化输出</li>
<li>上下文窗口</li>
</ul>
<p>对于大模型应用开发感兴趣的小伙伴，或者对上面提到的知识点有疑惑的小伙伴，不妨看看以下几篇内容（每篇耗时不超过五分钟😊）</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/qCn8x2XO2shA8MheYbHq0w" target="_blank" rel="noopener noreferrer">LLM 应用开发是什么：零基础也可以读懂的科普文(极简版)</a></li>
<li><a href="https://mp.weixin.qq.com/s/2GXBNOUq3jlysipftz8TpA" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：序-为什么你“会用 LLM”，但做不出复杂应用？</a></li>
<li><a href="https://mp.weixin.qq.com/s/v-z6EHY300ElOxdGPdzc0w" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第一章LLM到底在做什么？</a></li>
<li><a href="https://mp.weixin.qq.com/s/t_BuAW9i0npcaJdua3Am2Q" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第二章 模型不是重点，参数才是你真正的控制面板</a></li>
<li><a href="https://mp.weixin.qq.com/s/vzt0bGwcfnASOiBa0Kc7VQ" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第三章 为什么我的Prompt表现很糟？</a></li>
<li><a href="https://mp.weixin.qq.com/s/Nk-N34TLJVCTI5F4k5rGaQ" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第四章Prompt 的工程化结构设计</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZQbztqBq7_PzynG06N4-mg" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第五章 从 Prompt 到 Prompt 模板与工程治理</a></li>
<li><a href="https://mp.weixin.qq.com/s/nnKspRO87xbrn4-LBV3RNA" target="_blank" rel="noopener noreferrer">大模型应用开发系列教程：第六章 上下文窗口的真实边界</a></li>
<li><a href="https://mp.weixin.qq.com/s/96rHyp_gBUgmA2dhSbzNww" target="_blank" rel="noopener noreferrer">大模型应用开发实战：两百行实现一个自然语言地址提取智能体</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/D03-01.webp" type="image/webp"/>
    </item>
    <item>
      <title>应用篇</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E5%BA%94%E7%94%A8%E7%AF%87/</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E5%BA%94%E7%94%A8%E7%AF%87/</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">应用篇</source>
      <description>以搭建完整可用的SpringAI应用为目的，演示SpringAI的业务边界和表现 以搭建完整可用的SpringAI应用为目的，演示SpringAI的业务边界和表现，对应项目工都放在 app-projects 下 从0到1创建一个基于天气的旅游美食推荐智能体 大模型应用开发实战：两百行实现一个自然语言地址提取智能体 再见，OCR模板！你好，发票智能体：基于SpringAI与大模型的零配置发票智能提取架构 实战 | 零基础搭建知识库问答机器人：基于SpringAI+RAG的完整实现</description>
      <pubDate>Thu, 22 Jan 2026 08:45:40 GMT</pubDate>
      <content:encoded><![CDATA[<p>以搭建完整可用的SpringAI应用为目的，演示SpringAI的业务边界和表现</p>
<p>以搭建完整可用的SpringAI应用为目的，演示SpringAI的业务边界和表现，对应项目工都放在 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/app-projects" target="_blank" rel="noopener noreferrer">app-projects</a> 下</p>
<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> <a href="https://mp.weixin.qq.com/s/GTPUPs5FY52rz7bTbuaPuw" target="_blank" rel="noopener noreferrer">从0到1创建一个基于天气的旅游美食推荐智能体</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> <a href="https://mp.weixin.qq.com/s/96rHyp_gBUgmA2dhSbzNww" target="_blank" rel="noopener noreferrer">大模型应用开发实战：两百行实现一个自然语言地址提取智能体</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-2" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-2"> <a href="https://mp.weixin.qq.com/s/SnXdTB6tYqAzG7HgbnTSAQ" target="_blank" rel="noopener noreferrer">再见，OCR模板！你好，发票智能体：基于SpringAI与大模型的零配置发票智能提取架构</a></label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-3" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-3"> <a href="https://mp.weixin.qq.com/s/NHqLJbos-_nrxNNmhg7IBQ" target="_blank" rel="noopener noreferrer">实战 | 零基础搭建知识库问答机器人：基于SpringAI+RAG的完整实现</a></label></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>源码篇</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E6%BA%90%E7%A0%81%E7%AF%87/</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E6%BA%90%E7%A0%81%E7%AF%87/</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">源码篇</source>
      <description>以源码的视角，介绍SpringAI的核心实现</description>
      <pubDate>Thu, 22 Jan 2026 08:45:40 GMT</pubDate>
      <content:encoded><![CDATA[<p>以源码的视角，介绍SpringAI的核心实现</p>
]]></content:encoded>
    </item>
    <item>
      <title>01.使用数据库持久化对话历史</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E8%BF%9B%E9%98%B6%E7%AF%87/A01.%E4%BD%BF%E7%94%A8MySql%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E8%BF%9B%E9%98%B6%E7%AF%87/A01.%E4%BD%BF%E7%94%A8MySql%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">01.使用数据库持久化对话历史</source>
      <description>01.使用数据库持久化对话历史 本文作为SpringAI的进阶篇，将介绍一些在实际应用中，可能用到的小技巧。在基础篇的 04.聊天上下文 中，介绍并演示了基于 InMemoryChatMemoryRepository 来存储对话历史，从而实现多轮对话 在实际的业务场景中，用InMemoryChatMemoryRepository的场景可能还会更少一点，毕竟上下文放在内存中，不利于后续的审计以及应用重启之后数据就丢失了</description>
      <category>SpringAI</category>
      <pubDate>Thu, 07 Aug 2025 10:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 01.使用数据库持久化对话历史</h1>
<p>本文作为SpringAI的进阶篇，将介绍一些在实际应用中，可能用到的小技巧。在基础篇的 <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/04.%E8%81%8A%E5%A4%A9%E4%B8%8A%E4%B8%8B%E6%96%87.html" target="blank">04.聊天上下文</a>
中，介绍并演示了基于 <code>InMemoryChatMemoryRepository</code> 来存储对话历史，从而实现多轮对话</p>
<p>在实际的业务场景中，用<code>InMemoryChatMemoryRepository</code>的场景可能还会更少一点，毕竟上下文放在内存中，不利于后续的审计以及应用重启之后数据就丢失了</p>
<p>那么如何将对话持久化存储呢?</p>
<p>本文将介绍基于数据库的持久方案，将从两个方面进行介绍</p>
<ol>
<li>通过实例演示数据库的持久化使用方式</li>
<li>介绍一些关键的实现技术点</li>
</ol>
<h2> 一、项目演示</h2>
<h3> 1. 创建项目</h3>
<p>创建一个SpringAI项目，基本流程同 <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 2. 添加依赖</h3>
<p>在pom.xml中添加关键依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 配置数据库连接</h3>
<p>在配置文件 <code>application.yml</code> 文件中，指定SpringAI配置 + 数据库连接信息</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于<code>spring.ai.chat.memory.repository.jdbc</code>的配置进行一些必要的说明</p>
<table>
<thead>
<tr>
<th>配置</th>
<th>描述</th>
<th>取值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>spring.ai.chat.memory.repository.jdbc.initialize-schema</code></td>
<td>控制什么时候初始化schema</td>
<td>embeded(默认)/always/never</td>
</tr>
<tr>
<td><code>spring.ai.chat.memory.repository.jdbc.schema</code></td>
<td>指定数据库的schema的位置</td>
<td><code>classpath:org/springframework/ai/chat/memory/repository/jdbc/schema-@@platform@@.sql</code></td>
</tr>
<tr>
<td><code>spring.ai.chat.memory.repository.jdbc.platform</code></td>
<td>数据库平台，如mysql/h2/postgresql等</td>
<td>默认会自动检测</td>
</tr>
</tbody>
</table>
<p>在上面的配置中，我们的 <code>initialize-schema</code> 配置为 <code>always</code>，表示在启动的时候会自动创建数据库表（即便表存在，也会尝试执行脚本；我们这里使用的是MySql，因此需要自动创建表<code>SPRING_AI_CHAT_MEMORY</code>）</p>
<ol>
<li>ALWAYS</li>
</ol>
<ul>
<li>无论何时都会执行数据库初始化</li>
<li>即使数据库已存在，也会尝试运行初始化脚本</li>
<li>适用于每次启动都需要重新初始化数据库的场景</li>
</ul>
<ol start="2">
<li>EMBEDDED</li>
</ol>
<ul>
<li>仅在使用嵌入式数据库时执行初始化</li>
<li>对于H2、HSQL、Derby等嵌入式数据库会自动初始化</li>
<li>对于外部数据库（如MySQL、PostgreSQL）则跳过初始化</li>
<li>这是大多数情况下的推荐设置</li>
</ul>
<ol start="3">
<li>NEVER</li>
</ol>
<ul>
<li>从不执行数据库初始化</li>
<li>完全跳过所有数据库schema和data脚本的执行</li>
<li>适用于生产环境或已有数据库结构的情况</li>
</ul>
<p>对应的Schema所在的位置如下图</p>
<figure><img src="/imgs/column/springai/A01-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 初始化 ChatMemory</h3>
<p>当我们引入 <code>spring-ai-starter-model-chat-memory-repository-jdbc</code> 之后，会自动注入 <code>ChatMemoryRepository</code>
的bean对象，我们接下来基于它来创建<code>ChatMemory</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. ChatClient 配置</h3>
<p>然后通过<code>MessageChatMemoryAdvisor</code>来为<code>ChatClient</code>提供聊天历史能力支撑</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 示例测试</h3>
<p>提供一个聊天接口，第一个参数为用户标识，用于区分用户的聊天记录</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/A01-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 二、关键技术点</h2>
<p>使用MySql来存储用户与大模型的对话情况，从使用角度来看，还比较简单；接下来我们抓一下技术要点，从疑问出发，看下能否完成解惑</p>
<ol>
<li>持久化的数据表结构是如何设计的？</li>
<li>数据库表是如何初始化的？</li>
<li>又是如何实现自动识别数据库平台的？</li>
<li>如果想使用自定义的数据库表，替代默认的，可以怎么实现？</li>
</ol>
<h3> 1. 默认的表结构设计</h3>
<p>关于这个一点，前面介绍配置的时候也提到了，在<code>spring-aimodel-chat-memory-repository-jdbc</code>的包中，提供了5个schema文件，对应的源码工程结果如下</p>
<figure><img src="/imgs/column/springai/A01-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>以mysql为例，对应的schema如下</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>定义了四个字段，分别为：</p>
<ul>
<li><code>conversation_id</code>: 会话ID，用于区分不同的会话</li>
<li><code>content</code>: 会话内容，可以是用户输入，也可以是模型输出</li>
<li><code>type</code>: 会话类型，可以是用户输入，也可以是模型输出，也可以是系统信息，也可以是工具信息</li>
<li><code>timestamp</code>: 会话时间，用于排序</li>
</ul>
<h3> 2. 数据库初始化</h3>
<p>通过配置 <code>spring.ai.chat.memory.repository.jdbc.initialize-schema</code> 来控制； 为 <code>always</code>，会自动创建数据库表（即便表存在，也会尝试执行脚本）</p>
<p>这里主要是通过<code>JdbcChatMemoryRepositorySchemaInitializer</code>来实现schema脚本的初始化行为，依赖的是Spring Boot 中用于数据库初始化的组件<code>DataSourceScriptDatabaseInitializer</code></p>
<ul>
<li>检查数据库初始化模式（DatabaseInitializationMode）</li>
<li>根据配置查找相应的 SQL 脚本文件</li>
<li>使用配置的 DataSource 连接数据库</li>
<li>按顺序执行 schema 脚本和 data 脚本</li>
<li>处理脚本执行过程中的异常</li>
</ul>
<h3> 3. 自动识别数据库平台</h3>
<p>关键实现逻辑  <code>org.springframework.ai.chat.memory.repository.jdbc.JdbcChatMemoryRepositoryDialect.from</code></p>
<figure><img src="/imgs/column/springai/A01-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>根据数据库连接来判断当前使用的是哪个数据库，默认的是 <code>postgresql</code></p>
<h3> 4. 自定义数据库表结构</h3>
<p>默认的表结构满足大部分场景，如果需要自定义表结构，可以通过实现 <code>JdbcChatMemoryRepositoryDialect</code> 接口来自定义，并注册到 Spring 容器中</p>
<p>比如默认的MySql相关sql如下，若需要调整表名、字段名，替换下面的这个类，然后注册到 <code>JdbcChatMemoryRepository</code> 中即可</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点说明：换表名、字段名还好，如果我想额外存储用户的token使用情况，可行吗？</p>
<p>从源码来看，不可行，上面的 <code>Dialect</code> 中的<code>insert</code>，已经绑定了字段，无法进行动态扩展</p>
<figure><img src="/imgs/column/springai/A01-5.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 三、小结</h2>
<p>本文介绍的是基于MySql持久化对话历史的实现方案，Spring AI 默认使用 JdbcChatMemoryRepository 来实现，基于 MySql 的表结构，可以满足大部分场景，如果需要自定义表结构，可以通过实现 <code>JdbcChatMemoryRepositoryDialect</code> 接口来自定义</p>
<p>通过使用实例和一些关键性的技术说明，对于官方未直接支持的数据库，我们也可以很方便的进行扩展；当然现在的实现还存在一点缺陷，那就是无法自定义持久化的信息</p>
<p>接下来一篇博文，我们将实例演示，如何使用 h2 数据库进行持久化</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/advance-projects/A01-memory-jdbc-mysql" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/A01-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>02.使用H2持久化对话历史</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E8%BF%9B%E9%98%B6%E7%AF%87/A02.%E4%BD%BF%E7%94%A8H2%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E8%BF%9B%E9%98%B6%E7%AF%87/A02.%E4%BD%BF%E7%94%A8H2%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">02.使用H2持久化对话历史</source>
      <description>02.使用H2持久化对话历史 上面一篇文章介绍了 SpringAI官方提供的 jdbc start来实现持久化对话历史 使用MySql持久化对话历史，官方实现的几个数据库已经很有代表性了，接下来我们将看一下，如果沿用官方的思路，来为h2添加持久化对话历史功能。</description>
      <category>SpringAI</category>
      <pubDate>Thu, 07 Aug 2025 11:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 02.使用H2持久化对话历史</h1>
<p>上面一篇文章介绍了 SpringAI官方提供的 jdbc start来实现持久化对话历史 <a href="/ai-guides/ai-dev/%E8%BF%9B%E9%98%B6%E7%AF%87/A01.%E4%BD%BF%E7%94%A8MySql%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html" target="blank">使用MySql持久化对话历史</a>，官方实现的几个数据库已经很有代表性了，接下来我们将看一下，如果沿用官方的思路，来为h2添加持久化对话历史功能。</p>
<h2> 一、H2持久化对话历史</h2>
<h3> 1. 创建项目</h3>
<p>创建一个SpringAI项目，基本流程同 <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 2. 添加依赖</h3>
<p>在pom.xml中添加关键依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. 配置数据库连接</h3>
<p>在配置文件 <code>application.yml</code> 文件中，指定SpringAI配置 + 数据库连接信息</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明，虽然我们这里使用的是 H2，但是 <code>spring.ai.chat.memory.repository.jdbc.initialize-schema</code> 配置项，还是建议选择 <code>always</code>，因为上面配置的是使用文件来存储db；如果使用内存 <code>jdbc:h2:mem</code> 的方式，则这里可以选择 <code>embedded</code></p>
<figure><img src="/imgs/column/springai/A02-1.webp" alt="embeded是否创建表的关键判断逻辑" tabindex="0" loading="lazy"><figcaption>embeded是否创建表的关键判断逻辑</figcaption></figure>
<p>其次就是我们需要指定 <code>schema</code> 文件，这个文件，就是用来创建数据库表结构，这里我们使用 <code>h2</code> 的默认结构，因此这里我们使用 <code>classpath:schema-h2.sql</code></p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. 初始化 ChatMemory</h3>
<p>因为我们使用的是系统未提供支持的h2，因此无法使用自动注入的<code>ChatMemoryRepository</code>，因为它选择的Dialect是 <code>PostgresChatMemoryRepositoryDialect</code>，无法支持h2的使用场景</p>
<p>我们这里直接使用<code>MysqlChatMemoryRepositoryDialect</code>来作为h2的Dialect（当然也可以自行实现一个Dialect）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. ChatClient 配置</h3>
<p>然后通过<code>MessageChatMemoryAdvisor</code>来为<code>ChatClient</code>提供聊天历史能力支撑</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 示例测试</h3>
<p>提供一个聊天接口，第一个参数为用户标识，用于区分用户的聊天记录</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动成功之后，我们可以在h2-console中看到新增了一个表 <code>SPRING_AI_CHAT_MEMORY</code></p>
<figure><img src="/imgs/column/springai/A02-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后进行多轮对话，看看效果，表现和我们预期一致，聊天记录被保存在数据库中</p>
<figure><img src="/imgs/column/springai/A02-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 二、小结</h2>
<p>本文介绍的是如何借助 <code>spring-ai-starter-model-chat-memory-repository-jdbc</code> 来实现自定义的对话持久化，通过实现h2的Dialect，我们可以轻松实现自定义的持久化逻辑；若希望了解持久化的更多实现细节，可以查看上篇 <a href="/ai-guides/ai-dev/%E8%BF%9B%E9%98%B6%E7%AF%87/A01.%E4%BD%BF%E7%94%A8MySql%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html" target="blank">使用MySql持久化对话历史</a></p>
<p>这里实现的是基于数据库来进行持久化，那么如果我不是用数据库，比如希望用文件或者redis来实现，又可以怎么做呢？</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/advance-projects/A02-memory-jdbc-h2" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/A02-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>03.使用Redis持久化对话历史</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E8%BF%9B%E9%98%B6%E7%AF%87/A03.%E4%BD%BF%E7%94%A8Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E8%BF%9B%E9%98%B6%E7%AF%87/A03.%E4%BD%BF%E7%94%A8Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E8%AF%9D%E5%8E%86%E5%8F%B2.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">03.使用Redis持久化对话历史</source>
      <description>03.使用Redis持久化对话历史 前面介绍了使用关系数据库来存储对话历史，接下来我们更进一步，通过扩展ChatMemoryRepository来实现基于Redis的持久化 一、Redis持久化对话历史 1. 创建项目 创建一个SpringAI项目，基本流程同 创建一个SpringAI-Demo工程</description>
      <category>SpringAI</category>
      <pubDate>Thu, 07 Aug 2025 17:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 03.使用Redis持久化对话历史</h1>
<p>前面介绍了使用关系数据库来存储对话历史，接下来我们更进一步，通过扩展<code>ChatMemoryRepository</code>来实现基于Redis的持久化</p>
<h2> 一、Redis持久化对话历史</h2>
<h3> 1. 创建项目</h3>
<p>创建一个SpringAI项目，基本流程同 <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 2. 添加依赖</h3>
<p>在pom.xml中添加关键依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接依赖<code>spring-ai-starter-model-chat-memory</code>来实现聊天记录，这里采用redis来进行持久化，因此我们添加redis的相关依赖（这里一jedis客户端为例，对于lettuce或者redisson实际上没有太大的差别）</p>
<h3> 3. 配置</h3>
<p>在配置文件 <code>application.yml</code> 文件中，指定redis相关配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们这里使用单节点的redis进行演示；对于集群的场景，除了配置不一样之外，实际上对于我们的实现并没有太大的差别（因为我们利用的是Spring封装的RedisTemplate进行操作，因此对于集群的场景，实际上也是可以的）</p>
<h3> 4. 实现RedisChatMemoryRepository</h3>
<p>通过实现接口<code>ChatMemoryRepository</code>来完成我们的 RedisChatMemoryRepository</p>
<p>对于用户聊天记录，我们采用redis的列表的数据结构进行存储(具体实现除了这种方案之外，也可以使用hash数据结构来存储，field为会话id，value为对话记录)</p>
<ul>
<li>key: <code>chat:${conversationId}</code></li>
<li>value: [] , 消息列表</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基于redis的存储实现相对来讲并不算复杂，无非就是Message的读取与写入，这里我们采用json进行序列化与反序列化</p>
<p>我们实现一个自定义的反序列化策略，在获取数据时，只要Message中的 <code>messageType</code> + <code>text</code>，因为这些会一并传递给大模型，其他的元数据并没有太大意义，还会消耗我们的token</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的JsonUtil的实现则比较基础，一个统一的json工具类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 定义ChatMemory</h3>
<p>定义一个自定义的ChatMemory，这里我们使用 <code>RedisChatMemoryRepository</code> 来作为消息的存储仓库</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6. 示例测试</h3>
<p>提供一个聊天接口，第一个参数为用户标识，用于区分用户的聊天记录</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/A03-1.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 二、小结</h2>
<p>本文介绍的是如何通过实现SpringAI定义的<code>ChatMemoryRepository</code>接口来完成自定义的对话记录持久化，通过这种方式，可以实现更灵活的上下文管控</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/advance-projects/A03-memory-redis" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/A03-1.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>04.使用LangGraph4J实现多轮对话</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E8%BF%9B%E9%98%B6%E7%AF%87/A04.%E4%BD%BF%E7%94%A8LangGraph4J%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%BD%AE%E5%AF%B9%E8%AF%9D.html</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E8%BF%9B%E9%98%B6%E7%AF%87/A04.%E4%BD%BF%E7%94%A8LangGraph4J%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%BD%AE%E5%AF%B9%E8%AF%9D.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">04.使用LangGraph4J实现多轮对话</source>
      <description>04.使用LangGraph4J实现多轮对话 之前介绍的多轮对话，上下文存储主要是SpringAI提供的能力支持；接下来我们看一下，在agent开发时推荐使用的框架LangGraphJ，如何实现多轮对话 一、LangGraphJ实现多轮对话 1. 创建项目 创建一个SpringAI项目，基本流程同 创建一个SpringAI-Demo工程</description>
      <category>SpringAI</category>
      <pubDate>Mon, 11 Aug 2025 17:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 04.使用LangGraph4J实现多轮对话</h1>
<p>之前介绍的多轮对话，上下文存储主要是SpringAI提供的能力支持；接下来我们看一下，在agent开发时推荐使用的框架LangGraphJ，如何实现多轮对话</p>
<h2> 一、LangGraphJ实现多轮对话</h2>
<h3> 1. 创建项目</h3>
<p>创建一个SpringAI项目，基本流程同  <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/01.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASpringAI-Demo%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个SpringAI-Demo工程</a></p>
<h3> 2. 添加依赖</h3>
<p>在pom.xml中添加关键依赖</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们这里直接依赖的是 <code>langgraph4j-springai-agentexecutor</code> 模块，该模块提供了基于SpringAI的AgentExecutor实现；使用的版本为当前(25/08/08)的最新版本，有需要的小伙伴根据实际情况进行调整</p>
<h3> 3. 配置</h3>
<p>在配置文件 <code>application.yml</code> 文件中，添加大模型配置，我们这里依然是使用ZhipuAI的模型进行演示</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4. MemAgent实现</h3>
<p>实现一个MemAgent，用于获取对话的<code>CompileGraph</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意上面的实现， <code>MemorySaver</code> 是一个 <code>BaseCheckpointSaver</code> 的实现，用于实现 Checkpoint 的保存，对话历史保存到jvm内存中；使用<code>org.bsc.langgraph4j.RunnableConfig.threadId</code>来实现不同身份的会话隔离</p>
<h3> 5. 多轮对话端点</h3>
<p>提供一个聊天接口，第一个参数为用户标识，用于区分用户的聊天记录</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/A04-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 二、小结</h2>
<p>本文演示了通过 LangGraphJ 实现多轮对话的实现，虽然效果是实现了，但是对LangGraphJ不太了解的小伙伴，估计会有很多疑问，这个框架是怎么工作的呢？又该如何使用它来开发Agent呢？</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/advance-projects/A04-memory-agent-langgraph" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/A04-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>05.使用LangGraph4J实现Agent路由选择</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E8%BF%9B%E9%98%B6%E7%AF%87/A05.%E4%BD%BF%E7%94%A8LangGraph4J%E5%AE%9E%E7%8E%B0Agent%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9.html</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E8%BF%9B%E9%98%B6%E7%AF%87/A05.%E4%BD%BF%E7%94%A8LangGraph4J%E5%AE%9E%E7%8E%B0Agent%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">05.使用LangGraph4J实现Agent路由选择</source>
      <description>05.使用LangGraph4J实现Agent路由选择 在 创建一个Langgraph4j示例工程 这一篇文章中，我们介绍了如何创建一个 LangGraph4j 的示例工程； 在上文中介绍到 LangGraph4j 时，就提到了它有一个重要的特性，就是可以定义循环图，使不同的组件（代理、工具或自定义逻辑）能够以有状态的方式进行交互</description>
      <category>SpringAI</category>
      <pubDate>Tue, 12 Aug 2025 11:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 05.使用LangGraph4J实现Agent路由选择</h1>
<p>在 <a href="/ai-guides/ai-dev/%E5%9F%BA%E7%A1%80%E7%AF%87/14.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AALanggraph4j%E5%AE%9E%E4%BE%8B%E5%B7%A5%E7%A8%8B.html" target="blank">创建一个Langgraph4j示例工程</a> 这一篇文章中，我们介绍了如何创建一个 LangGraph4j 的示例工程；</p>
<p>在上文中介绍到 <code>LangGraph4j</code> 时，就提到了它有一个重要的特性，就是可以定义循环图，使不同的组件（代理、工具或自定义逻辑）能够以有状态的方式进行交互</p>
<p>接下来我们来实际感受一下，上面这个重要的特性是如何表现的</p>
<h2> 一、项目创建</h2>
<h3> 1. 创建LangGraph4j + SpringAI项目</h3>
<p>具体的创建过程，与上文一致，有兴趣的小伙伴请关注 <a href="../%E5%9F%BA%E7%A1%80%E7%AF%87/14.%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AALanggraph4j%E5%AE%9E%E4%BE%8B%E5%B7%A5%E7%A8%8B">创建一个Langgraph4j示例工程</a></p>
<h3> 2. 配置大模型密钥</h3>
<p>这里依然使用智谱的免费大模型，使用其他的模型时，请自行替换<code>start</code>和下面的配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 二、创建一个地点的旅游推荐Agent</h2>
<h3> 1. 工作流程</h3>
<p>在这里，我们设计一个简单的业务流程，开发一个旅游推荐的Agent，在这个agent中，我们需要结合旅游地点的天气，来选择不同的推荐项目</p>
<figure><img src="/imgs/column/springai/A05-1.webp" alt="由LangGraph4j生成的流程图" tabindex="0" loading="lazy"><figcaption>由LangGraph4j生成的流程图</figcaption></figure>
<p>注意上面这个流程图，虽然它是事后由<code>LangGraph4j</code>生成的，实际也是呈现我们的旅游推荐Agent的核心工作流程</p>
<ol>
<li>Weather: 根据传入的地方，获取当前的天气</li>
<li>Router: 作为一个路由节点（实际上啥也没干）
<ul>
<li>当天气为晴天时，路由到 outdoor，推荐一些室外的旅游项目</li>
<li>当天气为雨天时，路由到 indoor，推荐一些室内的旅游项目</li>
<li>当天气为其他情况时，路由到 default，直接结束</li>
</ul>
</li>
</ol>
<h3> 2. 基本概念科普</h3>
<p>在<code>LangGraph</code>中，有几个核心的概念，我们现简单来看一下；后面的实现中，会针对性的实现这些</p>
<blockquote>
<p>以下内容，来自于: <a href="https://github.com/langgraph4j/langgraph4j" target="_blank" rel="noopener noreferrer">langgraph4j</a></p>
</blockquote>
<h4> AgentState</h4>
<p>AgentState（或其扩展类）表示图的共享状态。它本质上是一个映射 (<code>Map&lt;String, Object&gt;</code>)，会在各个节点之间传递。每个节点都可以读取此状态并返回更新。</p>
<ul>
<li><code>Schema</code>：状态的结构由“Schema”定义，它是一个 <code>Map&lt;String, Channel.Reducer&gt;</code> 类型的对象。Map 中的每个键都对应状态中的一个属性。</li>
<li><code>Channel.Reducer</code>：Reducer 定义了如何处理状态属性的更新。例如，新值可能会覆盖旧值，或者添加到现有值列表中。</li>
<li><code>Channel.Default&lt;T&gt;</code>：如果状态属性尚未设置，则为其提供默认值。</li>
<li><code>Channel.Appender&lt;T&gt;</code> <code>/</code> <code>MessageChannel.Appender&lt;M&gt;</code>：一种常见的 Reducer 类型，它将新值附加到与状态属性关联的列表中。这对于累积消息、工具调用或其他数据序列非常有用。MessageChannel.Appender 专为聊天消息而设计，还可以处理通过 ID 删除消息的操作。</li>
</ul>
<h4> Nodes</h4>
<p>节点是构成图的执行操作的基石。节点通常是一个函数（或一个实现 <code>NodeAction&lt;S&gt;</code> 或 <code>AsyncNodeAction&lt;S&gt;</code> 的类），它：</p>
<ul>
<li>接收当前 <code>AgentState</code> 作为输入。</li>
<li>执行某些计算（例如，调用 LLM、执行工具、运行自定义业务逻辑）。</li>
<li>返回一个表示状态更新的 <code>Map&lt;String, Object&gt;</code> 对象。这些更新随后会根据架构的 <code>Reducer</code> 应用于 <code>AgentState</code>。</li>
</ul>
<p>节点可以是同步的，也可以是异步的（CompletableFuture）。</p>
<h4> Edges</h4>
<p>边定义节点之间的控制流。</p>
<ul>
<li>普通边：从一个节点到另一个节点的无条件转换。节点 A 完成后，控制权始终传递给节点 B。您可以使用 <code>addEdge(sourceNodeName, destinationNodeName)</code> 定义普通边。</li>
<li>条件边：下一个节点根据当前 <code>AgentState</code> 动态确定。
<ul>
<li>源节点完成后，将执行 <code>EdgeAction&lt;S&gt;</code>（或 <code>AsyncEdgeAction&lt;S&gt;</code>）函数。</li>
<li>该函数接收当前状态并返回下一个要执行的节点的名称。</li>
<li>这允许分支逻辑（例如，如果代理决定使用某个工具，则转到<code>execute_tool</code>节点；否则，转到<code>respond_to_user</code>节点）。</li>
<li>条件边使用 <code>addConditionalEdges(...)</code> 定义。</li>
</ul>
</li>
<li>入口点：您还可以使用 <code>addConditionalEntryPoint(...)</code> 为图定义条件入口点。</li>
</ul>
<h4> Compilation</h4>
<p>在 <code>StateGraph</code> 中定义好所有节点和边后，可以使用 <code>compile()</code> 将其编译为 <code>CompiledGraph&lt;S extends AgentState&gt;</code>。</p>
<p>这个编译后的图是你的逻辑的不可变且可运行的表示。编译过程会验证图的结构（例如，检查是否存在孤立节点）。</p>
<h4> Checkpoints (Persistence)</h4>
<p><code>LangGraph4j</code> 允许您在任何步骤保存（检查点）图的状态。这在以下情况下非常有用：</p>
<ul>
<li>调试：检查各个点的状态以了解发生了什么。</li>
<li>恢复：将图恢复到之前的状态并继续执行。</li>
<li>长时间运行的进程：持久化长时间运行的代理交互的状态。您通常会使用 <code>CheckpointSaver</code> 实现（例如，使用 <code>MemorySaver</code> 进行内存存储，或者您也可以自己实现持久化存储）。</li>
</ul>
<h3> 3. Node实现</h3>
<p>从上面的流程图中我们也可以看出，这里定义了四个<code>Node</code>，接下来我们分别给于实现</p>
<p><strong>WeatherNode：用于获取地区的天气</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>RouterNode: 路由节点</strong></p>
<p>这个路由节点实际上啥也没干，不要也行，这里主要是用它打印了一下 WeatherNode 的输出</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>OutdoorNode: 室外推荐节点</strong></p>
<p>在这个节点中，我们使用大模型来推荐外出旅游的项目</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>IndoorNode: 室内推荐节点</strong></p>
<p>在这个节点中，我们使用大模型来推荐适合室内游玩的项目</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到这里，我们的四个节点已经定义完成，接下来进行节点的连接</p>
<h3> 4. 节点连接</h3>
<p>节点连接，就是将节点通过<code>addEdge</code>方法进行连接，这里我们连接了四个节点，并且定义了条件边，用于判断当前节点是否需要执行</p>
<p>首先实现路由的条件边判定</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后是完成完整的节点、边定义</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5. 输出PlantUML</h3>
<p>在上面的节点定义完成后，我们可以通过<code>graph.getGraph()</code>方法，将节点定义转换为PlantUML格式，方便我们查看节点定义</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们拿到上面的内容之后，可以在 <a href="https://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa700001" target="_blank" rel="noopener noreferrer">在线plantuml工具</a> 中查看，会生成对应的流程图</p>
<figure><img src="/imgs/column/springai/A05-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 6. Agent封装</h3>
<p>接下来就是将上面的实现，封装为一个完整的，对外直接使用的Agent，源码可以在最后的项目链接中获取，类名为 <code>WeatherRecommendAgent</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7. 测试验证</h3>
<p>接下来我们进行实例验证，创建一个Controller，调用<code>WeatherRecommendAgent</code>的<code>recommendByLocation</code>方法，传入地区参数，返回结果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/springai/A05-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面实际的表现结果也可以看出和我们前面定义的流程图表现一致</p>
<h2> 三、小结</h2>
<p>本文通过实现一个简单的基于地点的天气实现旅游项目推荐，演示了多个单Agent联合组装成一个更复杂、功能更强大Agent示例。</p>
<p>在这个实现过程中，我们实现或者应用了<code>LangGraph4j</code> 框架中定义的Node、边（条件边）、State等，通过这些来生成了一个 <code>CompiledGraph</code>， 通过<code>CompiledGraph</code>来实现多Agent的组合</p>
<p>虽然这个项目实现了一个多Agent的组合，但是善于思考的我们，依然会有一些疑问</p>
<ul>
<li>这里使用的是默认的<code>AgentState</code>，内部是使用Map来传递共享参数，是否有更结构化的方式?</li>
<li><code>addConditionalEdges</code> 条件边定义的具体用法说明</li>
<li><code>GraphRepresentation</code> 节点定义的输出格式，是否可以自定义？ 是否可以结构化输出？</li>
<li>上面整体的实现更多的是借助<code>langgraph4j-core</code>，对于<code>langgraph4j-springai</code>是否会有更简单的使用姿势？</li>
</ul>
<p>接下来我们将努力尝试对上面这些问题进行逐步回答，有兴趣的小伙伴可以持续关注一波</p>
<p>文中所有涉及到的代码，可以到项目中获取 <a href="https://github.com/liuyueyi/spring-ai-demo/tree/master/advance-projects/A04-memory-agent-langgraph" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/spring-ai-demo</a></p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/A05-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>进阶篇</title>
      <link>https://ppai.top/ai-guides/ai-dev/%E8%BF%9B%E9%98%B6%E7%AF%87/</link>
      <guid>https://ppai.top/ai-guides/ai-dev/%E8%BF%9B%E9%98%B6%E7%AF%87/</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">进阶篇</source>
      <description>进阶相关将主要介绍如何更好的使用SpringAI进行大模型应用开发</description>
      <pubDate>Thu, 22 Jan 2026 08:45:40 GMT</pubDate>
      <content:encoded><![CDATA[<p>进阶相关将主要介绍如何更好的使用SpringAI进行大模型应用开发</p>
]]></content:encoded>
    </item>
    <item>
      <title>1. 首个完全由AI生成的APP-ColorPicker上架啦</title>
      <link>https://ppai.top/ai-guides/tutorial/ai-coding/01.%E9%A6%96%E4%B8%AA%E5%AE%8C%E5%85%A8%E7%94%B1AI%E7%94%9F%E6%88%90%E7%9A%84APP%E4%B8%8A%E6%9E%B6%E5%95%A6.html</link>
      <guid>https://ppai.top/ai-guides/tutorial/ai-coding/01.%E9%A6%96%E4%B8%AA%E5%AE%8C%E5%85%A8%E7%94%B1AI%E7%94%9F%E6%88%90%E7%9A%84APP%E4%B8%8A%E6%9E%B6%E5%95%A6.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">1. 首个完全由AI生成的APP-ColorPicker上架啦</source>
      <description>hello大家好，我是一灰灰，距离上一次和大家分享技术相关内容已经过去了两年多了；若不是最近AICoding的大火，估计也不会继续发文啦。最近这个月深度体验了ai coding的能力，也借助字节的Trae完成了几个产品，借着首个app上架一周的时间、并获得首个自然用户的评价（虽然是个差评）这个时机，给大家分享一下我最近在筹划的一个专栏 -- 《人人都是程序员》 第一手原文：首个完全由AI生成的APP-ColorPicker上架啦 | 一灰灰blog的公众号</description>
      <category>AI</category>
      <pubDate>Mon, 24 Mar 2025 21:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>hello大家好，我是一灰灰，距离上一次和大家分享技术相关内容已经过去了两年多了；若不是最近AICoding的大火，估计也不会继续发文啦。最近这个月深度体验了ai coding的能力，也借助字节的Trae完成了几个产品，借着首个app上架一周的时间、并获得首个自然用户的评价（虽然是个差评）这个时机，给大家分享一下我最近在筹划的一个专栏 -- 《人人都是程序员》</p>
<blockquote>
<p>第一手原文：<a href="https://mp.weixin.qq.com/s/qtxF-vnUeKrp9BZZRaeeSw" target="_blank" rel="noopener noreferrer">首个完全由AI生成的APP-ColorPicker上架啦 | 一灰灰blog的公众号</a></p>
</blockquote>
<figure><img src="/imgs/column/ai/1_1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>确实是没想到外国人也会因为语言问题给差评，谁说欧洲人素质高来着😡</p>
<h2> 1. ColorPicker上架谷歌应用市场</h2>
<p>最近这段时间的各种AI工具的使用，加上首个99%以上内容由AI生成的APP（ColorPicker）在谷歌应用市场的成功上线，忽然意识到“人人都是程序员”这一现实好像在加速到来。</p>
<p>还记得我在初入这一行时，当时的TL推荐我们程序员要有产品思维，多看看《人人都是产品经理》这一本书，没想到今天我要开始着手准备《人人都是程序员》了。</p>
<p>首先给大家看一下这个完全由AI完成的APP（3.17号上架通过）</p>
<figure><img src="/imgs/column/ai/1_2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>下面是实际的体验效果（整体功能齐全啦）</p>
<blockquote>
<p>点击查看原文：<a href="https://mp.weixin.qq.com/s/qtxF-vnUeKrp9BZZRaeeSw" target="_blank" rel="noopener noreferrer">演示视频原文</a></p>
</blockquote>
<p>希望体验h5的小伙伴可以访问下面两个地址（一个是自己的域名，一个是白嫖的cloudflare服务），或者直接点击文末的访问原文直达</p>
<ul>
<li><a href="http://cdn.hhui.top/app/color-picker/index.html#/" target="_blank" rel="noopener noreferrer">http://cdn.hhui.top/app/color-picker/index.html#/</a></li>
<li><a href="https://colorpicker-bpx.pages.dev/#/" target="_blank" rel="noopener noreferrer">https://colorpicker-bpx.pages.dev/#/</a></li>
</ul>
<p><strong>1. 主要的业务逻辑：</strong></p>
<p>• 照相 + 本地相册读取图片，识别图片颜色
• 支持颜色分组，收藏
• 颜色详情，支持全屏显示
• 系统推荐色彩专栏
• APP国际化</p>
<p><strong>2. 集成谷歌Admob广告，支持变现</strong></p>
<p><strong>3. 多端支持</strong></p>
<p>•android 版本 （已上架）
•ios 版本（没有苹果应用账号，因此没上架）
•h5/pc 版本: 已上线   <a href="https://colorpicker-bpx.pages.dev/#/" target="_blank" rel="noopener noreferrer">https://colorpicker-bpx.pages.dev/#/</a>
•小程序版（未备案，所以未上线）</p>
<h2> 2. AI生成APP的契机</h2>
<p>ColorPicker的诞生也比较偶然，今年年初的DeepSeek掀起AI届的新一轮高潮，好久没怎么学习的我也凑了一波热闹，借助字节提供的免费AI编辑器Trae，看一下现在的ai工具代码到底写得怎么样。</p>
<p>如到现在，基于Trae我共实现了三个应用：</p>
<h3> 2.1. 像素图填色游戏</h3>
<blockquote>
<p>源码：<a href="https://liuyueyi.github.io/ai-web-case/" target="_blank" rel="noopener noreferrer">https://liuyueyi.github.io/ai-web-case/</a></p>
</blockquote>
<p>1.一个简单的单页面web应用，通过解析给定的配置文件，生成像素图；用户可以根据自己选择的颜色对像素进行填色
2.特点：页面布局单一、业务逻辑简单，交互不多</p>
<figure><img src="/imgs/column/ai/1_3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这个web页面的开发过程非常顺利，基本上没有什么特别糟心的事情，整个实现也就两天的时间（关于将图片转换为用于渲染像素图的二维矩阵花了我一天，这块还是借助我的老本行java实现的😂），接下来我就想上点难度，看下AICoding的能力在哪里，接下来就有了下面的AI对战游戏</p>
<h3> 2.2. AI人机对战棋牌游戏</h3>
<p>1.人机对战的棋牌游戏，原定计划实现 五子棋、黑白棋、三子/九子棋、中国象棋、国际象棋等经典棋牌的人机方式
2.最终结果：完成五子棋、黑白棋、三子棋的基础实现
3.特点：布局相对复杂（比如三子棋盘的绘制），算法要求高（AI下棋策略，人机交互策略）</p>
<figure><img src="/imgs/column/ai/1_4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>相较于像素填色，这个AI棋盘对战的开发过程就比较难受了，不管是棋盘的布局（尤其是三子棋的棋盘，反复修改调整)、AI的游戏策略/判定策略调教，都不是一个轻松的活，原定计划的中国象棋和国际象棋也没有耐心继续调教了。</p>
<p>这个游戏差不多花了我一周的时间，做完之后，感受就是AICoding确实方便，虽然离取代资深程序员还是有不小的距离，但是对初级程序员的挑战就很非常大了。这个项目做完之后，我就萌生了一个“人人都是程序员”的想法，这好像并不是不可能</p>
<h3> 2.3. ColorPicker 图片颜色提取APP</h3>
<blockquote>
<p>源码 <a href="https://github.com/liuyueyi/ai-color-picker" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/ai-color-picker</a></p>
</blockquote>
<p>接下来就准备开始验证这个“人人都是程序员”是否属于我的异想天开了。</p>
<p>直接在应用市场，按照工具类进行下载、好评进行搜索，然后看到了一个百万下载量，而且功能不复杂应用，看到它的时候我就深信这个app完全可以有AI来生成，于是就有了下面的Ai生成应用</p>
<figure><img src="/imgs/column/ai/1_5.png" alt="AI致敬版，百万下载量的高分APP" tabindex="0" loading="lazy"><figcaption>AI致敬版，百万下载量的高分APP</figcaption></figure>
<figure><img src="/imgs/column/ai/1_6.webp" alt="AI生成的ColorPicker" tabindex="0" loading="lazy"><figcaption>AI生成的ColorPicker</figcaption></figure>
<p>AI生成的ColorPicker 谷歌市场下载地址 -&gt; <a href="https://play.google.com/store/apps/details?id=com.git.hui.colorpicker.google" target="_blank" rel="noopener noreferrer">https://play.google.com/store/apps/details?id=com.git.hui.colorpicker.google</a></p>
<ol>
<li>根据上传的图片，识别指定位置的图片颜色的工具</li>
<li>特点：一个完全由AI设计原型、实现业务逻辑细节，并且最终打包为Android APP，集成Admob广告，并上架谷歌应用市场，走通app的开发到上线全流程</li>
</ol>
<h2> 3. ColorPicker的历程</h2>
<p>接下来我将回顾一下 ColorPicker 的诞生历程 <a href="https://github.com/liuyueyi/ai-color-picker/commits/main/" target="_blank" rel="noopener noreferrer">https://github.com/liuyueyi/ai-color-picker/commits/main/</a></p>
<figure><img src="/imgs/column/ai/1_7.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol>
<li>
<p>3.11 号确定应用的主体功能、展现形式，开始编码
• a. 功能：图片提色
• b. 展现形式：wap应用 + 小程序 + app
• c. 技术栈：基于uniapp的技术栈来实现一套代码，多端生成
• d. 编程工具：HBuilder + AndroidStudio + Trae</p>
</li>
<li>
<p>3.12 号完成主体业务功能</p>
</li>
<li>
<p>3.13 号打包到apk，到android进行运行，尝试集成谷歌广告；并提交谷歌应用市场</p>
</li>
<li>
<p>3.14 号谷歌应用市场审批通过；开始第二版的迭代更新 a. 第二版新增：颜色搜索功能、分组、系统推荐色等能力</p>
</li>
<li>
<p>3.15 号解决uniapp上架到谷歌应用市场之后下载安装白屏问题（uniapp的bug)</p>
</li>
</ol>
<p>从想法诞生到最终的落地实现，基本上在五天内（其中app的相干样式适配、广告集成等问题最少花了两天😂），排除android相关的一些改造，其他的内容99.9%的内容全部由Trae来提供支撑，通过实际体验，“人人都是程序员”好像还挺容易成真的；</p>
<p>事后我重新复盘了一下这个开发过程，我将尝试以最大的可能性，给不是程序员这一行的小伙伴，介绍一条可以完全按照自己的想法设计app的小路，让你的创业不再停留在“就缺一个程序员”上了</p>
<h2> 4. 人人都是程序员专栏</h2>
<p>按照个人经验，拟定的专栏内容如下：（当然什么时候更新，我也无法给出肯定的承诺，欢迎关注公众号“一灰灰blog”蹲守第一手信息）</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/ai/1_1.webp" type="image/webp"/>
    </item>
    <item>
      <title>2. 图文手把手教你由0到1基于AI完成“垃圾消除小游戏”</title>
      <link>https://ppai.top/ai-guides/tutorial/ai-coding/02.%E4%BB%8E0%E5%88%B01%E5%9F%BA%E4%BA%8EAI%E7%94%9F%E6%88%90%E5%B0%8F%E6%B8%B8%E6%88%8F.html</link>
      <guid>https://ppai.top/ai-guides/tutorial/ai-coding/02.%E4%BB%8E0%E5%88%B01%E5%9F%BA%E4%BA%8EAI%E7%94%9F%E6%88%90%E5%B0%8F%E6%B8%B8%E6%88%8F.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">2. 图文手把手教你由0到1基于AI完成“垃圾消除小游戏”</source>
      <description>上一篇文章 首个完全由AI生成的APP上架啦 - ColorPicker 被喷得有点惨，本来是想分享一下最近使用AiCoding的探索发现，结果被好些大佬说是 “毫无技术含量、全是生产互联网垃圾”。说实话，看到这些评论还有点伤心，毕竟八年技术分享无人问，一朝水文大众喷。 虽然不被技术大咖认可，但我的初衷依然和上篇文章回复保持一致</description>
      <category>AI</category>
      <pubDate>Sat, 29 Mar 2025 21:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>上一篇文章  <a href="https://mp.weixin.qq.com/s/qtxF-vnUeKrp9BZZRaeeSw" target="_blank" rel="noopener noreferrer">首个完全由AI生成的APP上架啦 - ColorPicker</a>  被喷得有点惨，本来是想分享一下最近使用AiCoding的探索发现，结果被好些大佬说是 “毫无技术含量、全是生产互联网垃圾”。说实话，看到这些评论还有点伤心，毕竟八年技术分享无人问，一朝水文大众喷。</p>
<p>虽然不被技术大咖认可，但我的初衷依然和上篇文章回复保持一致</p>
<figure><img src="/imgs/column/ai/2-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>既然大家都说没有技术难度、是在制造互联网垃圾，那正好可以拿这个主题来校验一下，搞一个毫无技术难度的垃圾消除游戏，下面完整记录这个AICoding生成的游戏全过程，给对这方面感兴趣的小伙伴一个路线参考</p>
<p>全程挑战一下，由AI来生成一个毫无技术难度的小游戏 -- 羊了个羊-垃圾消除版，并分别生成wap版/小程序版/apk版输出</p>
<blockquote>
<p>点击试玩： <a href="https://ai.hhui.top/sheepgame/#/" target="_blank" rel="noopener noreferrer">https://ai.hhui.top/sheepgame/#/</a></p>
</blockquote>
<p>首先是技术栈与开发工具如下：</p>
<p>Uniapp</p>
<p>HBuilder + Trae + Android Studio + 微信小程序开发</p>
<h2> 一、初始化一个项目工程</h2>
<p>打开HBuilder，依次点击：</p>
<h3> 1. 新建项目</h3>
<p>方案1：文件 -&gt; 新建 -&gt; 项目</p>
<figure><img src="/imgs/column/ai/2-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>方案2：点击快速创建项目的按钮，如下图</p>
<figure><img src="/imgs/column/ai/2-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 指定项目信息</h3>
<ul>
<li>由于我们希望一套代码，多端运行（wap--手机浏览器，小程序，APP），因此最左边选择 uni-app</li>
<li>输入项目名、存储路径，选择应用模板</li>
</ul>
<figure><img src="/imgs/column/ai/2-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 使用Trae加载上面的工程</h3>
<ul>
<li>打开应用，会看到下面的截图</li>
<li>然后点击打开文件夹 -- 找到上面生成工程指定的文件夹，选中即可</li>
</ul>
<p><img src="/imgs/column/ai/2-5.webp" alt="" loading="lazy">
<img src="/imgs/column/ai/2-6.webp" alt="" loading="lazy"></p>
<p>此时我们的前置准备工作已经完成，即将进入正式的AICoding阶段</p>
<h2> 二、AICoding阶段</h2>
<h3> 1. 首先在HBuilder上运行一下项目</h3>
<ol>
<li>点击下图中所示的播放图标</li>
<li>在弹出的下拉框中，选择 运行到 Chrome</li>
</ol>
<figure><img src="/imgs/column/ai/2-7.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后你就会看到一个自动打开了一个浏览器，内容长下面这样</p>
<figure><img src="/imgs/column/ai/2-8.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>因为我们的目标输出是基于手机玩耍的小游戏，因此我们可以在浏览器这里按住F12/或者鼠标右键，点击检查，进入开发者模式</p>
<figure><img src="/imgs/column/ai/2-9.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>按照下图的方式进入移动视角</p>
<figure><img src="/imgs/column/ai/2-10.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 进入Trae，让他帮我们生成小游戏</h3>
<ol>
<li>在编辑器的右边AI对话框中，选择 Builder模式，大模型选择 Claude-3.7-Sonnet</li>
</ol>
<figure><img src="/imgs/column/ai/2-11.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="2">
<li>开始提问，给出我们的诉求，下面的描述文案没有任何修辞，就是普通的大白话(毫无技巧可言）</li>
</ol>
<figure><img src="/imgs/column/ai/2-12.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后我们就等待大模型帮我们生成各种代码，在这个过程中，会不断的出现下面这种询问你<strong>是否接受</strong>的情况，一路无脑选择<strong>全部接受</strong>即可</p>
<figure><img src="/imgs/column/ai/2-13.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在最后输出完成之后，它想要运行项目，查看实现的羊了个羊游戏效果；因为我们是HBuilder进行预览，所以直接拒绝它就行</p>
<figure><img src="/imgs/column/ai/2-14.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后我们切换回上一步打开的Chrome浏览器，看看效果；结果很不幸的是并不是我们预期的内容</p>
<figure><img src="/imgs/column/ai/2-15.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 错误调试阶段</h3>
<blockquote>
<p>小概率情况，首次生成的内容不可用，我们需要将对应的错误喂给大模型，让他自己去修复</p>
</blockquote>
<p>上面这种样式，表示生成的代码有问题，那么我们就直接告诉它，修改这些问题</p>
<ul>
<li>将上面的错误截图，丢到对话框，直接让Claude来修正</li>
</ul>
<figure><img src="/imgs/column/ai/2-16.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如果你有编程经验的话，上面这种问题实际上也很好发现，如我们看下它生成的代码</p>
<ul>
<li>正常的代码，标签都是配套出现的，这里 只有<code>&lt;script&gt;</code> 没有<code>&lt;/script&gt;</code>； 只有 <code>&lt;/style&gt;</code> 没有开头的<code>&lt;style&gt;</code></li>
</ul>
<figure><img src="/imgs/column/ai/2-17.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>等上面修复完毕之后，我们在看看Chrome浏览器的运行情况</p>
<ul>
<li>第一张图，为启动页</li>
<li>第二张图为开始游戏之后的页面（没有出现预期的游戏画面，需要我们继续进行调试）</li>
<li>第三张图为游戏介绍页面</li>
</ul>
<figure><img src="/imgs/column/ai/2-18.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>虽然功能还不齐全，但至少没有报错了，UI美化的问题我们放在最后；接下来我们重点调教一下游戏界面</p>
<h3> 4. 游戏界面显示调教</h3>
<p>我们直接对话让它进行修改，这个过程可能需要多轮对话（对于小白而言，这个过程就只能看玄学了，当然如果你掌握一些编程基础，也可以快速发现问题，让后针对性的让AI进行修正）</p>
<figure><img src="/imgs/column/ai/2-19.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>实际不展示游戏区域的原因并不是上面第一轮截图提示的钩子问题，而是样式的问题（大多数白屏都是样式原因导致的）</p>
<figure><img src="/imgs/column/ai/2-20.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>当我们将游戏区域换出来之后发现底部的候选区域当前页显示不出来，还需要下滑；说明游戏区域太大了，我们可以调整一下游戏区域的高度，比如最高占屏幕的 2/3； 其次就是每个卡片太大了，也需要调整一下</p>
<p>然后开始新一轮的样式调整</p>
<figure><img src="/imgs/column/ai/2-21.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>调整完毕之后再看看效果，比之前要好一点了，当然依然存在问题，部分卡片超出游戏区域了，没关系继续让它调整</p>
<figure><img src="/imgs/column/ai/2-22.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 5. 游戏逻辑调教</h3>
<p>我们需要修复一些游戏性的问题：</p>
<ul>
<li>如游戏模式，取消倒计时；改为候选区域填满表示游戏失败</li>
<li>比如同一层的卡片，不应该存在位置重叠的情况</li>
<li>为了更好的游戏性，可以固定限制相邻两层的间距为1/2个卡片</li>
</ul>
<figure><img src="/imgs/column/ai/2-23.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后再游戏试玩的过程中，你还会发现其他的一些问题，比如（底部卡槽填满了，没有告诉用户失败； 卡片明显被遮挡但是又可以被选中等）</p>
<ul>
<li>发现问题不要怕，一给个让它改就行，默默安慰自己享受老板吩咐人干活的快感吧~</li>
</ul>
<figure><img src="/imgs/column/ai/2-24.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>下面是一些游戏逻辑相关的改造问答，就不详细列举了</p>
<figure><img src="/imgs/column/ai/2-25.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>一些调整之后，我们再看看最终的效果</p>
<figure><img src="/imgs/column/ai/2-26.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 6. UI样式调整</h3>
<p>到应用商店，找一下羊了个羊的官方宣传图，或者下载游戏截个图，丢给trae来调整下整体布局样式，使其更美观一点</p>
<figure><img src="/imgs/column/ai/2-27.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>整体调整之后，比之前稍微好看一点了，不满意的小伙伴可以继续进行调教； 为了更贴合主题，我们将卡片的icon，从现在的动物换成各种垃圾</p>
<figure><img src="/imgs/column/ai/2-28.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>最后再整体调整一下游戏的各个布局（包括开始界面，游戏卡片中图标的大小，游戏logo等），改完之后我们完整的体验一下这个 “垃圾消除游戏”</p>
<p>找豆包，帮我生成icon的文生图提示词；然后再用豆包的文生图获取我们的游戏logo</p>
<figure><img src="/imgs/column/ai/2-29.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>第一次生成的图片不适合作为app的icon，需要更简约一点，就简单的调整下,一次不行多试几次</li>
</ul>
<p>基本功能完成，接下来我们整体体验一下这个垃圾小游戏</p>
<blockquote>
<p>打开公众号原文，体验视频的演示效果： <a href="https://mp.weixin.qq.com/s/mu9l0y18mNE3PlI8EQhrYw" target="_blank" rel="noopener noreferrer">
毫无技术难度：由0到1基于AI完成“垃圾消除小游戏”
</a></p>
</blockquote>
<h2> 三、小结</h2>
<p>这一篇主要通过图文的方式，演示了如何借助Trae来从0到1实现一个小游戏；接下来我们如何将同样通过图文的方式，手把手教你将上面实现的小游戏，打包上线，请看下一篇</p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/ai/2-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>3. 图文教你打包基于AI完成“垃圾消除小游戏”</title>
      <link>https://ppai.top/ai-guides/tutorial/ai-coding/03.%E4%BB%8E0%E5%88%B01%E6%95%99%E4%BD%A0%E6%89%93%E5%8C%85AI%E7%94%9F%E6%88%90%E7%9A%84%E5%B0%8F%E6%B8%B8%E6%88%8F.html</link>
      <guid>https://ppai.top/ai-guides/tutorial/ai-coding/03.%E4%BB%8E0%E5%88%B01%E6%95%99%E4%BD%A0%E6%89%93%E5%8C%85AI%E7%94%9F%E6%88%90%E7%9A%84%E5%B0%8F%E6%B8%B8%E6%88%8F.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">3. 图文教你打包基于AI完成“垃圾消除小游戏”</source>
      <description>上一篇使用图文的方式演示了如何从0到1借助ai生成一个可运行的小游戏，接下来我将通过图文的方式，手把手教你将上面生成的小游戏，打包出来供其他人玩耍 接下来将分别介绍常见的三种打包发行方式 接下来的动作将主要在HBuilder中执行 一、打包成H5游戏 h5游戏，主要用于浏览器直接访问玩耍，需要配置域名，没有域名的小伙伴，可以考虑一些云服务的PAGES服务来实现，接下来介绍下Cloudflare的托管部署方式 Step1. 打包 Hbuilder ，一次点击 发行 -&amp;gt; 网站PC Web 或手机H5 如果出现下面的异常，则按照下图方式进行修正</description>
      <category>AI</category>
      <pubDate>Sat, 29 Mar 2025 21:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>上一篇使用图文的方式演示了如何从0到1借助ai生成一个可运行的小游戏，接下来我将通过图文的方式，手把手教你将上面生成的小游戏，打包出来供其他人玩耍</p>
<p>接下来将分别介绍常见的三种打包发行方式</p>
<blockquote>
<p>接下来的动作将主要在HBuilder中执行</p>
</blockquote>
<h2> 一、打包成H5游戏</h2>
<p>h5游戏，主要用于浏览器直接访问玩耍，需要配置域名，没有域名的小伙伴，可以考虑一些云服务的PAGES服务来实现，接下来介绍下Cloudflare的托管部署方式</p>
<h3> Step1. 打包</h3>
<p>Hbuilder ，一次点击 发行 -&gt; 网站PC Web 或手机H5 如果出现下面的异常，则按照下图方式进行修正</p>
<figure><img src="/imgs/column/ai/3-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>打开项目下的 manifest.json 文件</li>
<li>在右边的视图中，点击重新获取按钮
<ul>
<li>如果没有登录的，会让你输入unicod的账号密码，登录即可</li>
<li>成功之后，就会得到下面3所示的AppID</li>
</ul>
</li>
</ul>
<figure><img src="/imgs/column/ai/3-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上面问题修复之后，再次进行打包，正确的样式如下</p>
<ul>
<li>因为接下来的演示是基于Cloudflare进行托管，所以下面的域名可以先随便填一个</li>
</ul>
<figure><img src="/imgs/column/ai/3-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后进入上面的输出目录，将目录下的内容打包为zip文件，如下图操作</p>
<figure><img src="/imgs/column/ai/3-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> Step2. 发行Cloudflare</h3>
<blockquote>
<p>没有账号的小伙伴自行注册，后续教程给出完整的注册使用流程，敬请蹲守一波😄</p>
</blockquote>
<ul>
<li>直接进入 Workers &amp; Pages 目录</li>
<li>点击create按钮，进入创建应用页面</li>
<li>切换Tab页到Pages -&gt; 点击Upload assets -&gt; 进入发布页面</li>
<li>输入项目名，此时会自动给你分配一个访问域名</li>
<li>接着上传zip压缩包</li>
<li>最后点击发布按钮</li>
</ul>
<figure><img src="/imgs/column/ai/3-5.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>发布成功的页面如下，我们可以直接点击域名，看一下效果（重点说明一下：上传的压缩包，请确保index.html在最外层）</p>
<figure><img src="/imgs/column/ai/3-6.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>直接点击上面的域名，就可以访问我们的小游戏啦</p>
<ul>
<li>域名是： <a href="https://sheepremove.pages.dev/" target="_blank" rel="noopener noreferrer">https://sheepremove.pages.dev/</a></li>
</ul>
<figure><img src="/imgs/column/ai/3-7.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> Step3. 发行到自己的服务器或者OSS托管</h3>
<p>当然如果你有自己的服务器或者OSS，也是可以将h5游戏部署上去的，下面简单介绍下将H5游戏托管到免费的七牛云空间下</p>
<ol>
<li>首先在oss上，创建对应的目录空间，如 /app/sheepremove</li>
</ol>
<figure><img src="/imgs/column/ai/3-8.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="2">
<li>修改HBuilder中web打包的输出前缀</li>
</ol>
<ul>
<li>manifest.json 文件 -&gt; web配置 -&gt; 运行的基础路径</li>
<li>启用https协议这个看你自己的托管域名，支不支持https，支持就选中；不支持就取消</li>
<li>然后重新发行一次： 菜单发行 -&gt; 网站-PC</li>
</ul>
<figure><img src="/imgs/column/ai/3-9.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="3">
<li>上传文件到七牛云</li>
</ol>
<blockquote>
<p>注意此时是文件的形式上传，不用之前的zip压缩包了</p>
</blockquote>
<figure><img src="/imgs/column/ai/3-10.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="4">
<li>体验一下</li>
</ol>
<blockquote>
<p><a href="http://cdn.hhui.top/app/sheepremove/index.html" target="_blank" rel="noopener noreferrer">http://cdn.hhui.top/app/sheepremove/index.html</a></p>
</blockquote>
<figure><img src="/imgs/column/ai/3-11.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 二、打包成微信小游戏</h2>
<blockquote>
<p>接下来我们看一下将上面的垃圾小游戏生成微信小游戏来体验一下，此时我们需要借助微信开发工具</p>
</blockquote>
<h3> Step1: 微信开发者工具，生成appid</h3>
<ul>
<li>将生成的appid记录出来，后续打包时会用到</li>
<li>注意：这里选择小程序，如果选择小游戏时，uniapp输出到微信时会报错</li>
</ul>
<figure><img src="/imgs/column/ai/3-12.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> Step2: 打包微信小程序</h3>
<p>配置小程序AppID</p>
<figure><img src="/imgs/column/ai/3-13.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>case1：运行小程序</strong></p>
<figure><img src="/imgs/column/ai/3-14.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后hbuilder会自动打开微信开发者工具，启动我们的 垃圾消除游戏 , 如下图</p>
<figure><img src="/imgs/column/ai/3-15.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<blockquote>
<p>说明：多平台时，可能出现各种奇怪的问题，需要针对性的进行提问解决 如：在微信小程序运行时，也出现了一个小问题，游戏区域未显示，同样将问题抛给Trae来修复</p>
</blockquote>
<figure><img src="/imgs/column/ai/3-16.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>case2: 发行小程序</strong></p>
<p>这种场景适用于我们开发完毕，准备提交给微信后台去申请上线，流程如下（由于没准备上线小程序，所以就不演示小程序上线流程了，放在后续的教程进行介绍）</p>
<figure><img src="/imgs/column/ai/3-17.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 三、打包成Android app</h2>
<p>接下来我们再来演示一下如何将上面的小游戏打包成android 应用包</p>
<h3> Step1: uniapp开发者后台配置签名</h3>
<p>首先进入开发者后台：<a href="https://dev.dcloud.net.cn/pages/app/list" target="_blank" rel="noopener noreferrer">https://dev.dcloud.net.cn/pages/app/list</a></p>
<p>然后点击应用，进入详情：</p>
<ul>
<li>各平台信息 -&gt; 点击新增</li>
<li>进入编辑页，依次补齐下面几个信息</li>
<li>Android App</li>
<li>正式版/测试版 -- 都可以</li>
<li>包名：打包出来的签名，按照惯性约定命名即可</li>
<li>应用签名 SHA1, SHA256 ---&gt; 这个是基于你打包时的签名证书生成的 （后续android输出篇教程详细介绍）</li>
</ul>
<figure><img src="/imgs/column/ai/3-18.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>配置完毕之后，点击提交，返回应用列表</p>
<ul>
<li>点击创建离线Key，再弹窗中点击创建</li>
<li>然后应用列表的按钮变成查看离线key</li>
<li>然后保存弹窗出来的appid</li>
</ul>
<figure><img src="/imgs/column/ai/3-19.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> Step2: 打包生成Android的离线资源</h3>
<ul>
<li>菜单点击发行</li>
<li>依次执行 App-Andoird/IOS-本地打包 -&gt; 生成本地打包App资源</li>
</ul>
<figure><img src="/imgs/column/ai/3-20.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> Step3: AndroidStudio实现apk输出</h3>
<p>这里直接使用我已经封装好的Android基础工程，跳过基于uniapp的原始项目工程的改造过程；我们接下来看一下如何基于这个基础工程来生成我们的apk包</p>
<p>1.拷贝资源</p>
<ul>
<li>进入android项目的 simpleDemo/src/main/assets/apps 目录</li>
<li>删除目录下的文件</li>
<li>将上面hbuilder生成的资源拷贝进来</li>
</ul>
<figure><img src="/imgs/column/ai/3-21.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="2">
<li>修改data/dcloud_control.xml中的appid</li>
</ol>
<p>将appid改为上面文件夹名（也可以直接在uniapp的后台查看appid)</p>
<figure><img src="/imgs/column/ai/3-22.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="3">
<li>修改AndroidManifest.xml中包名和dcloud_appkey</li>
</ol>
<ul>
<li>package：Step2中填的包名</li>
<li>appKey: Step2中获取的离线key</li>
</ul>
<figure><img src="/imgs/column/ai/3-23.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="4">
<li>修改build.gradle中的包名</li>
</ol>
<ul>
<li>Namespace: 上面的包名</li>
<li>applicationid：上面的包名</li>
</ul>
<figure><img src="/imgs/column/ai/3-24.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="5">
<li>修改应用名和logo</li>
</ol>
<ul>
<li>应用名：res/values/strings.xml 文件中 app_name</li>
</ul>
<figure><img src="/imgs/column/ai/3-25.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>logo:  res/drawable 下的 icon.9.png</li>
</ul>
<p>将前面生成的icon，拷贝到上面的drawable目录下，然后删除原来的icon.9.png</p>
<figure><img src="/imgs/column/ai/3-26.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="6">
<li>打包 - 步骤如下：</li>
</ol>
<ul>
<li>菜单，点击 Build</li>
<li>在下拉框中，选择 Generate Signed App Bundle/APK</li>
<li>选择APK</li>
<li>点击Next</li>
<li>输入打包证书地址、密码、别名等信息</li>
<li>选择release</li>
<li>点击create，等待下面打包成功的提示</li>
<li>在 simpleDemo/release 目录下可以看到输出的apk包</li>
</ul>
<figure><img src="/imgs/column/ai/3-27.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> Step4：安装体验</h3>
<p>直接用手机安装一下上面的apk，下面是实际的体验视频（在视频中你也会发现打开会有版本的弹窗提示，这个是uniapp的提醒，可以消除掉；以及android端的样式还需要调整下，这里就不详细展开了）</p>
<p>有兴趣体验的小伙伴，可以下载apk:（说明，这个安装包中集成了谷歌的测试广告，后续在apk打包篇中会介绍如何给应用加上广告变现）</p>
<ul>
<li><a href="http://cdn.hhui.top/app/sheepremove/%E5%9E%83%E5%9C%BE%E6%B6%88%E9%99%A4%E5%B0%8F%E6%B8%B8%E6%88%8F.apk" target="_blank" rel="noopener noreferrer">APK下载地址: </a></li>
</ul>
<p>演示视频，原文查看: - <a href="https://mp.weixin.qq.com/s/mu9l0y18mNE3PlI8EQhrYw" target="_blank" rel="noopener noreferrer">毫无技术难度：由0到1基于AI完成“垃圾消除小游戏”</a></p>
<h2> 四、小结</h2>
<p>这个垃圾消除小游戏的开动到apk的手机完整运行，再加上完成本篇文章，总计耗时 5 小时左右，说长不长，说短不短。</p>
<p>上面小游戏的所有代码全部由AI生成，我主要发挥的作用就是给ai喂我的想法、以及适当的告诉它怎么解决问题（有时候ai解决问题的速度有点让人难受），一个完整的流程下来，编程小白想要完成一个自己的h5/小程序/app游戏可能有点挑战，但是耐心怼一波，也不是不可能出现奇迹</p>
<p>最后我想说的一点是，AI正在飞速发展，作为一个十年的互联网的coder真心希望所有的程序员不要傲慢，你可能认为AICoding还很初级、经常制造各种垃圾，但不得不说现如今AiCoding已经对初级程序员已经发起了挑战，同时也为所有的非程序员，打开了一个实现自己想法/产品的大门。</p>
<p>我是一灰灰，后续我将会给大家带来更多的AICoding的系列教程，比如上面提到但是没有展开的</p>
<p>• 各编程工具的安装、调试、基本使用姿势介绍
• 项目开发管理的阶段性保存方案
• H5托管相关知识点：CloudFlare、GitHub Pages、自己专属服务器托管，接入Google AdSense变现
• 微信小程序的发包上线全流程
• Android的广告集成相关</p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/ai/3-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>4. 不借助AI也可以实现图片转线稿</title>
      <link>https://ppai.top/ai-guides/tutorial/ai-coding/04.%E4%B8%8D%E5%80%9F%E5%8A%A9AI%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E8%BD%AC%E7%BA%BF%E7%A8%BF.html</link>
      <guid>https://ppai.top/ai-guides/tutorial/ai-coding/04.%E4%B8%8D%E5%80%9F%E5%8A%A9AI%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E8%BD%AC%E7%BA%BF%E7%A8%BF.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">4. 不借助AI也可以实现图片转线稿</source>
      <description>最近准备实现一个根据图片生成简笔画的应用，研究了下现在的ai能力，在使用百度的图片提取线稿的时候发现AI处理能力是真的强，比如下面是几个提取case 从整体的实现效果来看，还是非常不错的，对于现实人物、3d图、2d卡通、建筑的线稿提取结果可以说几近完美了。唯一的小问题就是处理时间长了一点，也不免费... 那么有没有其他开源的工具可以直接使用呢，发现了两个有意思的开源项目，一个是基于机器学习训练结果的，另一个则是直接使用算法(代码行&amp;lt;50行)进行提取转换</description>
      <category>AI</category>
      <pubDate>Wed, 11 Jun 2025 10:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>最近准备实现一个根据图片生成简笔画的应用，研究了下现在的ai能力，在使用百度的图片提取线稿的时候发现AI处理能力是真的强，比如下面是几个提取case</p>
<figure><img src="/imgs/column/ai/4-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从整体的实现效果来看，还是非常不错的，对于现实人物、3d图、2d卡通、建筑的线稿提取结果可以说几近完美了。唯一的小问题就是处理时间长了一点，也不免费...</p>
<p>那么有没有其他开源的工具可以直接使用呢，发现了两个有意思的开源项目，一个是基于机器学习训练结果的，另一个则是直接使用算法(代码行&lt;50行)进行提取转换</p>
<h3> 基于训练模型 rocca/informative-drawings-line-art-onnx</h3>
<p>模型地址-&gt; <a href="https://huggingface.co/rocca/informative-drawings-line-art-onnx" target="_blank" rel="noopener noreferrer">https://huggingface.co/rocca/informative-drawings-line-art-onnx</a></p>
<p>项目源码：<a href="https://github.com/josephrocca/image-to-line-art-js" target="_blank" rel="noopener noreferrer">https://github.com/josephrocca/image-to-line-art-js</a></p>
<p>使用约17兆的模型即可实现线图提取功能，下面是官方的demo表现情况</p>
<figure><img src="/imgs/column/ai/4-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从上面的处理结果也可以看出，对于卡通图像的转换效果还是可以的；但是对于显示人物、建筑之类的效果就一一般般了</p>
<h3> 算法提取</h3>
<p>项目源码：<a href="https://github.com/FlandreDaisuki/Outline-Extractor" target="_blank" rel="noopener noreferrer">Outline-Extractor</a></p>
<p>核心算法</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在线体验地址: <a href="https://ai.hhui.top/app/imgline.html" target="_blank" rel="noopener noreferrer">https://ai.hhui.top/app/imgline.html</a></p>
<p>整体表现效果如下:</p>
<figure><img src="/imgs/column/ai/4-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从实际的效果来看，和上面的训练模型的处理结果半斤八两，不过好处也很明显，处理效率明显更高，且无外部依赖</p>
<h3> 小结</h3>
<p>下面是具体的对照结果，对于卡通图片，如果希望提取线稿，会发现即便不使用大模型、机器学习的能力，借助最基础的算法处理，不超过50行的代码也可以实现相对理想的效果</p>
<table>
<thead>
<tr>
<th>原图</th>
<th>百度提取线图</th>
<th>训练模型处理</th>
<th>算法提取</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/imgs/column/ai/4-4-0.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-b-0.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-t-0.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-s-0.jpg" alt="" loading="lazy"></td>
</tr>
<tr>
<td><img src="/imgs/column/ai/4-4-1.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-b-1.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-t-1.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-s-1.jpg" alt="" loading="lazy"></td>
</tr>
<tr>
<td><img src="/imgs/column/ai/4-4-2.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-b-2.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-t-2.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-s-2.jpg" alt="" loading="lazy"></td>
</tr>
<tr>
<td><img src="/imgs/column/ai/4-4-3.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-b-3.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-t-3.jpg" alt="" loading="lazy"></td>
<td><img src="/imgs/column/ai/4-4-s-3.jpg" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/ai/4-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>5. 浏览器中跑大模型-搭建一个自动抠图服务</title>
      <link>https://ppai.top/ai-guides/tutorial/ai-coding/05.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%B7%91%E5%A4%A7%E6%A8%A1%E5%9E%8B-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E6%8A%A0%E5%9B%BE%E6%9C%8D%E5%8A%A1.html</link>
      <guid>https://ppai.top/ai-guides/tutorial/ai-coding/05.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%B7%91%E5%A4%A7%E6%A8%A1%E5%9E%8B-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E6%8A%A0%E5%9B%BE%E6%9C%8D%E5%8A%A1.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">5. 浏览器中跑大模型-搭建一个自动抠图服务</source>
      <description>抠图的场景大家应该很熟悉了，使用大模型来抠图也属于很常见的功能了，但是在操作一些相对隐私的图片总会有一点点担心。那么在自己的电脑上跑一个大模型？ 电脑的性能够呛！ 难道就没有什么离线的大模型可以用嘛？ 相信很多小伙伴都听过Transformers.js，一个JavaScript库，它允许开发者在浏览器或Node.js环境中使用Hugging Face的预训练机器学习模型，无需服务器支持 最近花了一点时间（主要是借助豆包）来写了一个网页，支持在浏览器本地直接跑RMBG V1.4模型，实现离线的智能抠图功能。 下来看看整体的表现情况</description>
      <category>AI</category>
      <pubDate>Fri, 13 Jun 2025 17:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>抠图的场景大家应该很熟悉了，使用大模型来抠图也属于很常见的功能了，但是在操作一些相对隐私的图片总会有一点点担心。那么在自己的电脑上跑一个大模型？ 电脑的性能够呛！ 难道就没有什么离线的大模型可以用嘛？</p>
<p>相信很多小伙伴都听过<code>Transformers.js</code>，一个JavaScript库，它允许开发者在浏览器或Node.js环境中使用Hugging Face的预训练机器学习模型，无需服务器支持</p>
<p>最近花了一点时间（主要是借助豆包）来写了一个网页，支持在浏览器本地直接跑RMBG V1.4模型，实现离线的智能抠图功能。 下来看看整体的表现情况</p>
<figure><img src="/imgs/column/ai/5-1.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>支持本地上传图片、粘贴上传图片、拖拽上传图片三种方式；首次访问网页时，会自动下载大模型(约40M)，下载成功之后会在提示区域显示“模型已加载完成”，之后所有的操作将基于用户的浏览器进行操作，无后端交互，隐私无忧</p>
<figure><img src="/imgs/column/ai/5-2.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 实际体验</h3>
<p>有兴趣的小伙伴可以实际体验，访问地址：<a href="https://ai.hhui.top/app/rmBg.html" target="_blank" rel="noopener noreferrer">https://ai.hhui.top/app/rmBg.html</a></p>
<p>它的核心玩法很简单粗暴：</p>
<ol>
<li>打开网页。</li>
<li>选择本地图片（或拖拽或粘贴一个图片）。</li>
<li>点击开始处理图片</li>
<li>几秒后（看图片大小和机器性能），抠好的图直接显示/下载。</li>
</ol>
<figure><img src="/imgs/column/ai/5-3.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><strong>这体验就丝滑了：</strong></p>
<ul>
<li><strong>速度起飞：</strong> 省了上传下载的大头时间，处理速度就看用户本机CPU/GPU了。</li>
<li><strong>隐私拉满：</strong> 用户数据本地处理，安全感爆棚，合规风险骤降。</li>
<li><strong>零成本调用：</strong> 对开发者/服务提供方来说，没有图片传输的带宽成本，没有按次调用的API费用，服务器压力？不存在的！</li>
<li><strong>开箱即用：</strong> 用户不用装软件，不用注册，打开就用，用完就走。</li>
</ul>
<h3> 关键技术说明</h3>
<p>怎么做到的？关键点在这儿（技术老铁们看过来）：</p>
<ol>
<li><strong>模型本地化：</strong> 这个网页背后，在首次加载时（或按需），把训练好的抠图模型（onnx）<strong>直接下载到了用户的浏览器缓存里</strong>。模型大小约40M，百兆网速的小伙伴也就是几秒的加载时间。</li>
<li><strong>浏览器内推理引擎：</strong> 依靠的是强大的 <strong><code>transformers.js</code></strong> 。它们提供了在浏览器JavaScript环境中直接加载和运行AI模型的能力。</li>
</ol>
<p>对咱们开发者有啥启发？</p>
<ol>
<li><strong>边缘计算的魅力：</strong> 这就是“边缘计算”在Web端的生动体现啊！把计算负载从中心服务器下放到终端设备（浏览器），解决延迟、隐私、成本问题。想想看，除了抠图，像简单的图像分类、风格迁移、文本摘要、甚至轻量级的语音识别，是不是都有可能搬到浏览器里？</li>
<li><strong>Web ML 生态成熟：</strong> <code>transformers.js</code>、ONNX Runtime Web、TensorFlow.js 这些工具链越来越成熟，让在Web端部署和运行（尤其是优化后的）模型不再是天方夜谭。前端工程师的武器库又丰富了！</li>
<li><strong>用户体验新思路：</strong> 对于需要处理用户本地数据的应用（图片、文档、音视频片段），<strong>“本地优先”</strong> 的处理策略能极大提升用户体验和信任度。这个抠图工具就是个很好的样板。</li>
<li><strong>模型优化是王道：</strong> 浏览器环境资源有限（内存、算力），模型必须<strong>轻量化、高效化</strong>。这倒逼我们在模型设计、剪枝、量化、格式转换上做更多优化工作。</li>
</ol>
<p><strong>值得一试吗？</strong></p>
<p>当然！无论你是：</p>
<ul>
<li><strong>好奇宝宝：</strong> 想看看浏览器里跑模型到底啥感觉？</li>
<li><strong>前端攻城狮：</strong> 想探索Web ML的可能性边界？</li>
<li><strong>后端/全栈：</strong> 在琢磨如何降低服务端负载、优化成本结构？</li>
<li><strong>产品经理：</strong> 在寻找提升用户体验、增强隐私卖点的方案？</li>
</ul>
<p>这个网页都值得你点开玩一玩：<strong><a href="https://ai.hhui.top/app/rmBg.html" target="_blank" rel="noopener noreferrer">https://ai.hhui.top/app/rmBg.html</a></strong></p>
<p><strong>实际体验感受：</strong></p>
<ul>
<li>首次加载可能需要下载模型（40MB级别），有点耐心。</li>
<li>抠图速度取决于你电脑性能，实测普通照片几秒到十几秒搞定，效果在浏览器里跑成这样相当不错了（当然不能和顶级桌面软件比）。</li>
<li>最大的爽点：图片真的没上传！打开浏览器开发者工具 - 网络（Network）标签页，你会看到除了加载网页本身和模型文件，<strong>处理过程中没有任何图片上传的请求！</strong> 这感觉，踏实。</li>
</ul>
<p><strong>最后叨叨：</strong></p>
<p>这个网页虽然是个工具，但它展示的思路非常有价值。随着Web ML技术的进步和终端设备算力的提升，<strong>把更多AI能力“沉”到浏览器端</strong>，会是优化用户体验、降低成本、保护隐私的一个重要方向。对于隐私优先的小伙伴，不妨收藏一波😊</p>
<p><strong>链接再放一次，动手试试吧：</strong>
<a href="https://ai.hhui.top/app/rmBg.html" target="_blank" rel="noopener noreferrer">https://ai.hhui.top/app/rmBg.html</a></p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/ai/5-1.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>6. 基于Trae开发android原生应用，顺利上架谷歌应用市场</title>
      <link>https://ppai.top/ai-guides/tutorial/ai-coding/06.%E5%9F%BA%E4%BA%8ETrae%E5%BC%80%E5%8F%91android%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E5%B9%B6%E4%B8%8A%E6%9E%B6%E5%BA%94%E7%94%A8%E5%B8%82%E5%9C%BA.html</link>
      <guid>https://ppai.top/ai-guides/tutorial/ai-coding/06.%E5%9F%BA%E4%BA%8ETrae%E5%BC%80%E5%8F%91android%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E5%B9%B6%E4%B8%8A%E6%9E%B6%E5%BA%94%E7%94%A8%E5%B8%82%E5%9C%BA.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">6. 基于Trae开发android原生应用，顺利上架谷歌应用市场</source>
      <description>之前使用Trae开发的项目主要是基于web技术栈来搭建的，借助uniapp的生态体系，来生成多端可运行的应用，整体实现链路还是很顺畅的。但是最近准备开发一个android的小部件，需要使用原生的kotlin进行开发，发现直接使用Trae做原生开发，也意外的顺利 下来进行简单的记录一下，使用Trae进行原生开发的过程 一、应用预览 需要开发的应用本身比较简单，主要是为用户提供两种类型的小组件，文本小组件 + 计时小组件 支持用户在手机桌面上，添加一些豆腐块的文案/倒计时，用于装饰or提醒</description>
      <category>AI</category>
      <pubDate>Mon, 16 Jun 2025 17:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>之前使用Trae开发的项目主要是基于web技术栈来搭建的，借助uniapp的生态体系，来生成多端可运行的应用，整体实现链路还是很顺畅的。但是最近准备开发一个android的小部件，需要使用原生的kotlin进行开发，发现直接使用Trae做原生开发，也意外的顺利</p>
<p>下来进行简单的记录一下，使用Trae进行原生开发的过程</p>
<h2> 一、应用预览</h2>
<p>需要开发的应用本身比较简单，主要是为用户提供两种类型的小组件，文本小组件  + 计时小组件</p>
<p>支持用户在手机桌面上，添加一些豆腐块的文案/倒计时，用于装饰or提醒</p>
<figure><img src="https://ai.hhui.top/static/textwidget/s0.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>app体验地址： <a href="https://play.google.com/store/apps/details?id=com.github.hui.textwidget" target="_blank" rel="noopener noreferrer">https://play.google.com/store/apps/details?id=com.github.hui.textwidget</a></p>
<figure><img src="/imgs/column/ai/6-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 二、原生开发流程</h2>
<p>接下来我们看一下使用trae进行原生开发的流程，基本思路和之前介绍的 <a href="https://mp.weixin.qq.com/s/mu9l0y18mNE3PlI8EQhrYw" target="_blank" rel="noopener noreferrer">毫无技术难度：由0到1基于AI完成“垃圾消除小游戏”</a> 一致，只是部分具体的操作有些差异</p>
<h3> 1. 新建项目</h3>
<p>使用android studio创建一个空的项目</p>
<figure><img src="/imgs/column/ai/6-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在弹窗中，输入项目相关信息</p>
<figure><img src="/imgs/column/ai/6-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 2. 使用Trae打开项目</h3>
<p>使用trae打开刚才创建的项目，然后进行初始化</p>
<figure><img src="/imgs/column/ai/6-4.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>首先声明项目类型，然后给出指令，让trae帮我们自动生成对应的界面；</p>
<p>需要注意的时，首次进行kotlin开发时，trae对kotlin语言的支持不够友好，我们需要在插件市场中安装相关插件</p>
<figure><img src="/imgs/column/ai/6-5.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 3. 基于对话的功能实现</h3>
<p>因为这个app的设计非常简单，一个文本小部件、一个计时小部件；</p>
<p>因此核心的功能实现分两块</p>
<ul>
<li>小部件设置相关</li>
<li>小部件展示相关</li>
</ul>
<p>其中小部件的设置，主要是支持用户设置自己想要展示的文本、倒计时还是正计时，背景颜色、文字颜色、对齐方式等</p>
<figure><img src="/imgs/column/ai/6-6.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>小部件因为有两种不同的类型：文本 + 计时，因此我们也需要实现两个小部件</p>
<figure><img src="/imgs/column/ai/6-7.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<blockquote>
<p>说明：由于原生开发不像页面开发可以直接浏览器实时预览效果；原生开发过程中，我们需要不断的使用android studio查看生成的代码是否存在语法问题，借助Android Studio的模拟器来预览生成的效果</p>
</blockquote>
<figure><img src="/imgs/column/ai/6-8.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4. 打包上传</h3>
<p>相比较于uniapp的打包，原生开发就简单很多了，无需额外操作；直接在原生项目中打包即可</p>
<figure><img src="/imgs/column/ai/6-9.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 三、上架应用市场</h2>
<p>上架应用市场的流程之前介绍过，有兴趣的小伙伴可以翻一下</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/e3wZ7wMnKepm6R1Cz2DbAw?token=32118257&amp;lang=zh_CN" target="_blank" rel="noopener noreferrer">AI生成的垃圾小游戏-上架谷歌应用市场全流程-图文介绍</a></li>
</ul>
<p>我们在上架之前，先集成一下admob广告（赚一点是一点嘛），这里的广告集成与之前介绍的有一些区别，因为原生开发主要是基于Jetpack来实现的，因此我们的广告sdk的集成方式也需要相应的进行调整</p>
<p>比如新增一个底部的banner广告 ，直接在官方的demo扣过来，让trae进行二次改造</p>
<figure><img src="/imgs/column/ai/6-10.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 四、小结</h2>
<p>作为一个业余前端选手，借助热火朝天的“氛围编程”也实现了一些没什么鸟用的应用，没有太大障碍的完成了webapp、网页开发、浏览器插件、基于uniapp的跨端开发(小程序、h5、安卓应用)，现在也完成了基于原生kotlin的app开发全流程，整体感受就是只要你愿意折腾，技术的门槛是越来越低的</p>
<p>下面是一些借助Trae进行开发的过程，有兴趣的小伙伴可以看看</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487677&amp;idx=1&amp;sn=3cb47b3c8d84c7f3d299174205bdaa07&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">首个完全由AI生成的APP上架啦 - ColorPicker</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487748&amp;idx=1&amp;sn=eac77c82547603cd19725260d1bb584a&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">毫无技术难度：由0到1基于AI完成“垃圾消除小游戏”</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487847&amp;idx=1&amp;sn=ee5bea7a986f364314c50f667bbe9dfb&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">AI生成的垃圾小游戏-上架谷歌应用市场全流程-图文介绍</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487868&amp;idx=1&amp;sn=2a80743e416a3b00e3c66421547c5c94&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">AI 生成 web 应用，如何通过广告变现 “钱” 景无限</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487901&amp;idx=1&amp;sn=d7130ffcb19fde9d7ac23cdc529c08df&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">AI生成APP-接入谷歌变现图文攻略</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487950&amp;idx=1&amp;sn=09a9823ebdee85fb2d5bf0331504b48b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">借助AI赚美刀-谷歌广告收款攻略</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247487936&amp;idx=1&amp;sn=eafd7f1c95e06fff4f5ed1092ae68508&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">借助Trae的智能体完成我的浏览器主页个性化改造图文全流程</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247488002&amp;idx=1&amp;sn=5400567e26ca17710b923b3fb119b873&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">AI生成插件上架Chrome应用商店全流程</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&amp;mid=2247488089&amp;idx=1&amp;sn=8c57c677237861f88f705918186b7b4c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">浏览器里直接跑大模型抠图？试试这个借助transform.js搭建网页神器吧</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://ai.hhui.top/static/textwidget/s0.webp" type="image/webp"/>
    </item>
    <item>
      <title>7. 基于AI开发三端产品-文渊阁原型设计</title>
      <link>https://ppai.top/ai-guides/tutorial/ai-coding/07.%E5%9F%BA%E4%BA%8EAI%E5%BC%80%E5%8F%91%E4%BA%A7%E5%93%81-%E6%96%87%E6%B8%8A%E9%98%81%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1.html</link>
      <guid>https://ppai.top/ai-guides/tutorial/ai-coding/07.%E5%9F%BA%E4%BA%8EAI%E5%BC%80%E5%8F%91%E4%BA%A7%E5%93%81-%E6%96%87%E6%B8%8A%E9%98%81%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">7. 基于AI开发三端产品-文渊阁原型设计</source>
      <description>一恍惚25年就已经过了一半，上半年借助AI开发工具也做了不少小玩具；在下半年，给自己订一个小目标，做一个完整功能更完整的产品，计划做三端（PC、小程序、APP），并且包含独立的后端服务能力。 实际上我个人也没有特别想做的东西，正好小朋友最近开始学习识字、背诗，那就做一个中华文化知识相关的产品得了 一、 前置准备 有想法之后，第一件事情，当然是全网搜一下，有没有类似的可以学习致敬（抄袭）的竞品 知乎上有一个挺好的话题，- 有没有公认比较好的诗词APP推荐？ - 知乎</description>
      <category>AI</category>
      <pubDate>Tue, 08 Jul 2025 07:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>一恍惚25年就已经过了一半，上半年借助AI开发工具也做了不少小玩具；在下半年，给自己订一个小目标，做一个完整功能更完整的产品，计划做三端（PC、小程序、APP），并且包含独立的后端服务能力。</p>
<p>实际上我个人也没有特别想做的东西，正好小朋友最近开始学习识字、背诗，那就做一个中华文化知识相关的产品得了</p>
<h2> 一、 前置准备</h2>
<p>有想法之后，第一件事情，当然是全网搜一下，有没有类似的可以学习致敬（抄袭）的竞品</p>
<p>知乎上有一个挺好的话题，- <a href="https://www.zhihu.com/question/21528388" target="_blank" rel="noopener noreferrer">有没有公认比较好的诗词APP推荐？ - 知乎</a></p>
<p>推荐的产品还挺多，app/网站/小程序均有，下面是摘抄目录</p>
<figure><img src="/imgs/column/ai/7-1.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>产品有一些可以学习的对象；接下来再看看开源社区上是否有可以拿来当“基座”的原型😊</p>
<p>比如一些数据源：</p>
<ul>
<li><a href="https://github.com/caoxingyu/chinese-gushiwen" target="_blank" rel="noopener noreferrer">caoxingyu/chinese-gushiwen: 中华古诗文数据库和API。包含10000首古文(诗、词、歌、赋以及其它形式的文言文)，近4000名作者，10000名句</a></li>
<li><a href="https://github.com/chanind/hanzi-writer-data" target="_blank" rel="noopener noreferrer">chanind/hanzi-writer-data: The data used by Hanzi Writer</a></li>
</ul>
<p>一些可用的产品：</p>
<ul>
<li><a href="https://github.com/hefengbao/jingmo/tree/main" target="_blank" rel="noopener noreferrer">hefengbao/jingmo: 『京墨』开源的中华文化宝典 APP，诗（词）文（名句）、汉字、成语、词语、歇后语、绕口令、传统节日、传统色、节气、人物等。</a></li>
<li><a href="https://github.com/a2636340559/YaFeng" target="_blank" rel="noopener noreferrer">a2636340559/YaFeng: “雅风”古诗词APP</a></li>
<li><a href="https://github.com/SongC1229/song" target="_blank" rel="noopener noreferrer">SongC1229/song: 基于Flutter框架的诗词app,采用sqlite数据库</a></li>
</ul>
<h2> 二、 原型设计</h2>
<p>基于上面的过程我们大概知道自己想做些啥，但是具体的产品设计这块由于并不专业不知道该怎么做，既然我不会，那就借助一下AI来帮我整一下</p>
<p>直接大力出奇迹，对于小白完全不考虑什么提示词</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/imgs/column/ai/7-2.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>省略调整的过程，看看AI生成的原型方案</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然对于一个研发而言，上面的这套设计方案仅使用参考，我还是更喜欢可视化的交互页面</p>
<h2> 三、快速原型实现</h2>
<p>使用AI体验最好的就在这里了，我可以直接让它快速将上面的设计实现一个demo出来看看效果</p>
<figure><img src="/imgs/column/ai/7-3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这个生成的网页效果实际上超出了我的预期，至少我自己是设计不出来的。 接下来我们就是基于这个原型进行丰富补全</p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/ai/7-1.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>AI编程实战</title>
      <link>https://ppai.top/ai-guides/tutorial/ai-coding/</link>
      <guid>https://ppai.top/ai-guides/tutorial/ai-coding/</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">AI编程实战</source>
      <description>氛围编程 借助AiCoding（如cursor windsurf trae copilot）来实现低门槛的编程</description>
      <pubDate>Thu, 22 Jan 2026 08:45:40 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 氛围编程</h1>
<p>借助AiCoding（如cursor windsurf trae copilot）来实现低门槛的编程</p>
]]></content:encoded>
    </item>
    <item>
      <title>01.AI Agent Google白皮书</title>
      <link>https://ppai.top/ai-guides/tutorial/hello-agent/01.AI%20Agent%20Google%E7%99%BD%E7%9A%AE%E4%B9%A6.html</link>
      <guid>https://ppai.top/ai-guides/tutorial/hello-agent/01.AI%20Agent%20Google%E7%99%BD%E7%9A%AE%E4%B9%A6.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">01.AI Agent Google白皮书</source>
      <description>以下内容来自于大模型对 Agents谷歌白皮书 的翻译内容提取 1.序 人类非常擅长识别复杂的模式。他们是怎么做到的呢？ -- 借助于外部外部工具，如书籍、网络搜索或者计算器之类的工具，来补充一有的知识，然后再得出结论 对于生成式人工智能模型，同样也可以通过训练来使用工具，以此来访问实时信息或者给出行动建议，如</description>
      <category>Agent</category>
      <pubDate>Thu, 06 Nov 2025 10:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>以下内容来自于大模型对 <a href="https://drive.google.com/file/d/1oEjiRCTbd54aSdB_eEe3UShxLBWK9xkt/view" target="_blank" rel="noopener noreferrer">Agents谷歌白皮书</a> 的翻译内容提取</p>
<h2> 1.序</h2>
<p>人类非常擅长识别复杂的模式。他们是怎么做到的呢？</p>
<p>-- 借助于外部外部工具，如书籍、网络搜索或者计算器之类的工具，来补充一有的知识，然后再得出结论</p>
<p>对于生成式人工智能模型，同样也可以通过训练来使用工具，以此来访问实时信息或者给出行动建议，如</p>
<ul>
<li>利用数据库查询工具获取客户的购物历史，然后给出购物意见</li>
<li>根据用户的查询，调用相应的API，替用户回复电子邮件或者完成金融交易</li>
</ul>
<p>大模型要实现这个，则要求模型不仅需要访问外部工具，还要能够自主规划和执行任务。 这种具备了<strong>推理、逻辑和访问外部信息</strong>的生成式 AI 模型，就是 Agent 的概念；</p>
<p>换句话说，Agent <strong>是一个扩展了生成式AI模型出厂能力的程序</strong>。</p>
<h2> 2.什么是Agent</h2>
<h3> 2.1 基本概念</h3>
<p>简单说，Agent 是 “带脑子 + 带手脚 + 会规划” 的生成式 AI 应用 —— 它能自己定目标、用工具、调资源，不用人一步步指挥，就能完成任务。</p>
<ul>
<li>Agent拥有自主能力(autonnomous): 只要提供了合适的目标，它们就能独立行动，无需人类干预</li>
<li>即使是模糊的人类指令，Agent也可以推理出它接下来应该做什么，并采取行动，最终实现其目标</li>
</ul>
<h3> 2.2 认知架构(congnitive architecture)</h3>
<p>驱动Agent的行为、动作、决策（behavior, actions, decision marking）共同组合成Agent的认知架构</p>
<p>在这个架构中，有三个核心组件，如下面的认知架构图</p>
<ul>
<li>model: 模型</li>
<li>tool: 工具</li>
<li>orchestration: 编排层</li>
</ul>
<figure><img src="/imgs/column/springai/wp-00.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 2.2.1 模型 model</h4>
<p>在Agent领域中，model通常指的是用于做核心决策的语言模型(LM)</p>
<ul>
<li>可以是大模型，也可以是小模型(LLM/SLM)</li>
<li>需要遵循基于指令的推理和逻辑框架（ReAct, Chain-of-Thought, Tree-of-Thought）</li>
<li>可以是通用、多模态的模型，或者根据特定的Agent架构的需求微调的模型</li>
<li>为了获得更好的执行效果，推荐根据已有的工具、数据集、编排推理设置，对模型进行训练/微调，以此来获得更稳定表现的模型</li>
</ul>
<h4> 2.2.2 工具 tool</h4>
<p>基础模型在文本和图像生成方面非常抢单，但是无法预外部世界联动，则极大的限制了它们的能力。工具(tool)则可以解决这个问题，Agent通过工具与外部数据和服务互动，从而扩展模型的能力边界</p>
<p>工具可以有多种表现形式，最常见的是通过WEB API(如GET/POST/PATCH/DELETE等http调用) 方式提供的工具能力</p>
<h4> 2.2.3 编排层 ochestration</h4>
<p>编排层主要描述了一个循环过程，用于控制Agent如何接收消息、执行内部推理、并使用推来结果来指导下一步的行动或者决策</p>
<p>对于编排层，有两个显著的特点：</p>
<ul>
<li>通常来说，这个循环过程会持续进行，直到Agent达到其目标或触发停止条件</li>
<li>编排层的复杂性和Agent及其执行的任务直接相关，差异可能很大</li>
</ul>
<h4> 2.2.4 Agent vs Model</h4>
<p>代表对比了Agent与模型之间的区别</p>
<table>
<thead>
<tr>
<th>对比</th>
<th>模型</th>
<th>Agent</th>
</tr>
</thead>
<tbody>
<tr>
<td>知识范围</td>
<td>知识仅限于其训练数据。</td>
<td>通过工具连接外部系统，能够在模型自带的知识之外，实时、动态扩展知识。</td>
</tr>
<tr>
<td>状态与记忆</td>
<td>无状态，每次推理都跟上一次没关系，除非在外部给模型加上会话历史或上下文管理能力。</td>
<td>有状态，自动管理会话历史，根据编排自主决策进行多轮推理。</td>
</tr>
<tr>
<td>原生工具</td>
<td>无。</td>
<td>有，自带工具和对工具的支持能力。</td>
</tr>
<tr>
<td>原生逻辑层</td>
<td>无。需要借助提示词工程或使用推理框架（CoT、ReAct  等）来形成复杂提示，指导模型进行预测。</td>
<td>有，原生认知架构，内置 CoT、ReAct 等推理框架或 LangChain  等编排框架。</td>
</tr>
</tbody>
</table>
<h2> 3.认知架构：Agent如何工作</h2>
<h3> 3.1 以厨师为例，类比Agent的工作流程</h3>
<p>厨师的职责是根据顾客的菜单，烹饪对应的菜品。 这个操作流程类似上面说到的<strong>规划——执行——调整</strong>(<code>planning - execution - adjustment</code>)循环过程</p>
<ul>
<li>收集信息(输入)：顾客点的菜单，后厨现有的食材等</li>
<li>推理(思考): 根据收集的信息，判断可以做哪些采</li>
<li>做菜(执行): 切菜、烹饪、出锅</li>
</ul>
<p>在上面的每个阶段过程，厨师都需要根据实际情况进行调整，比如突然某个食材不够了，需要找顾客协商换一道菜；根据顾客的饮食偏好，添加不同的调料（如有人要清淡、有人要重口），通过这些调整，不断的完善整个做菜过程</p>
<p>这个信息接收、规划、执行和调整（information intake, planning, executing, and adjusting）的循环描述的就是一个厨师用来实现其目标的特定认知架构。</p>
<h3> 3.2 Agent 推理框架</h3>
<p>Agent的核心是编排层，负责<strong>维护记忆、状态、推理和规划</strong>（<code>memory, state, reasoning and planning</code>）</p>
<p>使用快速发展的<strong>提示词工程</strong>(prompt engineering)及相关框架来指导推理和规划，使Agent能更有效的与环境互动来完成任务</p>
<p>白皮书中提到了三种推理框架和推理计数</p>
<ul>
<li>ReAct: 为LM提供了一个思考过程的策略</li>
<li>Cot(Chain-of-Thought)：思维链，通过中间步骤实现推理能力 （有各种子技术，如自我一致性、主动提示、多模态CoT）</li>
<li>ToT(Tree-of-Thoughts)：思维树，适合探索或战略前瞻任务。概括了链式思考提示，并允许模型探索各种思考链，作为使用语言模型解决问题的中间步骤。</li>
</ul>
<h3> 3.3 ReAct示例</h3>
<p>Agent 可以使用以上一种或多种推理技术，给特定的用户请求确定下一个最佳行动。 例如，使用 ReAct 的例子</p>
<ol>
<li>用户向 Agent 发送查询。</li>
<li>Agent 开始 ReAct sequence。</li>
<li>Agent 提示模型，要求其生成下一个 ReAct 步骤及其相应的输出：
<ul>
<li>问题：提示词 + 用户输入的问题</li>
<li>思考：模型的想法：下一步应该做什么</li>
<li>行动：模型的决策：下一步要采取什么行动。这里就是可以引入工具的地方， 例如，行动可以是 <code>[Flights, Search, Code, None]</code> 中的一个，前三个代表模型可以选择的已知工具，最后一个代表“无工具选择”。</li>
<li>行动的输入：模型决定是否要向工具提供输入，如果要提供，还要确定提供哪些输入</li>
<li>观察：行动/行动输入序列的结果。根据需要，这个思考/行动/行动输入/观察<code>（thought / action / action input / observation）</code>可能会重复 N 次。</li>
<li>最终答案：模型返回对原始用户查询的最终答案。</li>
</ul>
</li>
<li>ReAct 循环结束，并将最终答案返回给用户。</li>
</ol>
<figure><img src="/imgs/column/springai/wp-01.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如上图，模型、工具和Agent配置共同工作，根据用户的输入，返回一个有根据的、简洁的响应。虽然模型第一轮根据其先前知识猜了一个答案（幻觉），但它接下来使用了一个工具（航班）来搜索实时外部信息，从而能根据真实数据做出更明智的决策，并将这些信息总结回给用户。</p>
<p>Agent 的响应质量与模型的推理能力和执行任务的能力直接相关，包括选择正确工具的能力，以及工具自身的定义的好坏（how well that tools has been defined）。就像厨师精选食材、精心做菜，并关注顾客的反馈一样，Agent 依赖于合理的推理和可靠的信息来提供最佳结果。</p>
<h2> 4.工具：模型链接真实世界的关键</h2>
<p>语言模型很擅长处理信息，但它们缺乏直接感知和影响现实世界的能力。在需要与外部系统或数据联动的情况下，这些模型的实用性就很低了。 某种意义上说，语言模型的能力<strong>受限于它们的训练数据中覆盖到的信息</strong></p>
<p>为了赋予模型与外部系统进行实时、上下文感知的互动能力，通常有下面几种方式（统称为工具 Tools）</p>
<ul>
<li>Functions</li>
<li>Extensions</li>
<li>Data Stores</li>
<li>Plugins</li>
</ul>
<h3> 4.1 Extensions</h3>
<p><code>extension</code> 是一种以标准化方式连接 <code>API</code> 与 <code>Agent</code> 的组件， 使 <code>Agent</code> 能够调用外部 API，而不用管这些 API 背后是怎么实现的。</p>
<p>假设你想创建一个帮用户预定航班的Agent，并使用Google Flights API来搜索航班信息，但不确定如何让你的Agent调用这个API</p>
<figure><img src="/imgs/column/springai/wp-02.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 4.1.1 传统方式</h4>
<p>写代码，从用户输入中解析城市等相关信息，然后调用API，如</p>
<ul>
<li>用户输入 “I want to book a flight from Austin to Zurich”（“我想从奥斯汀飞往苏黎世”）； 我们的代码需要从中提取“Austin”和“Zurich”作为相关信息，然后才能进行 API 调用。</li>
<li>但如果用户输入“I want to book a flight to Zurich”，我们就无法获得出发城市信息，进而无法成功调用 API，所以需要写很多代码来处理边界 case。</li>
</ul>
<p>显然，这种方法维护性和扩展性都很差。有没有更好的解决方式呢？ 这就轮到 exntension 出场了。</p>
<h4> 4.1.2 使用Extension</h4>
<figure><img src="/imgs/column/springai/wp-03.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如图，Extension通过以下方式将Agent与API串起来</p>
<ul>
<li>提供示例信息告诉Agent如何使用API</li>
<li>告诉Agent调用API所需的具体参数</li>
</ul>
<p><code>Extension</code> 可以独立于 <code>Agent</code> 开发，但应作为 <code>Agent</code> 配置的一部分。 <code>Agent</code> 在运行时，根据提供的示例和模型来决定使用哪个 <code>extension</code> 来处理用户的查询， 这突出了 <code>extension</code> 的一个核心优势：<code>built-in example types</code>， 允许 <code>Agent</code> 动态选择最适合所执行任务的 extension，如下图所示</p>
<figure><img src="/imgs/column/springai/wp-04.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4.2 Functions</h3>
<p>在程序员的日常工作中，“函数”指的是自包含的代码模块，用于完成特定任务，并可以复用（被不同地方的代码调用）</p>
<p>在Agent的世界中，函数的工作方式非常相似——知识将软件开发者替换为模型。模型可以设置一组已知的函数，然后就可以根据规范决定何时使用哪个函数，以及函数需要哪些参数</p>
<figure><img src="/imgs/column/springai/wp-05.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol>
<li>模型只输出函数名及参数信息，不会执行函数调用</li>
<li>函数在客户端执行，作为对比的是Extension在Agent端执行</li>
</ol>
<h4> 4.2.1 Functions vs Extention</h4>
<p>对于Function，与Extention的核心区别在于，调用实际API的逻辑和执行将从代理返回给用户，因此开发人员可以对应用程序中的数据流进行更精细的控制，常见于</p>
<ul>
<li>并不希望直接调用API，而是由应用程序的其他层来调用</li>
<li>因为安全身份校验，不支持Agent直接访问的场景</li>
<li>不希望实时调用的场景（如需要人工review执行链路）</li>
</ul>
<figure><img src="/imgs/column/springai/wp-06.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 4.2.2 示例</h4>
<p>考虑以下例子，实现一个 AI Traval Agent，它会与想要旅行的用户互动。 我们的目标是让 Agent 生成一个城市列表，然后就可以下载相应城市的图片、数据等，以供用户旅行规划使用。</p>
<p>用户输入：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>模型输出可能如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然以上输出包含了我们需要的数据（城市名称），但格式不适合解析。 通过 Function，我们可以教模型以结构化风格（如 JSON）输出，以便其他系统解析。</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个Agent应用的整体流程图如下</p>
<figure><img src="/imgs/column/springai/wp-07.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4.3 data storage</h3>
<p>语言模型就像一个大图书馆，其中包含了其训练数据（信息）。但与真实世界的图书馆不同的是，这个图书馆是静态的 —— 不会更新，只包含其最初训练时的知识。而现实世界的知识是不断在演变的，所以静态模型在解决现实世界问题时就遇到了挑战。</p>
<figure><img src="/imgs/column/springai/wp-08.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><code>Data Storage</code> 通过提供动态更新的信息来解决这一问题，</p>
<ul>
<li>允许开发人员以原始格式向 <code>Agent</code> 提供增量数据，将传入的文档转换为一组向量数据库嵌入，<code>Agent</code> 可以使用这些 <code>embedding</code> 来提取信息。</li>
<li>增量数据补充，无需耗时的数据转换、模型重新训练、微调</li>
</ul>
<h4> 4.3.1 实现与应用</h4>
<p>在生成式 AI 场景，Agent 使用的数据库一般是向量数据库 —— 它们以向量 <code>embedding</code> 的形式存储数据，这是一种高维向量或数学表示。</p>
<figure><img src="/imgs/column/springai/wp-09.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>使用语言模型与 Data Storage 的最典型例子是检索增强生成（RAG - Retrieval Augmented Generation），RAG 应用程序通过让模型访问各种格式的数据来扩展模型知识的广度和深度，如：</p>
<ul>
<li>网站内容</li>
<li>结构化数据，如pdf/word/csv/电子表格等</li>
<li>非结构化数据，如HTML/PDF/TXT等</li>
</ul>
<p>用户请求和Agent响应循环的基本过程如下图</p>
<figure><img src="/imgs/column/springai/wp-10.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol>
<li>用户请求 发送到嵌入模型(embedding model)，生成嵌入查询(query embedding)。</li>
<li>将嵌入查询与向量数据库的内容进行匹配，本质上就是在计算相似度。</li>
<li>将相似度最高的内容以文本格式发送回 <code>Agent</code>。</li>
<li><code>Agent</code> 决定响应或行动。</li>
<li>最终响应发送给用户。</li>
</ol>
<h4> 4.3.2 示例</h4>
<p>一个RAG与ReAct推理/规划的Agent示例</p>
<figure><img src="/imgs/column/springai/wp-11.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 4.4 小结</h3>
<p>总结来说，Extension、Function 和 Data Storage 是 Agent 在运行时可以使用的几种不同工具类型。 每种工具都有其特定的用途，可以根据 Agent 开发人员的判断单独或一起使用。</p>
<table>
<thead>
<tr>
<th>对比</th>
<th>Extensions</th>
<th>Function Calling</th>
<th>Data Stores</th>
</tr>
</thead>
<tbody>
<tr>
<td>Execution 执行</td>
<td>Agent执行</td>
<td>Client执行</td>
<td>Agent执行</td>
</tr>
<tr>
<td>使用场景</td>
<td>- 开发人员希望 Agent 控制 API 的调用 <br> - 使用 native pre-built Extensions (i.e., Vertex Search, Code Interpreter, etc.) 时比较有用 <br> - Multi-hop planning and API calling (i.e., 下一个 action 取决于前一个 action/API call 的输出)</td>
<td>- 安全或认证等原因，导致 Agent 无法直接调用 API 的场景 <br> - 时序或者操作顺序限制，导致 Agent 无法直接事实调用 API 的场景，(i.e., batch operations, human-in-the-loop review, etc.) <br> - API 没有暴露给公网，只能在内部使用的场景。</td>
<td>RAG</td>
</tr>
</tbody>
</table>
<h2> 5.通过针对性学习提升模型性能</h2>
<p>有效使用模型的一个关键是，让模型具备在生成输出时选择正确工具的能力。虽然一般训练有助于模型获得这种技能，但现实世界的场景通常需要超出训练数据的知识。 这就像是掌握基本做菜技能和精通特定菜系之间的区别，两者都需要基础烹饪知识，但后者需要针对性学习以获得更好的垂类结果。</p>
<p>通常有下面几种方法</p>
<h3> 5.1 In-Context learnging：基于上下文学习</h3>
<p>使用通用模型，但在推理时为模型提供提示词、工具和示例，使模型其能够“即时学习”如何以及何时为特定任务使用这些工具。 如ReAct框架</p>
<h3> 5.2 Retrieval-based in-context learnging: 基于检索的上下文学习</h3>
<p>通过从外部存储中检索相关信息、工具和示例来动态填充模型提示词，如RAG</p>
<h3> 5.3 Fine-utning based learning: 基于微调的学习</h3>
<p>用大量的特定示例对模型进行训练（微调/精调），然后用微调过的模型进行推理。</p>
<p>这有助于模型在接收到任何用户查询之前，理解何时以及如何应用某些工具。</p>
<h2> 6.总结</h2>
<p>本文讨论了生成式 AI Agent 的基础构建模块及工作原理。一些关键信息：</p>
<ol>
<li>Agent 的核心价值：让生成式 AI 从 “生成内容” 升级为 “完成任务”，能自主规划、用工具、对接真实世界</li>
<li>三大关键：模型（思考）、工具（行动）、编排层（流程）</li>
<li>工具选对很重要：直接用 Extension，安全可控用 Function，需要实时 / 私有数据用 Data Store</li>
<li>推理框架：ReAct, CoT, ToT, (以及本文未提到的Plan-and-Execute)</li>
<li>未来方向：多个 Agent 分工合作（比如一个负责旅行规划，一个负责订机票，一个负责订酒店），解决更复杂的问题</li>
</ol>
<p>最后需要说明，复杂的 Agent 架构并不是一蹴而就的，需要持续迭代（iterative approach）。 给定业务场景和需求之后，不断的实验和改进是找到解决方案的关键。</p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/wp-00.webp" type="image/webp"/>
    </item>
    <item>
      <title>02.Agent思考框架-CoT思维链</title>
      <link>https://ppai.top/ai-guides/tutorial/hello-agent/02.Agent%E6%80%9D%E8%80%83%E6%A1%86%E6%9E%B6-CoT.html</link>
      <guid>https://ppai.top/ai-guides/tutorial/hello-agent/02.Agent%E6%80%9D%E8%80%83%E6%A1%86%E6%9E%B6-CoT.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">02.Agent思考框架-CoT思维链</source>
      <description>AI智能体思考框架主要是为了赋予AI智能体结构化的推理和决策能力，为AI智能体提供一套完整的方法论，指导其如何理解目标、分解任务、运用工具、处理输入，并依据环境反馈来调整资深行为 当前主流的思考框架有CoT, ReAct, ToT, Plan-and-Execute，本文将主要介绍一下CoT 思维链 1.CoT思维链 Chain-of-Thought(CoT) 来源与论文 《Chain-of-Thought Prompting Elicits Reasoning in Large Language Models》</description>
      <category>Agent</category>
      <pubDate>Thu, 06 Nov 2025 14:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>AI智能体思考框架主要是为了赋予AI智能体结构化的推理和决策能力，为AI智能体提供一套完整的方法论，指导其如何理解目标、分解任务、运用工具、处理输入，并依据环境反馈来调整资深行为</p>
<p>当前主流的思考框架有CoT, ReAct, ToT, Plan-and-Execute，本文将主要介绍一下CoT 思维链</p>
<h2> 1.CoT思维链</h2>
<p>Chain-of-Thought(CoT) 来源与论文 <a href="https://proceedings.neurips.cc/paper_files/paper/2022/file/9d5609613524ecf4f15af0f7b31abca4-Paper-Conference.pdf" target="_blank" rel="noopener noreferrer">《Chain-of-Thought Prompting Elicits Reasoning in Large Language Models》</a></p>
<p>论文中提出，CoT核心是让大模型在输出最终答案前，先用自然语言生成一步步的推理过程，就像人类解数学题时写 “解题步骤”、做决策时列 “思考清单” 一样。而这些推理的中间步骤就被称为思维链</p>
<h3> 1.1 CoT定义</h3>
<blockquote>
<p>以下内容，可来自于论文: <a href="https://arxiv.org/pdf/2311.11797" target="_blank" rel="noopener noreferrer">Igniting Language Intelligence: The Hitchhiker's Guide From Chain-of-Thought Reasoning to Language Agents</a></p>
</blockquote>
<p>区别于传统的 Prompt 从输入直接到输出的方式，CoT完成了从输入到思维链再到输出的转变，即</p>
<p>由 <code>input -&gt; output</code> 转变为 <code>input -&gt; reasoning chain -&gt; output</code></p>
<figure><img src="/imgs/column/springai/ag2-01.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如图，一个完整的包含CoT的提示词，通常由指令(Instruction), 逻辑依据(Rationale), 示例(Examplars)三部分组成</p>
<ul>
<li>指令: 用于描述问题并且告知大模型的输出格式</li>
<li>逻辑: 依据即指 CoT 的中间推理过程，可以包含问题的解决方案、中间推理步骤以及与问题相关的任何外部知识，</li>
<li>示例: 则指以少样本的方式为大模型提供输入输出对的基本格式，每一个示例都包含：问题，推理过程与答案。</li>
</ul>
<p>以是否包含示例为区分，可以将 CoT 分为 Zero-Shot-CoT 与 Few-Shot-CoT</p>
<p>在上图中，Zero-Shot-CoT 不添加示例而仅仅在指令中添加一行经典的“Let's think step by step”，就可以“唤醒”大模型的推理能力。</p>
<p>而 Few-Shot-Cot 则在示例中详细描述了“解题步骤”，让大模型参考样例进行执行，从而得到推理能力。</p>
<h3> 1.2 CoT的作用</h3>
<ol>
<li>CoT允许模型把一个复杂问题拆解成多个步骤，也就是说需要更多推理步骤的问题可以多分点计算量。</li>
<li>CoT提供了一个观察模型为何会犯错的窗口，给观测者了解模型出现幻觉的原因</li>
<li>CoT能用在数学应用题、常识推理和符号操作上，也就有可能用在任何人类通过语言能解决的问题上</li>
<li>CoT支持任何语言模型使用</li>
</ol>
<h3> 1.3 CoT的优势</h3>
<ol>
<li>提高推理性能：CoT 通过将复杂问题分解为多步骤的子问题，相当显著的增强了大模型的推理能力，也最大限度的降低了大模型忽视求解问题的“关键细节”的现象，使得计算资源总是被分配于求解问题的“核心步骤”；</li>
<li>提高可解释性：对比向大模型输入一个问题大模型为我们仅仅输出一个答案，CoT 使得大模型通过向我们展示“做题过程”，使得我们可以更好的判断大模型在求解当前问题上究竟是如何工作的，同时“做题步骤”的输出，也为我们定位其中错误步骤提供了依据；</li>
<li>提高可控性：通过让大模型一步一步输出步骤，我们通过这些步骤的呈现可以对大模型问题求解的过程施加更大的影响，避免大模型成为无法控制的“完全黑盒”</li>
<li>提高灵活性：仅仅添加一句“Let's think step by step”，就可以在现有的各种不同的大模型中使用 CoT 方法，同时，CoT 赋予的大模型一步一步思考的能力不仅仅局限于“语言智能”，在科学应用，以及 AI Agent 的构建之中都有用武之地</li>
</ol>
<h2> 2. CoT原理</h2>
<h3> 2.1 CoT生效原理</h3>
<p>大模型是如何支持CoT的呢？</p>
<p>本质是 <code>大模型支持 CoT 的本质，是通过训练或提示机制，使模型在生成过程中显式或隐式地产生中间推理步骤，从而提高复杂推理任务的可解释性与准确性。</code></p>
<h4> 2.1.1 提示级CoT：基于提示工程的显式引导</h4>
<p>最早、也是目前最常用的方式。其核心思想是不改变模型参数，而是通过提示语（prompt）设计，引导模型在推理过程中显式输出中间步骤。主要分为两类：</p>
<ul>
<li><strong>零样本 CoT（Zero-shot CoT）</strong>：仅在问题末尾添加引导语，例如 <code>Let’s think step by step</code> 或 <code>请先分析步骤，再给出结论</code>。
<ul>
<li>例如，问题“为什么夏天海滩人多？” 加上引导语后</li>
<li>模型会生成类似推理链：
<ul>
<li>第一步，夏天天气炎热，人们倾向于去水边避暑；</li>
<li>第二步，海滩具备娱乐与降温功能；</li>
<li>第三步，夏季假期增加出行需求”，最后得出结论“因此夏天海滩更受欢迎。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这种方式简单有效，但在复杂推理任务中的准确率较低，对模型语言偏好和训练语料敏感。</p>
<ul>
<li>
<p><strong>少样本 CoT（Few-shot CoT）</strong>：在提示中提供若干 <code>问题 + 推理链 + 答案</code></p>
<ul>
<li>示例，使模型通过上下文学习（In-context Learning, ICL）模仿推理模式。</li>
<li>例如在算术任务中提供示例：「问题：10 个橘子吃了 3 个，还剩几个？→ 推理：10−3=7 → 答案：7」。模型据此可类推新问题。</li>
</ul>
</li>
</ul>
<p>这种方式能显著提升推理稳定性，但需要人工构建高质量示例。</p>
<h4> 2.1.2 自举式CoT：利用模型自身能力自动生成示例</h4>
<p>人工编写少样本示例成本高，因而出现了 <strong>自动思维链（Auto-CoT）</strong> 方法。其核心思想是：让模型通过自举（bootstrapping）机制自动生成用于提示的 CoT 示例。典型流程如下：</p>
<ol>
<li><strong>问题聚类（Question Clustering）</strong>：将待解决任务划分为若干语义相近的类别（如“加法”“减法”“应用题”）。</li>
<li><strong>自动示例生成（Automatic Demonstration Generation）</strong>：从每类中选择代表性问题，利用零样本 CoT 生成高质量推理链作为示例。</li>
<li><strong>Few-shot 提示重构</strong>：将自动生成的示例嵌入提示中，引导模型处理同类问题。</li>
</ol>
<p>在实践中，Auto-CoT 常与 <strong>自一致性（Self-consistency）</strong> 策略结合，即采样多条思维链并选取最一致的答案，以减轻错误推理传播问题。
这种方法减少人工干预，能在无需重新训练的前提下，自动获得较强的推理能力。</p>
<h4> 2.1.3 模型级 CoT：在训练阶段内化推理能力</h4>
<p>现在的大模型（如 DeepSeek-R1、GPT-o1 等）已不再依赖提示引导，而是通过训练过程直接“内化”思维链能力。实现路径通常包括以下几个阶段：</p>
<ul>
<li><strong>监督微调（Supervised Fine-tuning, SFT）阶段</strong>：在训练数据中引入大量包含“推理步骤 + 最终答案”的样本，使模型学习生成中间思考过程；</li>
<li><strong>强化优化（RLHF / RLAIF）阶段</strong>：通过人类反馈或自动反馈信号，奖励“逻辑正确、步骤完整”的推理链，惩罚“跳步或错误推理”；</li>
<li><strong>过程监督（Process Supervision）与验证器机制（Verifier-based Fine-tuning）</strong>：进一步强化中间推理过程的可验证性，使模型学会自我审查与修正。</li>
</ul>
<p>经过这样的训练，模型在面对复杂推理任务时，即便没有显式提示，也能自然生成符合逻辑的思维链，表现出“内置的推理习惯”。</p>
<h4> 2.1.4 多模态 CoT：跨模态推理的思维链扩展</h4>
<p>随着多模态大模型的发展（如 GPT-4o、Gemini 2等），CoT 概念已扩展至文字与视觉等多源信息的联合推理。</p>
<p><strong>多模态 CoT（Multimodal CoT）</strong>
旨在让模型在生成答案前，整合图像特征与文本上下文，形成跨模态的推理链。</p>
<p>例如，输入一张“拥挤的海滩”图片并询问“夏天这里会更受欢迎吗？”，模型可能推理：“图片显示人群密集，当前已受欢迎；夏季天气炎热，人们更倾向于去海滩避暑；假期增多会进一步提升出游人数”，最终得出结论“夏天会更受欢迎”。</p>
<p>技术上，多模态 CoT 通过两类机制实现：</p>
<ul>
<li><strong>融合式推理（Fusion-based Reasoning）</strong>：将图像与文本 token 在同一 Transformer 层中联合建模；</li>
<li><strong>递归式推理（Iterative Reasoning）</strong>：先生成初步视觉分析，再结合语言模型多轮细化推理。</li>
</ul>
<p>这类机制显著提升了模型在视觉问答（VQA）、图文逻辑、视频理解等任务中的推理一致性与可解释性。</p>
<h4> 2.1.5 小结</h4>
<p>CoT 的演进体现了从“显式提示驱动”到“内化思维模式”的范式转变：</p>
<ul>
<li><strong>提示级 CoT</strong>：通过设计输入引导模型逐步推理；</li>
<li><strong>自举式 CoT</strong>：让模型利用自身能力自动生成推理示例；</li>
<li><strong>模型级 CoT</strong>：在训练中嵌入推理链能力，实现原生思考；</li>
<li><strong>多模态 CoT</strong>：扩展至跨模态逻辑推理，融合语言与感知信息。</li>
</ul>
<p>这一演化路径标志着大模型从“被提示思考”迈向“自主推理”的阶段性突破。</p>
<h3> 2.2 CoT推理过程</h3>
<p>CoT提示过程，更像是一种提示词工程（Prompt Engineering)，通过向大语言模型展示一些少量的 exapmles，在样例中解释推理过程，大语言模型在回答提示时也会显示推理过程。</p>
<figure><img src="/imgs/column/springai/ag2-02.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如上图，以一个数学题为例，思维链提示会在给出答案之前，还会自动给出推理步骤，基于示例的方式，得到最终的计算结果</p>
<p>请注意，很多人会把 CoT 和 “详细提示” 搞混，其实两者本质不同：</p>
<ul>
<li>普通提示（比如 “请详细回答”）：只要求模型 “把答案说详细”，但没要求 “拆步骤推理”，模型可能还是跳过关键思考环节；</li>
<li>CoT 提示：强制模型 “拆步骤想”，比如在问题结尾加 “Let’s think step by step”（零样本 CoT），或给几个 “问题 + 推理链 + 答案” 的例子（少样本 CoT），让模型模仿 “分步思考” 的模式。</li>
</ul>
<h2> 3. CoT 与 AI Agent</h2>
<p>接下来我们再来看一看CoT为什么会成为Agent的主流推理框架之一</p>
<h3> 3.1 概念层</h3>
<h4> 3.1.1 CoT</h4>
<p>上面说到了Chain-of-Thought (CoT) 是一种推理生成机制（reasoning generation mechanism），让模型在回答问题前显式地展开中间推理步骤。</p>
<p>通俗地说，它让模型不直接“给答案”，而是“先想一想再回答”。
它关注的是 “思考的路径”。</p>
<h4> 3.1.2 Agent</h4>
<p>AI Agent（智能体） 是一种具备自主决策、环境交互与长期目标优化能力的系统架构。
它不只是语言模型，而是一个具备以下循环的系统：</p>
<p>感知（Perceive）→ 推理（Reason）→ 决策（Plan）→ 执行（Act）→ 反馈（Reflect）</p>
<p>Agent 的核心特征在于它必须：</p>
<ul>
<li>面对开放环境；</li>
<li>基于上下文做多步决策；</li>
<li>能调用外部工具或环境接口；</li>
<li>能根据反馈进行自我修正。</li>
</ul>
<h4> 3.1.3 对比</h4>
<table>
<thead>
<tr>
<th>概念</th>
<th>关注点</th>
<th>核心目标</th>
<th>是否可独立存在</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CoT</strong></td>
<td>模型内部的推理路径</td>
<td>提升逻辑一致性与可解释性</td>
<td>✅（单模型即可实现）</td>
</tr>
<tr>
<td><strong>Agent</strong></td>
<td>系统级决策循环</td>
<td>实现自主任务执行</td>
<td>🚫（离不开推理机制）</td>
</tr>
</tbody>
</table>
<p><strong>结论</strong>：CoT 是 Agent 的“推理内核”，Agent 是 CoT 的“应用容器”。</p>
<h3> 3.2 技术逻辑层</h3>
<p>AI Agent 想要具备“智能决策”的能力，必须拥有**多步思考（multi-step reasoning）<strong>和</strong>动态规划（planning）**能力。
而 CoT 正是当前大模型中最有效的“多步思考表示形式”。</p>
<h4> 3.2.1 CoT 提供了 Agent 的“内在思维空间”（Internal Reasoning Space）</h4>
<p>传统语言模型输出的是单步映射：</p>
<blockquote>
<p>输入 → 输出</p>
</blockquote>
<p>但 Agent 需要一个能在内部进行反思、规划、评估的结构化思维过程。</p>
<blockquote>
<p>输入 → （思考链）→ 决策 → 动作 → 环境反馈</p>
</blockquote>
<p>在这一结构中，CoT 就是 Agent 的「<strong>思维工作记忆（Working Memory）</strong>」：
模型通过生成中间推理链，显式地表达自己“在思考什么”，
从而为后续动作提供决策依据。</p>
<p>例如：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 Agent 框架中，以上 CoT 输出可直接驱动调用外部工具（日程表API、邮件系统）来执行这些步骤。</p>
<h4> 3.2.2 CoT 是“反思与规划（Reflection &amp; Planning）”机制的基础</h4>
<p>在现代 Agent 设计中，存在两种主流推理范式：</p>
<table>
<thead>
<tr>
<th>推理机制</th>
<th>核心特征</th>
<th>代表实现</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CoT（Chain-of-Thought）</strong></td>
<td>线性推理链条，显式展开思考</td>
<td>GPT-4、DeepSeek-R1</td>
</tr>
<tr>
<td><strong>ToT（Tree-of-Thought）</strong></td>
<td>树状搜索式推理，多路径评估与反思</td>
<td>Tree-of-Thoughts (Yao et al., 2023)</td>
</tr>
<tr>
<td><strong>ReAct（Reason + Act）</strong></td>
<td>推理与行动交替执行</td>
<td>LangChain / ReAct Agents</td>
</tr>
<tr>
<td><strong>Reflexion / Self-Refine</strong></td>
<td>基于 CoT 输出的自我反思与修正</td>
<td>Reflexion (Shinn et al., 2023)</td>
</tr>
</tbody>
</table>
<p>注意：这些框架<strong>都以 CoT 为基础</strong>。</p>
<ul>
<li>ReAct 将 CoT 拓展为 “推理链 + 动作链”；</li>
<li>Tree-of-Thought 则是 CoT 的并行搜索化版本；</li>
<li>Reflexion 则是在 CoT 基础上增加了 “评估与修正” 模块。</li>
</ul>
<p>因此，从技术谱系上看：</p>
<blockquote>
<p><strong>CoT → ReAct / ToT / Reflexion → Agent Frameworks（如 AutoGPT, LangGraph, Voyager 等）</strong></p>
</blockquote>
<p>这也是为什么学术界称 CoT 是 “<strong>AI Agent 的推理基石（reasoning substrate）</strong>”。</p>
<h4> 3.2.3 CoT 支撑 Agent 的“显式可解释推理”能力</h4>
<p>Agent 需要被<strong>监控、调试、解释</strong>。
如果模型的决策过程是黑箱式的 end-to-end 输出（没有中间思考过程），就无法解释为何采取某个行动。</p>
<p>而 CoT 提供了一种<strong>可追踪的决策链条</strong>：</p>
<ul>
<li>每个步骤都可以被解析、验证、修改；</li>
<li>可以通过 reward model（奖励模型）对推理链进行强化或惩罚；</li>
<li>可以为后续的 meta-agent（监督 agent）提供反思依据。</li>
</ul>
<p>例如：</p>
<blockquote>
<p>CoT 输出：“我认为这家公司明天股价会上涨，因为……”，
Agent 上层模块即可分析这条推理链的合理性，并决定是否执行交易动作。</p>
</blockquote>
<p>这也是 OpenAI、Anthropic、DeepSeek 在 2024–2025 年各自的 Agent 架构中，都将 “structured reasoning trace” 作为核心模块的原因。</p>
<h3> 3.3 架构层</h3>
<p>下图描述了 CoT 与 Agent 的架构关系（文字版示意）：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这套架构中：</p>
<ul>
<li><strong>CoT 是核心推理引擎（Reasoning Engine）</strong>；</li>
<li>它与记忆模块、工具模块交互；</li>
<li>输出的思维链结果直接影响行动决策与反馈循环；</li>
<li>高级 Agent（如反思型、自演化型 Agent）则在多轮 CoT 之上再叠加元推理（Meta-Reasoning）。</li>
</ul>
<h3> 3.4 小结</h3>
<p>CoT 作为 Agent 的主流推理框架，其主要原因如下</p>
<table>
<thead>
<tr>
<th>理由</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1. CoT 提供了结构化的思维路径</strong></td>
<td>使模型从“直接反应”转为“逐步规划”</td>
</tr>
<tr>
<td><strong>2. CoT 是多步决策的基础</strong></td>
<td>Agent 的计划、反思、行动循环都依赖推理链</td>
</tr>
<tr>
<td><strong>3. CoT 支撑可解释与可控性</strong></td>
<td>让外部系统理解、修改模型思考过程</td>
</tr>
<tr>
<td><strong>4. CoT 是更复杂推理框架（ReAct、ToT、Reflexion）的母体</strong></td>
<td>所有主流 Agent 推理范式都从 CoT 演化而来</td>
</tr>
<tr>
<td><strong>5. 实践验证</strong></td>
<td>从 LangChain 到 OpenAI o1-preview，再到 DeepSeek-R1，均以 CoT 风格思维链为决策基石</td>
</tr>
</tbody>
</table>
<p>一句话总结</p>
<blockquote>
<p><strong>CoT 是 AI Agent 的思维引擎。</strong>
它将大模型从“语言生成器”变为“可思考的决策体”，
是连接自然语言理解与自主行动之间的关键逻辑桥梁。</p>
</blockquote>
<hr>
<p>参考资料:</p>
<ul>
<li><a href="https://blog.csdn.net/qq_36426650/article/details/139452817" target="_blank" rel="noopener noreferrer">大模型Chain-of-Thought（CoT）与Agent基础知识与介绍_cot 大模型-CSDN博客</a></li>
<li><a href="https://www.zhihu.com/tardis/zm/art/670907685?source_id=1003" target="_blank" rel="noopener noreferrer">一文读懂：思维链 CoT（Chain of Thought）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/629087587" target="_blank" rel="noopener noreferrer">大模型思维链（Chain-of-Thought）技术原理 - 知乎</a></li>
<li><a href="https://arxiv.org/pdf/2311.11797" target="_blank" rel="noopener noreferrer">Igniting Language Intelligence: The Hitchhiker’s Guide From Chain-of-Thought Reasoning to Language Agents</a></li>
<li><a href="https://proceedings.neurips.cc/paper_files/paper/2022/file/9d5609613524ecf4f15af0f7b31abca4-Paper-Conference.pdf" target="_blank" rel="noopener noreferrer">Chain-of-Thought Prompting Elicits Reasoning
in Large Language Models</a></li>
<li>大模型：豆包 + ChatGpt</li>
</ul>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/ag2-01.webp" type="image/webp"/>
    </item>
    <item>
      <title>03.Agent思考框架-ReAct</title>
      <link>https://ppai.top/ai-guides/tutorial/hello-agent/03.Agent%E6%80%9D%E8%80%83%E6%A1%86%E6%9E%B6-ReAct.html</link>
      <guid>https://ppai.top/ai-guides/tutorial/hello-agent/03.Agent%E6%80%9D%E8%80%83%E6%A1%86%E6%9E%B6-ReAct.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">03.Agent思考框架-ReAct</source>
      <description>1. 背景与起源 ReAct 框架全称为 [Reason + Act: Synergizing Reasoning and Acting in Language Models](https://react-lm.github.io/)，由 Yao et al.（2022, Google Research） 首次提出。论文标题为： ReAct: Synergizing Reasoning and Acting in Language Models</description>
      <category>Agent</category>
      <pubDate>Thu, 06 Nov 2025 17:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 1. 背景与起源</h2>
<p><strong>ReAct 框架</strong>全称为 <code>[Reason + Act: Synergizing Reasoning and Acting in Language Models](https://react-lm.github.io/)</code>，由 <strong>Yao et al.（2022, Google Research）</strong> 首次提出。论文标题为：</p>
<blockquote>
<p><a href="https://arxiv.org/pdf/2210.03629" target="_blank" rel="noopener noreferrer"><em>ReAct: Synergizing Reasoning and Acting in Language Models</em></a></p>
</blockquote>
<p>这篇论文的出发点非常直接：</p>
<blockquote>
<p>仅靠 Chain-of-Thought（CoT）能让模型“思考”，但不能“行动”；
而仅靠 Tool-use 或 Action-based Agent 能“行动”，但不会“思考”。</p>
<p><strong>ReAct 试图让模型在推理（Reason）与行动（Act）之间交替进行，从而实现真正的智能体行为。</strong></p>
</blockquote>
<figure><img src="/imgs/column/springai/ag3-01.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 2. 核心思想：让模型在「思考」与「行动」之间循环</h2>
<p>传统的 CoT 是<strong>静态推理</strong>：</p>
<blockquote>
<p>输入 → 推理链（CoT） → 答案</p>
</blockquote>
<p>而 ReAct 是<strong>动态交互式推理</strong>：</p>
<blockquote>
<p>输入 → 推理步骤（Reason） → 执行动作（Act） → 观察反馈（Observe） → 再推理（Reason） → 再行动（Act） → … → 最终答案</p>
</blockquote>
<p>这种循环让模型不只是生成一条思维链，而是能够：</p>
<ul>
<li><strong>主动与外部环境交互（通过工具或接口）</strong></li>
<li><strong>根据反馈修正推理路径</strong></li>
<li><strong>在多轮循环中完成复杂任务</strong></li>
</ul>
<p>举个例子如你想查 “北京明天是否适合户外施工”，会先想 “我需要知道明天的天气（推理）→ 打开天气 APP 查数据（行动）→ 看到明天有暴雨（观察）→ 得出‘不适合施工’的结论（再推理）”。
放在大模型 / Agent 场景中，ReAct 就是让模型不再局限于 “纯内部推理”（比如 CoT 只在脑子里想），而是通过 “调用工具、获取外部反馈” 来验证和修正推理，形成闭环：</p>
<ul>
<li>推理（Reasoning）：分析目标、拆解步骤、决定下一步 “该做什么”（比如 “用户要订建筑材料，我需要先查库存→ 调用库存工具”）；</li>
<li>行动（Acting）：执行具体操作（调用工具 API、查询数据库、发送指令等），是模型与外部世界交互的核心；</li>
<li>观察（Observation）：获取行动的结果反馈（比如库存工具返回 “钢筋库存充足”“水泥缺货”）；</li>
<li>迭代：根据观察结果调整推理，直到完成目标（比如水泥缺货→ 推理 “需要找替代供应商”→ 行动 “调用供应商匹配工具”）。</li>
</ul>
<h2> 3. ReAct 的机制结构</h2>
<h3> 3.1 核心闭环流程</h3>
<p>ReAct 的核心是一个循环式 Prompt 结构，每一轮由 3 个关键组件构成：</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Reason</code></td>
<td>思考步骤</td>
<td>模型分析当前状态，推理下一步要做什么</td>
</tr>
<tr>
<td><code>Act</code></td>
<td>执行动作</td>
<td>模型根据推理结果调用外部工具、API、搜索等</td>
</tr>
<tr>
<td><code>Observe</code></td>
<td>观察反馈</td>
<td>模型读取行动结果，更新内部状态</td>
</tr>
</tbody>
</table>
<p>循环结构如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种结构兼具“推理链的透明性”与“可执行性”，是 CoT 向 Agent 推理自然演化的形式。</p>
<h3> 3.2 关键要素</h3>
<p>要想让上面的ReAct的流程跑通，必须满足三个核心条件</p>
<ol>
<li>明确的目标与终止条件：目标要可量化（如2016年、诺贝尔文学奖获得者），终止条件要清晰（找到用户，任务完成）</li>
<li>标准化的工具接口：Agent 能 “看懂并调用” 工具（网络搜索）</li>
<li>状态记忆模块：Agent 能记录每一轮的 “思考结果、行动内容、观察反馈”，避免重复劳动或者遗忘关键信息</li>
</ol>
<h2> 4. 与 CoT 的关系：ReAct = CoT + 行动接口</h2>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>Chain-of-Thought (CoT)</th>
<th>ReAct (推理行动)</th>
</tr>
</thead>
<tbody>
<tr>
<td>核心功能</td>
<td>静态推理（只思考）</td>
<td>推理 + 行动 + 反馈循环</td>
</tr>
<tr>
<td>是否交互</td>
<td>否（纯语言生成）</td>
<td>是（能调用外部工具/环境）</td>
</tr>
<tr>
<td>信息来源</td>
<td>依赖模型训练时的内部知识</td>
<td>内部知识 + 外部输入 + 工具反馈数据（调用工具获取）</td>
</tr>
<tr>
<td>可解释性</td>
<td>高（显式推理链）</td>
<td>更高（推理+行动全可追溯）</td>
</tr>
<tr>
<td>典型应用</td>
<td>逻辑推理、数学题</td>
<td>工具使用、问答、信息检索、任务规划</td>
</tr>
</tbody>
</table>
<p>可以这样理解：</p>
<blockquote>
<p><strong>CoT 让模型“会思考”；
ReAct 让模型“边思考边行动”。</strong></p>
</blockquote>
<p>ReAct 实际上是将 CoT 的“推理链”扩展为一个“推理-行动交替链（Reason–Act Loop）”，使模型能够通过外部信息验证和修正自身推理过程。</p>
<h2> 5. 典型应用场景</h2>
<p>ReAct 框架已成为众多 <strong>LLM Agent 框架的基础逻辑</strong>，例如：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>知识检索 Agent</strong></td>
<td>模型根据推理决定是否调用搜索 API，检索结果再反馈给模型</td>
</tr>
<tr>
<td><strong>任务执行 Agent</strong></td>
<td>模型通过多轮思考与动作完成复杂流程（如预定行程、分析数据）</td>
</tr>
<tr>
<td><strong>工具调用（Tool Use）</strong></td>
<td>ReAct 框架下的模型能自主判断何时调用计算器、数据库或Python执行环境</td>
</tr>
<tr>
<td><strong>多Agent协作</strong></td>
<td>多个 Agent 间通过 ReAct 循环共享中间推理结果，实现协同任务（如 AutoGen、LangGraph）</td>
</tr>
</tbody>
</table>
<p>ReAct 机制也被广泛集成在框架中：</p>
<ul>
<li><strong>LangChain / LangGraph</strong>：ReAct 是默认的 reasoning template；</li>
<li><strong>OpenAI GPTs / o1 系列</strong>：其系统提示内嵌了类似 ReAct 的隐式结构；</li>
<li><strong>DeepSeek-R1 / Claude 3.5</strong>：均具备“内隐 ReAct”式动态推理循环。</li>
</ul>
<h2> 6. ReAct 的优势</h2>
<table>
<thead>
<tr>
<th>优势</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>融合思考与行动</strong></td>
<td>不再需要人工编排先“思考”还是“执行”，模型可自动判断何时行动。</td>
</tr>
<tr>
<td><strong>支持闭环反馈</strong></td>
<td>环境结果反哺推理过程，形成自我纠错机制。 避免出现纯推理(如CoT)容易出现的“想当然”的错误</td>
</tr>
<tr>
<td><strong>可解释性强</strong></td>
<td>每一步 Reason 与 Action 都是可追踪文本，利于调试与评估。</td>
</tr>
<tr>
<td><strong>易扩展</strong></td>
<td>可嵌入任意工具调用接口（API、DB、Web 搜索等）。</td>
</tr>
<tr>
<td><strong>增强记忆与规划能力</strong></td>
<td>多轮 Reasoning 让模型能规划长序列任务，而非一次性输出。</td>
</tr>
<tr>
<td><strong>通用性强</strong></td>
<td>ReAct 不依赖特定任务或工具，只要能拆解步骤、调用工具，就能适用：比如从 “查天气” 到 “采购建筑材料”，从 “旅游规划” 到 “科研数据分析”，只需替换工具和目标，框架本身无需修改，开发效率高</td>
</tr>
</tbody>
</table>
<h2> 7. ReAct 的局限与改进方向</h2>
<table>
<thead>
<tr>
<th>局限</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>推理质量依赖模型本身的 CoT 能力</strong></td>
<td>若模型的逻辑推理弱，ReAct 仍可能走错路线。</td>
</tr>
<tr>
<td><strong>长上下文管理复杂</strong></td>
<td>多轮循环可能导致上下文爆炸，需要 Memory 模块支持。</td>
</tr>
<tr>
<td><strong>计算成本高</strong></td>
<td>每轮 Reason + Act + Observe 都是一条完整的 API 调用。</td>
</tr>
<tr>
<td><strong>缺乏全局规划能力</strong></td>
<td>ReAct 是“逐步决策”，缺乏全局最优策略搜索。</td>
</tr>
</tbody>
</table>
<p>因此，后续研究提出了更高阶的扩展框架，如：</p>
<ul>
<li><strong>Tree-of-Thought (ToT)</strong>：将推理链分支化、多路径搜索；</li>
<li><strong>Reflexion / Self-Refine</strong>：在 ReAct 基础上加入“自我反思”机制；</li>
<li><strong>Graph-of-Thought (GoT)</strong>：通过图结构管理复杂的推理关系。</li>
</ul>
<p>这些框架都继承自 ReAct 的核心思想：<strong>Reason + Act 的循环推理范式</strong>。</p>
<h2> 8. ReAct在Agent中的具体应用示例</h2>
<p><code>ReAct</code> 是 <code>Agent</code> “编排层” 的核心逻辑，要在 <code>Agent</code> 中落地 <code>ReAct</code>，可以按照 “组件搭建→流程设计→优化迭代” 的三板斧进行套路</p>
<h3> 8.1 第一步：搭建Agent的ReAct核心组件</h3>
<p>前面说了ReAct的三个关键组件： Reason(思考)、Act(行动)、Observe(观察)，在具体的Agent实现中，我们还需要额外考虑上下文的管理(Memory)</p>
<p>因此一个Agent要实现ReAct，则应包含下面四个核心模块</p>
<blockquote>
<p>比如我现在给Agent下达一个任务，<code>帮用户采购 100 吨 HRB400E 钢筋，要求 3 天内送达北京朝阳区工地，预算 50 万元</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>组件</th>
<th>功能描述</th>
<th>技术实现参照</th>
</tr>
</thead>
<tbody>
<tr>
<td>思考模块（Reasoner）</td>
<td>接收目标+状态→ 拆解步骤→ 决定下一步行动（比如“调用哪个工具”“参数是什么”）</td>
<td>基于大模型实现（如GPT-4、Gemini、DeepSeek），通过提示工程引导模型生成“行动指令”（比如“调用库存工具，参数：材料型号=HRB400E，数量=100吨”）</td>
</tr>
<tr>
<td>行动执行器（Actor）</td>
<td>解析思考模块的“行动指令”→ 调用对应的工具（API、数据库、RPA等）</td>
<td>搭建工具注册中心（统一管理工具名称、输入输出格式），用函数调用（Function Call）实现模型与工具的对接（比如模型输出JSON格式的行动指令，执行器解析后调用API）</td>
</tr>
<tr>
<td>观察模块（Observer）</td>
<td>获取工具返回结果→ 整理成模型能理解的格式（比如把API返回的JSON转成自然语言）</td>
<td>设计结果标准化模板（比如工具返回“{"supplier":"A","price":3700}"→ 整理为“供应商A的HRB400E钢筋报价3700元/吨”）</td>
</tr>
<tr>
<td>状态记忆模块（Memory）</td>
<td>存储“目标+每一轮的思考/行动/观察结果”→ 为下一轮思考提供上下文</td>
<td>用向量数据库（如Milvus、FAISS）存储长上下文，支持“关键词检索”（比如快速查找“供应商A的履约率”）</td>
</tr>
</tbody>
</table>
<h3> 8.2 第二步：设计 ReAct 闭环执行流程</h3>
<p>依然以上面的建筑材料采购Agent为例</p>
<h4> （1）初始化：明确目标与工具</h4>
<ul>
<li>目标：用户输入“采购100吨HRB400E钢筋，3天内送达北京朝阳工地，预算50万”；</li>
<li>注册工具：库存查询工具、供应商履约率工具、报价对比工具、订单生成工具。</li>
</ul>
<h4> （2）循环执行（直到任务完成/终止）</h4>
<figure><img src="/imgs/column/springai/ag3-02.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>
<p>每一轮的“思考指令”格式示例（模型输出）：</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>观察模块整理结果示例：
“库存查询工具返回3家供应商：1. 供应商A（库存150吨，报价3700元/吨，3天达）；2. 供应商B（库存200吨，报价3800元/吨，2天达）；3. 供应商C（库存120吨，报价3600元/吨，4天达，超期）”</p>
</li>
</ul>
<h4> （3）终止条件设计</h4>
<ul>
<li>成功终止：完成目标（如“采购订单提交成功，供应商A将在3天内送达100吨HRB400E钢筋，总价37万元”）；</li>
<li>失败终止：多次迭代后无法满足目标（如“无符合‘3天达+100吨库存’的供应商，建议延长交货期至4天或更换材料型号”）。</li>
</ul>
<h3> 8.3 第三步：优化 ReAct 执行效率</h3>
<p>实际应用中，需解决“循环次数过多、工具调用错误、推理冗余”等问题，常用优化技巧：</p>
<ul>
<li>① 工具选择策略：思考模块优先选择“高优先级工具”（比如先查库存，再查履约率，避免跳过关键步骤）；</li>
<li>② 状态压缩：记忆模块只保留“关键信息”（比如只记“符合条件的供应商A/B”，忽略C的详细信息），减少大模型上下文压力；</li>
<li>③ 错误重试机制：行动失败（如工具调用超时、返回错误）时，思考模块自动调整参数（比如“重新调用库存工具，增加‘北京周边供应商’筛选条件”）；</li>
<li>④ 少样本示例引导：在思考模块的提示中，加入“问题+ReAct循环示例”，让模型更快掌握推理+行动的节奏（比如给一个“采购水泥”的ReAct示例，让模型模仿）。</li>
</ul>
<h2> 9. 总结：一句话概括 ReAct</h2>
<p><strong>ReAct 是连接“语言模型的思考能力（CoT）”与“Agent 的执行能力”的桥梁。</strong></p>
<p>它让大模型不仅能在语言空间中推理，还能在外部世界中行动；最后再以一张图，来重温一下ReAct</p>
<figure><img src="/imgs/column/springai/ag3-03.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/ag3-01.webp" type="image/webp"/>
    </item>
    <item>
      <title>04.Agent思考框架-Plan-and-Execute</title>
      <link>https://ppai.top/ai-guides/tutorial/hello-agent/04.Agent%E6%80%9D%E8%80%83%E6%A1%86%E6%9E%B6-Plan-and-Execute.html</link>
      <guid>https://ppai.top/ai-guides/tutorial/hello-agent/04.Agent%E6%80%9D%E8%80%83%E6%A1%86%E6%9E%B6-Plan-and-Execute.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">04.Agent思考框架-Plan-and-Execute</source>
      <description>Plan-and-Execute 框架：面向复杂任务的层次化推理与行动架构 1. 引言 随着语言模型推理能力与外部工具使用能力的增强，如何高效地解决长程、多步骤、复杂任务成为 AI Agent 的关键挑战。 传统的 Chain-of-Thought (CoT) 与 ReAct 框架虽能支持推理与行动的结合，但它们通常以逐步生成的方式执行任务，容易陷入“短视（myopic）”问题——即模型缺乏全局规划能力，只能在局部推理层面决策。</description>
      <category>Agent</category>
      <pubDate>Fri, 07 Nov 2025 09:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>Plan-and-Execute 框架：面向复杂任务的层次化推理与行动架构</p>
</blockquote>
<h2> 1. 引言</h2>
<p>随着语言模型推理能力与外部工具使用能力的增强，如何高效地解决<strong>长程、多步骤、复杂任务</strong>成为 AI Agent 的关键挑战。</p>
<p>传统的 <strong>Chain-of-Thought (CoT)</strong> 与 <strong>ReAct</strong> 框架虽能支持推理与行动的结合，但它们通常以<strong>逐步生成的方式</strong>执行任务，容易陷入“短视（myopic）”问题——即模型缺乏全局规划能力，只能在局部推理层面决策。</p>
<p>基于此，就有了 <strong>Plan-and-Execute（计划–执行）框架</strong>，其核心逻辑是 <strong>“先全局规划，再分步执行，全程监控调整”</strong> —— 模仿人类处理复杂任务的模式（比如项目经理做项目计划、旅行博主规划跨城行程），先拆解出完整的任务步骤，再逐一执行，同时根据执行结果动态优化计划，避免 “边想边做” 导致的返工或偏离目标。</p>
<h2> 2. 核心思想</h2>
<p>Plan-and-Execute 的基本理念是：</p>
<blockquote>
<p><strong>让语言模型先“想清楚要做什么”，再“逐步去做”。</strong></p>
</blockquote>
<h3> 2.1 定义</h3>
<p>Plan-and-Execute（简称 “P&amp;E”）是一种 “目标驱动 + 规划先行” 的 Agent 认知架构，核心是将复杂任务拆解为 “可执行的子步骤（计划）”，再逐个执行子步骤，同时监控执行结果，若出现偏差则修正计划，直至完成整体目标。</p>
<h3> 2.2 子系统</h3>
<p>在该框架中，模型被划分为两个协作子系统：</p>
<ol>
<li><strong>Planner（规划器）</strong> —— 负责全局任务分解与阶段性目标设定；</li>
<li><strong>Executor（执行器）</strong> —— 负责逐步执行具体步骤，并根据反馈调整局部行为。</li>
</ol>
<p>相比 ReAct 的“边想边做”模式，Plan-and-Execute 更接近人类在处理复杂任务时的思维方式：</p>
<h3> 2.3 示例说明</h3>
<p>还是以上一篇ReAct中的示例进行扩展说明：<code>完成 “建筑项目跨区域材料调度”（目标：把北京项目的剩余 100 吨钢材，5 天内运到天津项目，预算 10 万元）</code></p>
<p>对于P&amp;E框架，其执行步骤如下：</p>
<ol>
<li>先规划（Plan）：拆分子步骤→
<ul>
<li>① 确认北京项目钢材库存及规格；</li>
<li>② 联系合规物流商报价；</li>
<li>③ 对比物流方案（成本、时效）；</li>
<li>④ 办理材料运输备案；</li>
<li>⑤ 安排装车运输；</li>
<li>⑥ 天津项目验收；</li>
</ul>
</li>
<li>再执行（Execute）：按步骤逐一落地，比如先调用 “库存工具” 确认钢材，再调用 “物流商工具” 报价；</li>
<li>动态调整：若执行中发现 “某物流商报价超预算”，则回到规划环节，补充 “筛选低价物流商” 子步骤，修正后继续执行。</li>
</ol>
<h2> 3. 框架结构</h2>
<h3> 3.1 流程概览</h3>
<p>Plan-and-Execute 框架的核心流程如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在实践中，这两阶段通常由同一个语言模型（或多个模型）协作完成：</p>
<ul>
<li><strong>Planner</strong>：生成多步任务计划，明确每个子任务的目标；</li>
<li><strong>Executor</strong>：逐步执行每个子任务，可调用工具或环境；</li>
<li><strong>Evaluator（可选）</strong>：在执行后评估结果质量，并决定是否重新规划。</li>
</ul>
<h3> 3.2 示例</h3>
<p>假设目标：“为某地铁项目采购3类材料（1000吨HRB400E钢筋、500立方米C30混凝土、200套消防设备），要求20天内全部送达工地，预算800万元，需符合地铁工程质量标准”</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>具体操作（Agent 执行）</th>
</tr>
</thead>
<tbody>
<tr>
<td>① 目标解析（Target Parsing）</td>
<td>拆解目标关键约束：材料类型（3类）、数量、时效（20天）、预算（800万）、质量标准（地铁级）→ 明确“不可妥协条件”（质量、时效）和“可调整条件”（预算浮动5%）</td>
</tr>
<tr>
<td>② 全局规划（Plan Generation）</td>
<td>生成详细子步骤（按逻辑顺序）：<br>1. 校验3类材料的地铁级质量标准参数；<br>2. 筛选符合质量标准的供应商（每类材料≥3家）；<br>3. 向供应商询价，对比报价是否在预算内；<br>4. 确认供应商交货周期（≤20天）；<br>5. 选择最优供应商（质量+价格+时效平衡）；<br>6. 签订采购合同；<br>7. 安排分批次物流运输；<br>8. 工地验收材料（核对质量+数量）</td>
</tr>
<tr>
<td>③ 分步执行（Plan Execution）</td>
<td>按子步骤调用工具执行：<br>- 步骤1：调用“建筑质量标准工具”，获取地铁级材料参数；<br>- 步骤2：调用“供应商筛选工具”，输入参数筛选供应商；<br>- 步骤3：调用“报价工具”，向6家供应商询价；<br>（每执行完一个子步骤，记录结果）</td>
</tr>
<tr>
<td>④ 监控反馈（Monitoring &amp; Feedback）</td>
<td>检查执行结果是否符合计划要求：<br>- 发现“混凝土供应商报价超预算10%”（偏离预算约束）；<br>- 发现“消防设备供应商交货周期25天”（偏离时效约束）；<br>- 整理偏差：2个子步骤未达标，需修正</td>
</tr>
<tr>
<td>⑤ 计划修正（Plan Revision）</td>
<td>基于偏差调整计划：<br>1. 新增“混凝土供应商二次筛选”（要求报价≤预算上限）；<br>2. 新增“消防设备供应商谈判”（要求交货周期≤20天，否则更换）；<br>3. 调整步骤顺序：先谈判消防设备，再二次筛选混凝土供应商；<br>→ 修正后回到“分步执行”环节，继续推进</td>
</tr>
</tbody>
</table>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种结构清晰地展示了规划与执行的分工：Planner 负责构思路线，Executor 负责落实行动。</p>
<h3> 3.3 P&amp;E关键要素</h3>
<p>要让 P&amp;E 框架跑通，Agent 必须具备4个核心能力，对应4个关键组件：</p>
<ul>
<li>① 目标解析能力：能从模糊需求中提取“关键约束”（如质量、时效、预算）和“可调整空间”，避免规划方向跑偏（比如用户没说质量标准，Agent 需自动补充“符合项目所属行业标准”）；</li>
<li>② 规划生成能力：能拆解“颗粒度合适”的子步骤（既不能太粗，比如只拆“选供应商→采购→验收”，也不能太细，比如拆“打开供应商工具→输入参数→点击查询”），且子步骤符合逻辑顺序（如“验收”必须在“运输”之后）；</li>
<li>③ 执行调度能力：能按计划顺序调用工具，处理“并行步骤”（如钢筋和消防设备的询价可同时进行）和“依赖步骤”（如“签订合同”必须在“询价对比”之后）；</li>
<li>④ 监控修正能力：能识别“执行偏差”（如超预算、超时效），并判断是“调整子步骤”（如二次筛选供应商）还是“重新规划”（如预算严重不足，需和用户协商调整目标）。</li>
</ul>
<h2> 4. 与 ReAct 的对比</h2>
<p>P&amp;E 和 ReAct 都属于 Agent 推理框架，但适用场景完全不同，对比清晰：</p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>ReAct(推理-行动)</th>
<th>Plan-and-Execute(规划-执行)</th>
</tr>
</thead>
<tbody>
<tr>
<td>推理方式</td>
<td>推理与行动交替进行</td>
<td>规划与执行分阶段进行</td>
</tr>
<tr>
<td>计划优先级</td>
<td>执行是核心，规划服务于单次执行</td>
<td>规划是核心，执行围绕规划展开</td>
</tr>
<tr>
<td>决策粒度</td>
<td>细粒度、即时决策</td>
<td>粗粒度、全局规划</td>
</tr>
<tr>
<td>步骤关联性</td>
<td>子步骤弱关联（比如查价格后可直接反馈，无需后续步骤）</td>
<td>子步骤强关联（比如 “备案” 必须在 “选物流商” 之后）</td>
</tr>
<tr>
<td>优势</td>
<td>灵活、动态响应环境</td>
<td>结构化、全局性强</td>
</tr>
<tr>
<td>局限</td>
<td>容易迷失方向、循环冗长</td>
<td>计划可能过于刚性，缺乏即时反应</td>
</tr>
<tr>
<td>适用任务</td>
<td>开放式问答、信息检索等简单、短流程、不确定性高的任务（查库存、查价格、物流跟踪）</td>
<td>长程任务、复杂流程、多阶段决策（跨项目调度、大型采购、项目管理）</td>
</tr>
</tbody>
</table>
<p>从本质上看，<strong>ReAct 偏向“思考中的即时行动”，而 Plan-and-Execute 偏向“先计划再执行的理性决策”</strong>。</p>
<p>两者可视为 AI Agent 推理架构的两种互补策略。</p>
<h2> 5. 优势分析</h2>
<p>Plan-and-Execute 的主要优势体现在以下几个方面：</p>
<table>
<thead>
<tr>
<th>优势</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>全局可控性强</strong></td>
<td>通过显式规划步骤，模型行为更可预测、更易解释。</td>
</tr>
<tr>
<td><strong>层次化推理能力</strong></td>
<td>模型能在不同抽象层次上思考任务，从全局到局部逐层细化。</td>
</tr>
<tr>
<td><strong>可复用性高</strong></td>
<td>已生成的计划可复用或共享，便于多Agent协作或任务迁移。</td>
</tr>
<tr>
<td><strong>易于监控与调试</strong></td>
<td>Planner 与 Executor 的独立性使得错误定位更清晰。</td>
</tr>
</tbody>
</table>
<h2> 6. 局限与改进方向</h2>
<p>尽管 Plan-and-Execute 提升了任务结构化程度，但也存在一些局限性：</p>
<table>
<thead>
<tr>
<th>局限</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>计划僵化</strong></td>
<td>若初始计划不合理，后续执行可能陷入错误路径。</td>
</tr>
<tr>
<td><strong>缺乏动态适应能力</strong></td>
<td>对突发情况或环境变化响应较慢。</td>
</tr>
<tr>
<td><strong>计算成本高</strong></td>
<td>需要额外生成和维护计划文本。</td>
</tr>
<tr>
<td><strong>依赖任务分解质量</strong></td>
<td>Planner 的规划能力直接决定整体表现。</td>
</tr>
</tbody>
</table>
<p>为缓解这些问题，研究者提出了一系列改进版本，例如：</p>
<ul>
<li><strong>Reflexion + Plan-and-Execute</strong>：在执行后引入反思机制；</li>
<li><strong>Hierarchical Agent（分层智能体）</strong>：多层 Planner–Executor 架构；</li>
<li><strong>Adaptive Planning</strong>：执行阶段可根据观察结果动态更新计划。</li>
</ul>
<p>这些方法进一步增强了系统的鲁棒性与灵活性。</p>
<h2> 7. 应用与实践</h2>
<p>按“组件搭建→流程设计→优化迭代”三步走，每个步骤都要结合业务场景细化</p>
<h3> 7.1 第一步：搭建 Agent 的 P&amp;E 核心组件</h3>
<p>Agent 要支持 P&amp;E，必须包含5个核心模块（对应 P&amp;E 闭环流程）：</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>功能描述</th>
<th>技术实现建议</th>
</tr>
</thead>
<tbody>
<tr>
<td>目标解析模块（Target Parser）</td>
<td>提取用户需求中的“核心目标+约束条件+可调整空间”，生成标准化目标（如“采购1000吨钢筋，约束：地铁级质量、20天达、预算≤400万”）</td>
<td>基于大模型（如GPT-4、Gemini），通过提示工程引导模型识别约束（比如“从需求中提取材料类型、数量、时效、预算、质量标准”），结合行业数据库补充默认约束（如无质量标准则默认“项目所属行业国标”）</td>
</tr>
<tr>
<td>规划器（Planner）</td>
<td>基于标准化目标，生成“逻辑连贯、颗粒度合适”的子步骤计划，支持“并行/依赖步骤”标记（如“钢筋询价”和“消防设备询价”可并行，“签合同”依赖“询价对比”）</td>
<td>用大模型+少样本示例（比如给“3个采购计划示例”），引导模型生成结构化计划（如JSON格式的子步骤清单，包含“步骤ID、名称、依赖步骤、执行工具、预期结果”）</td>
</tr>
<tr>
<td>执行器（Executor）</td>
<td>按计划顺序调用工具执行子步骤，支持“并行步骤同步执行”“依赖步骤串行执行”，记录每个步骤的实际结果</td>
<td>搭建工具调度中心，管理工具调用优先级（如“验收步骤”优先级高于“询价步骤”），用函数调用（Function Call）对接工具，返回结构化执行结果（如“询价结果：供应商A报价3800元/吨，交货期15天”）</td>
</tr>
<tr>
<td>监控器（Monitor）</td>
<td>对比“执行结果”与“计划预期结果”，识别偏差（如“报价3800元/吨＞预算上限3700元/吨”“交货期15天≤预期20天”），标记偏差类型（预算偏差、时效偏差、质量偏差）</td>
<td>设定偏差阈值（如预算偏差≥5%触发警报），用规则引擎+大模型判断偏差影响（如“预算超10%需重新规划，超3%可谈判”）</td>
</tr>
<tr>
<td>修正器（Reviser）</td>
<td>基于偏差类型，调整计划：① 轻微偏差（如报价超3%）→ 新增子步骤（如“与供应商谈判降价”）；② 严重偏差（如无符合时效的供应商）→ 重新生成全局计划；③ 无法修正（如预算严重不足）→ 反馈用户</td>
<td>用大模型+行业规则，生成修正方案（如“新增谈判步骤，目标降价至3700元/吨以下，若谈判失败则二次筛选供应商”），修正后更新计划清单</td>
</tr>
</tbody>
</table>
<h3> 7.2 第二步：设计 P&amp;E 闭环执行流程（以“跨项目材料调度Agent”为例）</h3>
<h4> （1）初始化：明确目标与资源</h4>
<ul>
<li>目标：用户输入“将北京项目剩余的80吨钢筋、50吨水泥，20天内调度至天津滨海新区项目，总成本≤15万元，钢筋需符合HRB400E标准，水泥需符合P.O42.5标准”；</li>
<li>注册工具：库存盘点工具、供应商资质校验工具、物流报价工具、合规备案工具、运输跟踪工具、验收工具。</li>
</ul>
<h4> （2）闭环执行流程（可视化）</h4>
<figure><img src="/imgs/column/springai/ag4-01.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>
<p>规划器生成的“子步骤计划”示例（JSON格式）：</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>监控器识别偏差示例：
“步骤3执行结果：2家物流商报价，分别为15.8万元、16.5万元，均超预算（15万元），偏差类型：预算偏差，偏差率：5.3%（轻微偏差）”</p>
</li>
<li>
<p>修正器调整计划示例：
“新增步骤4：与报价15.8万元的物流商谈判，目标降价至15万元以下；若谈判失败，新增步骤5：筛选天津本地小型物流商补充报价”</p>
</li>
</ul>
<h4> （3）终止条件设计</h4>
<ul>
<li>成功终止：所有子步骤执行完成，满足核心目标（如“材料已送达天津项目，验收合格，总成本14.8万元，耗时18天”）；</li>
<li>失败终止：多次修正后仍无法满足核心约束（如“所有物流商报价均超18万元，无法压缩至15万元内，且无替代物流方案”），反馈用户并提供备选建议（如“延长运输时间至30天，可降低成本至14.5万元”）。</li>
</ul>
<h3> 7.3 第三步：优化 P&amp;E 执行效率</h3>
<p>P&amp;E 框架的落地难点是<code>规划太复杂、执行效率低、修正频繁</code>，需通过以下技巧优化：</p>
<ul>
<li>① 分层规划（Hierarchical Planning）：把复杂计划拆分为 *<em>主计划+子计划</em>
<ul>
<li>比如“跨项目调度主计划”包含“库存盘点、物流规划、验收”3个主步骤</li>
<li>每个主步骤再拆子计划（如“物流规划”拆“询价、谈判、签约”），避免计划过于冗长；</li>
</ul>
</li>
<li>② 计划压缩（Plan Compression）：只保留<strong>关键步骤</strong>和<strong>约束条件</strong>，忽略细节（如无需在计划中写<code>打开物流工具→输入参数</code>，只需写<code>调用物流工具询价</code>），减少大模型上下文压力；</li>
<li>③ 动态资源分配：执行器支持<strong>并行步骤同步执行</strong>（如同时盘点钢筋和水泥库存），缩短整体周期；对<strong>关键步骤</strong>（如合规备案）分配更多资源（如优先调用工具、超时重试3次）；</li>
<li>④ 少样本规划引导：在规划器的提示中，加入<strong>行业相关的规划示例</strong>（如“建筑材料调度的标准步骤清单”），让模型生成的计划更贴合业务实际，减少修正次数；</li>
<li>⑤ 偏差阈值动态调整：根据任务阶段调整偏差阈值（如前期询价阶段，预算偏差阈值设为10%；后期签约阶段，阈值设为3%），避免过度修正影响效率。</li>
</ul>
<h2> 8. 总结</h2>
<p><strong>Plan-and-Execute 框架</strong> 是一种面向复杂任务的层次化推理与行动机制。</p>
<p>它通过“先规划、再执行”的解耦结构，使模型能够在全局视角下进行任务分解与多阶段执行，从而在可解释性、稳定性和任务规划性上优于 ReAct 等即时推理框架。</p>
<blockquote>
<p><strong>一句话总结：</strong>
<strong>Plan-and-Execute 是让 AI Agent 从“即兴思考者”进化为“有计划的行动者”的关键框架。</strong></p>
</blockquote>
<p>最后再以一张图，来重温一下P&amp;E</p>
<figure><img src="/imgs/column/springai/ag3-03.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/springai/ag4-01.webp" type="image/webp"/>
    </item>
    <item>
      <title>Agent篇</title>
      <link>https://ppai.top/ai-guides/tutorial/hello-agent/</link>
      <guid>https://ppai.top/ai-guides/tutorial/hello-agent/</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">Agent篇</source>
      <description>主要介绍AI Agent相关的知识点，包括相关技术栈，应用开发等</description>
      <pubDate>Thu, 22 Jan 2026 08:45:40 GMT</pubDate>
      <content:encoded><![CDATA[<p>主要介绍AI Agent相关的知识点，包括相关技术栈，应用开发等</p>
]]></content:encoded>
    </item>
    <item>
      <title>LLM 应用开发是什么：零基础也可以读懂的科普文(半小时速成)</title>
      <link>https://ppai.top/ai-guides/tutorial/hello-llm/01.llm%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%95%99%E5%AD%A6%E7%89%88%E6%95%99%E7%A8%8B.html</link>
      <guid>https://ppai.top/ai-guides/tutorial/hello-llm/01.llm%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%95%99%E5%AD%A6%E7%89%88%E6%95%99%E7%A8%8B.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">LLM 应用开发是什么：零基础也可以读懂的科普文(半小时速成)</source>
      <description>LLM 应用开发教学版教程 面向对象：初级程序员 / 对 LLM 有基础认知、希望真正做出 LLM 应用的人 本教程不追求“模型原理深度”，而是帮助你一步步理解：为什么要这样做、如果不这样会出现什么问题。 LLM 应用开发是什么：零基础也可以读懂的科普文(极简版)</description>
      <category>LLM</category>
      <pubDate>Mon, 29 Dec 2025 17:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1> LLM 应用开发教学版教程</h1>
<blockquote>
<p>面向对象：初级程序员 / 对 LLM 有基础认知、希望真正做出 LLM 应用的人</p>
<p>本教程不追求“模型原理深度”，而是帮助你<strong>一步步理解：为什么要这样做、如果不这样会出现什么问题</strong>。</p>
<p><a href="https://mp.weixin.qq.com/s/qCn8x2XO2shA8MheYbHq0w" target="_blank" rel="noopener noreferrer">LLM 应用开发是什么：零基础也可以读懂的科普文(极简版)</a></p>
</blockquote>
<hr>
<h2> 第 0 章：为什么现在的程序员，绕不开 LLM？</h2>
<p>在正式开始写代码之前，我们先停下来思考一个问题：</p>
<blockquote>
<p><strong>如果你已经会写后端、前端、脚本、接口，那 LLM 对你来说到底意味着什么？</strong></p>
</blockquote>
<p>很多初学者一开始接触 LLM，会有两种极端反应：</p>
<ul>
<li>一种是：<em>“这不就是个更聪明的聊天机器人吗？”</em></li>
<li>另一种是：<em>“以后是不是不用写代码了？”</em></li>
</ul>
<p>这两种理解，其实都不太准确。</p>
<p>这一章，我们只做一件事：</p>
<blockquote>
<p><strong>帮你建立一个“正确的位置感”：LLM 在软件系统中，究竟扮演什么角色。</strong></p>
</blockquote>
<hr>
<h3> 0.1 传统程序解决问题的方式，有什么局限？</h3>
<p>先回到你熟悉的世界。</p>
<p>在没有 LLM 之前，一个程序通常是这样工作的：</p>
<ul>
<li>输入是<strong>结构化的</strong>（表单、参数、JSON）</li>
<li>逻辑是<strong>确定的</strong>（if / else、规则、流程）</li>
<li>输出是<strong>可预期的</strong></li>
</ul>
<p>这套模式非常稳定，也非常可靠。</p>
<p>但它有一个明显前提：</p>
<blockquote>
<p><strong>问题本身，必须是“可以被提前描述清楚的”。</strong></p>
</blockquote>
<p>举几个你可能遇到过的真实场景：</p>
<ul>
<li>用户输入一段“很随意”的自然语言描述</li>
<li>文档是 PDF / Word / Markdown，结构混乱</li>
<li>用户的问题，每次问法都不一样</li>
</ul>
<p>这时你会发现：</p>
<blockquote>
<p>👉 规则开始爆炸
👉 if / else 越来越多
👉 覆盖不全、维护困难</p>
</blockquote>
<p>不是你写得不好，而是<strong>问题本身已经不适合用纯规则解决了</strong>。</p>
<hr>
<h3> 0.2 LLM 带来的真正变化是什么？</h3>
<p>LLM 并没有取代程序员，它真正改变的是这一点：</p>
<blockquote>
<p><strong>程序第一次拥有了“理解非结构化输入”的能力。</strong></p>
</blockquote>
<p>注意这里的关键词：</p>
<ul>
<li>不是“理解世界”</li>
<li>而是“理解语言形式上的意图”</li>
</ul>
<p>这意味着什么？</p>
<p>以前你需要做的事情是：</p>
<blockquote>
<p>把用户输入 → 强行变成结构化数据 → 再处理</p>
</blockquote>
<p>而现在你可以：</p>
<blockquote>
<p>把“理解这件事”本身，交给模型</p>
</blockquote>
<p>程序员的角色开始发生变化：</p>
<ul>
<li>从“写规则的人”</li>
<li>变成“设计约束和流程的人”</li>
</ul>
<p>这也是为什么我们说：</p>
<blockquote>
<p><strong>LLM 应用开发，本质是工程问题，而不是模型问题。</strong></p>
</blockquote>
<hr>
<h3> 0.3 什么叫“LLM 应用开发”？</h3>
<p>很多人一开始会把 LLM 应用理解为：</p>
<blockquote>
<p>“写几个 Prompt，调个 API，就完了”</p>
</blockquote>
<p>但在真实项目中，很快你就会遇到这些问题：</p>
<ul>
<li>模型有时会胡说八道</li>
<li>对话一长，它就开始“失忆”</li>
<li>不同用户，需要不同风格的回答</li>
<li>数据是私有的，模型根本没见过</li>
</ul>
<p>于是你会发现：</p>
<blockquote>
<p><strong>真正的 LLM 应用 = 模型 + 工程系统</strong></p>
</blockquote>
<p>一个完整的 LLM 应用，通常至少包含：</p>
<ul>
<li>模型调用（API）</li>
<li>提示词设计（Prompt）</li>
<li>上下文与记忆管理</li>
<li>外部知识接入（RAG）</li>
<li>工具 / 接口调用（Function Calling）</li>
</ul>
<p>本教程接下来所有内容，都会围绕这些组件展开。</p>
<hr>
<h3> 0.4 在开始之前，你需要一个心理预期</h3>
<p>在正式进入技术细节前，有三点非常重要的心理预期：</p>
<ol>
<li>
<p><strong>LLM 不是银弹</strong><br>
它能解决一类问题，但不是所有问题。</p>
</li>
<li>
<p><strong>LLM 会犯错，而且看起来很自信</strong><br>
你必须为它设计“兜底机制”。</p>
</li>
<li>
<p><strong>写好 LLM 应用，比写 Demo 难得多</strong><br>
真正的难点在工程设计，而不是 API 调用。</p>
</li>
</ol>
<p>如果你带着这个预期继续往下读，后面的内容会顺很多。</p>
<hr>
<h3> 本章小结</h3>
<p>这一章你只需要记住三件事：</p>
<ul>
<li>LLM 的价值，在于处理非结构化语言</li>
<li>LLM 应用开发，是一门工程能力</li>
<li>后面的每一章，都是为了解决一个“你一定会遇到的问题”</li>
</ul>
<p>下一章，我们不会立刻写代码，而是先回答一个更基础的问题：</p>
<blockquote>
<p><strong>LLM 到底能做什么？又有哪些事情，是它天然做不好的？</strong></p>
</blockquote>
<hr>
<h2> 第 1 章：LLM 能做什么？不能做什么？</h2>
<p>在真正开始调用模型之前，我们必须先回答一个非常现实的问题：</p>
<blockquote>
<p><strong>哪些问题适合交给 LLM？哪些问题一开始就不该用它？</strong></p>
</blockquote>
<p>如果这个判断一开始就错了，后面 Prompt 写得再好、RAG 再复杂，效果也很难理想。</p>
<p>这一章的目标只有一个：</p>
<blockquote>
<p><strong>帮你建立对 LLM 能力边界的直觉判断。</strong></p>
</blockquote>
<hr>
<h3> 1.1 LLM 最擅长做的事情是什么？</h3>
<p>先说结论：</p>
<blockquote>
<p><strong>LLM 最擅长的，是“处理语言本身”。</strong></p>
</blockquote>
<p>这里的“处理”，并不是指“懂世界”，而是指：</p>
<ul>
<li>理解语言里的意图</li>
<li>生成符合上下文的自然语言</li>
<li>在已有信息基础上进行组织、改写、总结</li>
</ul>
<p>你可以把 LLM 想象成一个：</p>
<blockquote>
<p><strong>极其擅长阅读、写作和模仿语言风格的系统</strong></p>
</blockquote>
<p>基于这一点，它在下面这些场景中，往往表现得很好。</p>
<hr>
<h4> 场景一：信息整理与改写</h4>
<p>例如：</p>
<ul>
<li>把一段很长的文字总结成要点</li>
<li>把技术文档改写成用户能看懂的说明</li>
<li>把零散的会议记录整理成结构化结论</li>
</ul>
<p>这些任务的共同点是：</p>
<ul>
<li>输入是自然语言</li>
<li>输出仍然是自然语言</li>
<li>不要求“绝对精确”，而是“整体合理”</li>
</ul>
<p>LLM 在这类任务上，往往比纯规则系统简单得多、效果也更好。</p>
<hr>
<h4> 场景二：基于上下文的问答</h4>
<p>例如：</p>
<ul>
<li>“帮我解释一下这段代码在干什么”</li>
<li>“根据这份文档，回答用户的问题”</li>
<li>“用更通俗的方式解释这个概念”</li>
</ul>
<p>只要你能把<strong>必要的信息</strong>提供给模型，它就能基于上下文进行回答。</p>
<p>这也是后面 RAG 技术存在的根本原因。</p>
<hr>
<h4> 场景三：语言风格与角色模拟</h4>
<p>你可能已经体验过：</p>
<ul>
<li>让模型用“老师的口吻”解释问题</li>
<li>用“客服风格”回复用户</li>
<li>模拟某种固定的写作风格</li>
</ul>
<p>这并不是模型“在演戏”，而是因为：</p>
<blockquote>
<p><strong>语言风格本身，就是一种可以被学习的模式。</strong></p>
</blockquote>
<hr>
<h3> 1.2 那它不擅长什么？</h3>
<p>理解 LLM 的能力边界，比理解它的能力本身更重要。</p>
<p>下面这些事情，是 LLM <strong>天然就不擅长</strong>，甚至是“危险的”。</p>
<hr>
<h4> 不擅长一：精确计算和绝对正确性</h4>
<p>LLM 并不是计算器。</p>
<p>当你问它：</p>
<ul>
<li>精确的数学结果</li>
<li>严格的逻辑证明</li>
<li>每一步都不能出错的推导</li>
</ul>
<p>它<strong>有可能给你一个“看起来合理，但实际上错误”的答案</strong>。</p>
<p>原因很简单：</p>
<blockquote>
<p><strong>它追求的是“语言上的合理性”，而不是“结果上的正确性”。</strong></p>
</blockquote>
<hr>
<h4> 不擅长二：最新、私有或未提供的信息</h4>
<p>模型的训练数据是有限的。</p>
<p>如果你问它：</p>
<ul>
<li>最新发生的事情</li>
<li>公司内部的数据</li>
<li>你电脑里的某个文件内容</li>
</ul>
<p>在没有额外手段的情况下，它只能：</p>
<blockquote>
<p><strong>猜一个最像真的答案</strong></p>
</blockquote>
<p>这正是“幻觉”问题的来源之一。</p>
<hr>
<h4> 不擅长三：替你做判断和承担责任</h4>
<p>LLM 可以给你建议，但它：</p>
<ul>
<li>不对结果负责</li>
<li>不知道真实世界的后果</li>
<li>无法替你做价值判断</li>
</ul>
<p>所以在：</p>
<ul>
<li>法律</li>
<li>医疗</li>
<li>金融决策</li>
</ul>
<p>等高风险场景中，<strong>它只能作为辅助，而不能作为最终决策者</strong>。</p>
<hr>
<h3> 1.3 一个非常重要的结论</h3>
<p>到这里，我们可以得出一个对后续所有章节都非常重要的结论：</p>
<blockquote>
<p><strong>LLM 适合做“语言层面的智能”，而不是“事实层面的权威”。</strong></p>
</blockquote>
<p>这句话你可以多读几遍。</p>
<p>它几乎解释了后面所有技术为什么存在：</p>
<ul>
<li>Prompt：为了让模型“更好地理解你想要什么”</li>
<li>上下文管理：为了让模型“别忘了已经说过什么”</li>
<li>RAG：为了让模型“基于真实资料说话”</li>
<li>Function Calling：为了让模型“不要自己瞎编，而是去调用系统”</li>
</ul>
<hr>
<h3> 本章小结</h3>
<p>这一章，你只需要记住三点：</p>
<ol>
<li>LLM 擅长处理自然语言</li>
<li>LLM 不保证事实绝对正确</li>
<li>用不用 LLM，首先是一个<strong>工程判断</strong></li>
</ol>
<p>下一章，我们终于要开始真正“用模型”了。</p>
<p>但在写任何复杂逻辑之前，我们会先做一件很基础、但非常关键的事情：</p>
<blockquote>
<p><strong>把 LLM 接进你的程序，搞清楚你到底在和什么交互。</strong></p>
</blockquote>
<hr>
<h2> 第 2 章：第一次把 LLM 接进你的程序</h2>
<p>在前两章，我们一直在讲“为什么”和“能不能”。</p>
<p>从这一章开始，我们终于要做一件非常具体的事情：</p>
<blockquote>
<p><strong>把大语言模型，当成一个真正的系统组件，接进你的程序里。</strong></p>
</blockquote>
<p>这一章不会追求复杂功能，它的目标只有一个：</p>
<blockquote>
<p><strong>让你清楚：你到底在和什么交互。</strong></p>
</blockquote>
<p>如果这一点没想清楚，后面所有 Prompt、RAG、Agent，都会变成“玄学调参”。</p>
<hr>
<h3> 2.1 调用 LLM，本质上是在做什么？</h3>
<p>先说一个非常容易被忽略的事实：</p>
<blockquote>
<p><strong>你调用 LLM，并不是在“和一个人聊天”。</strong></p>
</blockquote>
<p>从工程角度看，你在做的事情其实是：</p>
<ul>
<li>构造一次请求</li>
<li>把一段上下文发给模型</li>
<li>让模型基于这些上下文，生成下一段文本</li>
</ul>
<p>也就是说：</p>
<blockquote>
<p><strong>每一次调用，模型都是“一次性地”看完整个输入。</strong></p>
</blockquote>
<p>它不会自动记住你上一次说了什么，除非：</p>
<blockquote>
<p>👉 你把这些内容，再一次发给它</p>
</blockquote>
<p>这个认知，对理解后面的“上下文管理”非常重要。</p>
<hr>
<h3> 2.2 messages：你真正传给模型的是什么？</h3>
<p>在大多数 LLM API 中，你都会看到一个类似的结构：</p>
<ul>
<li>model</li>
<li>messages</li>
</ul>
<p>其中，<code>messages</code> 往往是一个列表，看起来像是“聊天记录”。</p>
<p>但从模型的视角来看：</p>
<blockquote>
<p><strong>它不是聊天记录，而是一段“完整的输入文本”。</strong></p>
</blockquote>
<p>模型并不知道哪一句是“刚刚发生的”，
它只看到：</p>
<blockquote>
<p>“现在，有这样一段内容，请继续往下写。”</p>
</blockquote>
<hr>
<h3> 2.3 system / user / assistant 角色，到底有什么用？</h3>
<p>在 <code>messages</code> 中，通常会看到三种角色：</p>
<ul>
<li>system</li>
<li>user</li>
<li>assistant</li>
</ul>
<p>很多初学者会以为：</p>
<blockquote>
<p>“这些角色是给模型‘分身份’用的。”</p>
</blockquote>
<p>但更准确的理解是：</p>
<blockquote>
<p><strong>它们是用来给模型不同“权重和语义提示”的。</strong></p>
</blockquote>
<hr>
<h4> system：全局约束和行为边界</h4>
<p><code>system</code> 的作用是：</p>
<blockquote>
<p><strong>告诉模型：你是谁，你应该如何整体地表现。</strong></p>
</blockquote>
<p>例如：</p>
<ul>
<li>你是一个严谨的技术助手</li>
<li>回答时不要编造不存在的内容</li>
<li>输出必须是 JSON 格式</li>
</ul>
<p>你可以把 <code>system</code> 理解为：</p>
<blockquote>
<p><strong>整次生成过程的“最高优先级说明书”</strong></p>
</blockquote>
<hr>
<h4> user：具体任务和问题</h4>
<p><code>user</code> 消息，通常代表：</p>
<ul>
<li>当前用户提出的问题</li>
<li>当前这一次调用想要完成的任务</li>
</ul>
<p>它关注的是：</p>
<blockquote>
<p><strong>这一次你希望模型做什么。</strong></p>
</blockquote>
<hr>
<h4> assistant：历史输出，用来“延续上下文”</h4>
<p><code>assistant</code> 并不是模型自己生成的“实时内容”，
而是：</p>
<blockquote>
<p><strong>你主动提供给模型的、它“之前说过的话”。</strong></p>
</blockquote>
<p>这样做的目的只有一个：</p>
<blockquote>
<p><strong>让模型在新的生成中，延续之前的对话风格和内容。</strong></p>
</blockquote>
<hr>
<h3> 2.4 一个重要但反直觉的结论</h3>
<p>到这里，我们可以得出一个非常关键的结论：</p>
<blockquote>
<p><strong>模型并不“记得”任何东西，除非你把它再发给它。</strong></p>
</blockquote>
<p>所谓的“多轮对话”，在工程上其实是：</p>
<blockquote>
<p><strong>你不断把历史对话，重新打包发给模型。</strong></p>
</blockquote>
<p>这也解释了两个常见现象：</p>
<ul>
<li>对话越长，成本越高</li>
<li>对话越长，模型越容易“跑偏”</li>
</ul>
<p>这不是模型变笨了，而是：</p>
<blockquote>
<p><strong>输入变得又长又杂了。</strong></p>
</blockquote>
<hr>
<h3> 2.5 为什么这一章不急着讲 Prompt 技巧？</h3>
<p>你可能已经注意到：</p>
<blockquote>
<p>这一章我们几乎没有讲“怎么写 Prompt”。</p>
</blockquote>
<p>这是刻意的。</p>
<p>因为在你没有理解：</p>
<ul>
<li>模型怎么看输入</li>
<li>角色是怎么影响生成的</li>
<li>上下文是如何被一次性消费的</li>
</ul>
<p>之前，所有 Prompt 技巧，都会变成：</p>
<blockquote>
<p>“试出来的经验，而不是可复用的方法。”</p>
</blockquote>
<hr>
<h3> 本章小结</h3>
<p>这一章你需要记住的，其实只有三点：</p>
<ol>
<li>LLM API 是一次性生成，不是持续对话</li>
<li>messages 是完整输入，而不是增量补丁</li>
<li>system / user / assistant 是语义提示工具</li>
</ol>
<p>下一章，我们终于要开始面对一个所有人都会遇到的问题：</p>
<blockquote>
<p><strong>为什么我明明说得很清楚，模型却总是答非所问？</strong></p>
</blockquote>
<p>这将引出 LLM 应用开发中，最基础、也是最容易被误解的一件事：</p>
<blockquote>
<p><strong>Prompt 的本质。</strong></p>
</blockquote>
<hr>
<h2> 第 3 章：为什么模型总是答非所问？——Prompt 的本质</h2>
<p>如果你已经实际调用过 LLM，大概率遇到过这样的情况：</p>
<blockquote>
<p>你觉得自己已经说得很清楚了，
但模型给你的回答却：</p>
<ul>
<li>跑题</li>
<li>太泛</li>
<li>或者完全不是你想要的形式</li>
</ul>
</blockquote>
<p>于是你开始不断修改 Prompt：</p>
<ul>
<li>多加几句话</li>
<li>换一种说法</li>
<li>反复“试到对”为止</li>
</ul>
<p>这一章，我们要解决的正是这个问题：</p>
<blockquote>
<p><strong>为什么 Prompt 会失效？以及，什么才是“有效 Prompt”的本质。</strong></p>
</blockquote>
<hr>
<h3> 3.1 一个常见误区：把 Prompt 当成“问题”</h3>
<p>很多初学者写 Prompt 时，脑子里想的是：</p>
<blockquote>
<p>“我该怎么把问题问清楚？”</p>
</blockquote>
<p>但模型接收到的，并不是一个“问题”，而是：</p>
<blockquote>
<p><strong>一段用来继续生成文本的上下文。</strong></p>
</blockquote>
<p>这意味着：</p>
<ul>
<li>模型不会自动帮你补全目标</li>
<li>也不会自动知道你“想用这个结果干嘛”</li>
</ul>
<p>如果上下文里没有清楚地体现任务，
模型只能按照“语言概率”自由发挥。</p>
<hr>
<h3> 3.2 Prompt 的真实角色：任务说明书</h3>
<p>一个更准确的理解是：</p>
<blockquote>
<p><strong>Prompt 不是提问，而是任务说明书。</strong></p>
</blockquote>
<p>想象你把一项工作交给一个新同事：</p>
<ul>
<li>你会只丢一句话给他吗？</li>
<li>还是会说明：
<ul>
<li>要做什么</li>
<li>用什么方式做</li>
<li>结果要长什么样</li>
</ul>
</li>
</ul>
<p>LLM 也是一样。</p>
<p>当你只给它一句模糊的问题时，
它只能给你一个“看起来像回答”的文本。</p>
<hr>
<h3> 3.3 一个有效 Prompt，至少要回答三个问题</h3>
<p>从工程角度看，一个可控的 Prompt，通常需要明确三件事：</p>
<hr>
<h4> 第一件事：你希望它“扮演什么角色”？</h4>
<p>这通常通过 <code>system</code> 或开头的角色描述完成。</p>
<p>例如：</p>
<ul>
<li>你是一个资深 Java 后端工程师</li>
<li>你是一个严谨的技术文档助手</li>
</ul>
<p>角色并不是装饰，而是在<strong>限制生成空间</strong>。</p>
<hr>
<h4> 第二件事：你希望它“完成什么任务”？</h4>
<p>这里要避免的，是只描述问题本身。</p>
<p>更好的方式是直接说明：</p>
<ul>
<li>请你做分析</li>
<li>请你给出步骤</li>
<li>请你输出结构化结果</li>
</ul>
<p>也就是说：</p>
<blockquote>
<p><strong>直接告诉模型你要的“动作”，而不是只给素材。</strong></p>
</blockquote>
<hr>
<h4> 第三件事：你希望“结果长什么样”？</h4>
<p>这是最容易被忽略的一点。</p>
<p>模型并不知道你：</p>
<ul>
<li>是要一段解释</li>
<li>还是一份列表</li>
<li>还是 JSON / Markdown</li>
</ul>
<p>如果你不说明，
它会选择“最通用、最安全”的输出方式。</p>
<hr>
<h3> 3.4 Zero-shot 和 Few-shot，是怎么被“逼出来的”？</h3>
<p>当你发现：</p>
<blockquote>
<p>“我已经写得很清楚了，它还是不稳定”</p>
</blockquote>
<p>通常不是模型不够聪明，而是：</p>
<blockquote>
<p><strong>它不知道你心里那个‘参考答案长什么样’。</strong></p>
</blockquote>
<p>这时，就会自然出现两种做法。</p>
<hr>
<h4> Zero-shot：只给说明，不给示例</h4>
<ul>
<li>适合规则简单、边界清晰的任务</li>
<li>成本低，但不稳定</li>
</ul>
<hr>
<h4> Few-shot：直接给几个示例</h4>
<ul>
<li>告诉模型：
<blockquote>
<p>“照着这个样子来”</p>
</blockquote>
</li>
</ul>
<p>示例的作用不是“教知识”，而是：</p>
<blockquote>
<p><strong>在输入中，明确什么是“好输出”。</strong></p>
</blockquote>
<hr>
<h3> 3.5 为什么 Prompt 永远不可能解决所有问题？</h3>
<p>到这里，你可能会产生一个错觉：</p>
<blockquote>
<p>“那我是不是只要把 Prompt 写得足够复杂就行了？”</p>
</blockquote>
<p>很遗憾，答案是否定的。</p>
<p>原因在于：</p>
<ul>
<li>Prompt 仍然只是文本</li>
<li>模型仍然只是在“生成下一个词”</li>
</ul>
<p>当任务涉及：</p>
<ul>
<li>真实世界的事实</li>
<li>私有或大量数据</li>
<li>严格的一致性要求</li>
</ul>
<p><strong>Prompt 的能力就会到达上限。</strong></p>
<p>这不是技巧问题，而是能力边界问题。</p>
<hr>
<h3> 本章小结</h3>
<p>这一章，你需要记住的不是“Prompt 模板”，而是三个核心认知：</p>
<ol>
<li>Prompt 是任务说明书，不是问题</li>
<li>角色、任务、输出格式同样重要</li>
<li>Prompt 有上限，不能解决所有问题</li>
</ol>
<p>下一章，我们将面对另一个所有人都会遇到的现实问题：</p>
<blockquote>
<p><strong>聊着聊着，模型为什么就开始“忘事”了？</strong></p>
</blockquote>
<p>这将引出 LLM 应用开发中，非常关键的一环：</p>
<blockquote>
<p><strong>上下文与记忆管理。</strong></p>
</blockquote>
<hr>
<h2> 第 4 章：聊着聊着它就忘了？——上下文与记忆管理</h2>
<p>当你把 Prompt 写得越来越清楚之后，通常会遇到下一个问题：</p>
<blockquote>
<p>对话刚开始时一切正常，
但聊着聊着，模型就开始：</p>
<ul>
<li>忘记前面说过的约束</li>
<li>前后回答自相矛盾</li>
<li>或者突然换了一种风格</li>
</ul>
</blockquote>
<p>很多初学者会直觉地认为：</p>
<blockquote>
<p>“是不是模型不稳定？”</p>
</blockquote>
<p>但实际上，问题几乎从来不在模型身上。</p>
<p>这一章，我们要彻底讲清楚：</p>
<blockquote>
<p><strong>LLM 为什么会‘忘事’，以及我们在工程上该如何应对。</strong></p>
</blockquote>
<hr>
<h3> 4.1 一个必须先打破的误解：模型并没有记忆</h3>
<p>先说结论：</p>
<blockquote>
<p><strong>LLM 本身并不具备持续记忆。</strong></p>
</blockquote>
<p>在第 2 章我们已经提到过：</p>
<ul>
<li>每一次调用</li>
<li>模型看到的都是<strong>一次性完整输入</strong></li>
</ul>
<p>这意味着：</p>
<blockquote>
<p><strong>所谓“记住”，只是你把历史内容再次发给了它。</strong></p>
</blockquote>
<p>如果你没有把某段信息放进当前请求中，
那对模型来说，这段信息就是不存在的。</p>
<hr>
<h3> 4.2 什么是上下文窗口？（直觉理解）</h3>
<p>模型并不是可以无限读取输入的。</p>
<p>它有一个限制，通常被称为：</p>
<blockquote>
<p><strong>上下文窗口（Context Window）</strong></p>
</blockquote>
<p>你可以把它想象成：</p>
<blockquote>
<p>模型在生成回答时，
能“同时看到”的最大文本长度。</p>
</blockquote>
<p>当输入内容超过这个长度时：</p>
<ul>
<li>早期的内容会被截断</li>
<li>或者根本无法被模型同时考虑</li>
</ul>
<p>于是就会出现一种现象：</p>
<blockquote>
<p><strong>模型并不是选择性遗忘，而是根本“看不到”。</strong></p>
</blockquote>
<hr>
<h3> 4.3 为什么对话越长，效果越容易变差？</h3>
<p>即使没有超过上下文窗口，
对话变长也会带来新的问题。</p>
<p>原因主要有三个：</p>
<hr>
<h4> 原因一：重要信息被淹没</h4>
<p>当你把大量历史对话一股脑塞给模型时：</p>
<ul>
<li>新的任务</li>
<li>旧的闲聊</li>
<li>无关的中间推理</li>
</ul>
<p>都会混在一起。</p>
<p>模型并不知道：</p>
<blockquote>
<p>哪些是“你现在最关心的”。</p>
</blockquote>
<hr>
<h4> 原因二：早期约束逐渐失效</h4>
<p>即使你在最开始的 <code>system</code> 中设定了规则，</p>
<p>随着输入变长：</p>
<ul>
<li>后续内容的影响会越来越大</li>
<li>早期指令的“权重”会被稀释</li>
</ul>
<p>于是你会感觉：</p>
<blockquote>
<p>模型开始“不听话了”。</p>
</blockquote>
<hr>
<h4> 原因三：成本和延迟直线上升</h4>
<p>上下文越长：</p>
<ul>
<li>每次调用消耗的 token 越多</li>
<li>响应时间越长</li>
<li>成本越不可控</li>
</ul>
<p>这在真实系统中，往往是不可接受的。</p>
<hr>
<h3> 4.4 工程上常见的三种记忆策略</h3>
<p>既然不能无限塞上下文，
那工程上通常会怎么做？</p>
<p>实际上，常见的策略只有三种。</p>
<hr>
<h4> 策略一：全量上下文（最简单，也最脆弱）</h4>
<p>做法：</p>
<ul>
<li>把所有历史对话原样保留</li>
<li>每次请求全部发送</li>
</ul>
<p>优点：</p>
<ul>
<li>实现最简单</li>
<li>短对话效果好</li>
</ul>
<p>缺点：</p>
<ul>
<li>极易超出上下文窗口</li>
<li>成本高</li>
<li>长对话必然失控</li>
</ul>
<p>适合：</p>
<ul>
<li>Demo</li>
<li>非常短的交互</li>
</ul>
<hr>
<h4> 策略二：摘要记忆（折中方案）</h4>
<p>做法：</p>
<ul>
<li>定期把历史对话压缩成摘要</li>
<li>只保留关键信息和结论</li>
</ul>
<p>这样做的本质是：</p>
<blockquote>
<p><strong>用“信息密度”，换“上下文长度”。</strong></p>
</blockquote>
<p>优点：</p>
<ul>
<li>成本可控</li>
<li>能保留整体语义</li>
</ul>
<p>缺点：</p>
<ul>
<li>细节不可逆丢失</li>
<li>摘要质量直接影响效果</li>
</ul>
<hr>
<h4> 策略三：向量记忆（为后面 RAG 做铺垫）</h4>
<p>做法：</p>
<ul>
<li>把历史信息向量化</li>
<li>在需要时进行检索</li>
<li>只把相关内容送入上下文</li>
</ul>
<p>这种方式的关键思想是：</p>
<blockquote>
<p><strong>不是“全记住”，而是“按需回忆”。</strong></p>
</blockquote>
<p>优点：</p>
<ul>
<li>可扩展</li>
<li>不受上下文长度限制</li>
</ul>
<p>缺点：</p>
<ul>
<li>实现复杂</li>
<li>需要额外系统支持</li>
</ul>
<hr>
<h3> 4.5 一个重要的工程认知</h3>
<p>到这里，你应该能意识到一件事：</p>
<blockquote>
<p><strong>上下文管理不是 Prompt 问题，而是系统设计问题。</strong></p>
</blockquote>
<p>很多“模型突然变差”的问题，
本质上都是：</p>
<ul>
<li>信息组织失败</li>
<li>重要内容没有被正确送达</li>
</ul>
<p>这也是为什么：</p>
<blockquote>
<p><strong>只靠 Prompt，永远做不好复杂对话系统。</strong></p>
</blockquote>
<hr>
<h3> 本章小结</h3>
<p>这一章你需要记住的核心点是：</p>
<ol>
<li>模型没有记忆，只有你提供的上下文</li>
<li>上下文窗口是硬限制</li>
<li>记忆策略是工程取舍</li>
</ol>
<p>下一章，我们将面对一个更棘手、也更危险的问题：</p>
<blockquote>
<p><strong>模型为什么会“一本正经地胡说八道”？</strong></p>
</blockquote>
<p>这将引出 LLM 应用开发中，绕不开的主题：</p>
<blockquote>
<p><strong>幻觉问题。</strong></p>
</blockquote>
<hr>
<h2> 第 5 章：它为什么会“一本正经地胡说八道”？——幻觉问题</h2>
<p>如果你已经按照前面的章节做过一些尝试，那么很可能遇到过下面这种情况：</p>
<blockquote>
<p>模型回答得非常完整，
语气也很自信，
逻辑看起来还挺通顺，
但你越核对，越发现哪里不对。</p>
</blockquote>
<p>很多人第一次遇到这种情况时，都会有点“崩溃”：</p>
<blockquote>
<p>“这也太不靠谱了吧？”</p>
</blockquote>
<p>这一章，我们要做的不是吐槽模型，
而是回答一个非常关键的问题：</p>
<blockquote>
<p><strong>模型为什么会胡说八道？而且还说得这么像真的？</strong></p>
</blockquote>
<hr>
<h3> 5.1 先说结论：幻觉不是 Bug</h3>
<p>先给出一个可能有点反直觉的结论：</p>
<blockquote>
<p><strong>幻觉不是模型的 Bug，而是它工作方式的自然结果。</strong></p>
</blockquote>
<p>回到最本质的一点：</p>
<ul>
<li>LLM 的目标是</li>
<li>在给定上下文下</li>
<li>生成“最可能出现的下一个词”</li>
</ul>
<p>注意这里的关键词是：</p>
<blockquote>
<p><strong>“最可能”，而不是“最正确”。</strong></p>
</blockquote>
<p>当模型面对一个它并不真正“知道答案”的问题时，
它并不会停下来告诉你“我不知道”。</p>
<p>相反，它会：</p>
<blockquote>
<p><strong>尽可能生成一个“看起来合理”的答案。</strong></p>
</blockquote>
<p>这就是幻觉的根源。</p>
<hr>
<h3> 5.2 幻觉通常在什么情况下出现？</h3>
<p>虽然幻觉不可避免，但它并不是随机发生的。</p>
<p>在工程实践中，幻觉往往集中出现在以下几类场景。</p>
<hr>
<h4> 场景一：信息不完整或上下文模糊</h4>
<p>当你给模型的信息不足时：</p>
<ul>
<li>问题范围很大</li>
<li>关键条件没有说明</li>
<li>或者上下文前后矛盾</li>
</ul>
<p>模型只能“自行补全”。</p>
<p>而补全的依据，只能是训练时学到的语言模式。</p>
<hr>
<h4> 场景二：询问模型并不具备的知识</h4>
<p>例如：</p>
<ul>
<li>最新发生的事件</li>
<li>公司内部的业务数据</li>
<li>你本地系统的状态</li>
</ul>
<p>在这些情况下，</p>
<blockquote>
<p><strong>模型既看不到真实数据，也无法访问外部系统。</strong></p>
</blockquote>
<p>于是它只能编一个。</p>
<hr>
<h4> 场景三：要求模型给出“权威结论”</h4>
<p>当你让模型：</p>
<ul>
<li>下判断</li>
<li>给结论</li>
<li>承担决策责任</li>
</ul>
<p>幻觉风险会显著升高。</p>
<p>因为模型并不知道：</p>
<blockquote>
<p>错了会有什么后果。</p>
</blockquote>
<hr>
<h3> 5.3 为什么幻觉在真实应用中很危险？</h3>
<p>在一些轻量场景中，幻觉可能只是“有点不准”。</p>
<p>例如：</p>
<ul>
<li>聊天</li>
<li>头脑风暴</li>
<li>文案草稿</li>
</ul>
<p>但在下面这些场景中，幻觉是不可接受的：</p>
<ul>
<li>企业知识问答</li>
<li>技术文档查询</li>
<li>法律、医疗、金融相关系统</li>
</ul>
<p>原因很简单：</p>
<blockquote>
<p><strong>用户无法分辨哪些内容是模型“编的”。</strong></p>
</blockquote>
<p>如果系统本身又没有做校验或限制，
那么：</p>
<blockquote>
<p>错误信息会被当成事实传播。</p>
</blockquote>
<hr>
<h3> 5.4 一个重要的工程判断：哪些幻觉可以容忍？</h3>
<p>在进入解决方案之前，我们先明确一件事：</p>
<blockquote>
<p><strong>不是所有幻觉，都必须被彻底消除。</strong></p>
</blockquote>
<p>在工程上，你通常需要做的是：</p>
<ul>
<li>区分“可容忍的幻觉”</li>
<li>和“必须消除的幻觉”</li>
</ul>
<p>例如：</p>
<ul>
<li>写创意文案时，少量编造是可以接受的</li>
<li>但在查询公司制度时，一句编造就是严重事故</li>
</ul>
<p>这一步判断，决定了你后续系统的复杂度。</p>
<hr>
<h3> 5.5 为什么 Prompt 解决不了幻觉？</h3>
<p>很多初学者会尝试在 Prompt 中加上类似：</p>
<blockquote>
<p>“如果不知道，请直接说不知道”</p>
</blockquote>
<p>有时有效，但你很快会发现：</p>
<ul>
<li>它并不稳定</li>
<li>在复杂场景下几乎必然失效</li>
</ul>
<p>原因在于：</p>
<blockquote>
<p><strong>Prompt 只能影响生成倾向，无法改变模型是否“知道”。</strong></p>
</blockquote>
<p>当模型缺乏事实基础时，
再严格的 Prompt，
也只能降低幻觉概率，而无法消除。</p>
<hr>
<h3> 5.6 解决幻觉的根本思路是什么？</h3>
<p>到这里，其实答案已经呼之欲出了。</p>
<p>如果幻觉的根源在于：</p>
<blockquote>
<p><strong>模型没有真实、可靠的信息来源</strong></p>
</blockquote>
<p>那么解决思路也就很明确：</p>
<blockquote>
<p><strong>不要让模型凭空回答，让它基于你提供的真实资料回答。</strong></p>
</blockquote>
<p>也就是说：</p>
<ul>
<li>把“事实”从模型训练中解耦出来</li>
<li>在推理阶段，把真实资料送给模型</li>
</ul>
<p>这正是下一章要介绍的核心技术：</p>
<blockquote>
<p><strong>RAG（Retrieval-Augmented Generation）。</strong></p>
</blockquote>
<hr>
<h3> 本章小结</h3>
<p>这一章你需要牢牢记住的几点是：</p>
<ol>
<li>幻觉不是 Bug，而是模型特性</li>
<li>幻觉在信息不足时几乎不可避免</li>
<li>Prompt 无法根治幻觉</li>
<li>解决幻觉需要外部真实信息</li>
</ol>
<p>下一章，我们将正式进入 LLM 应用开发中
<strong>最重要、也是最具工程价值的一项能力</strong>：</p>
<blockquote>
<p><strong>让模型基于你的数据回答问题。</strong></p>
</blockquote>
<h2> 第 6 章：RAG —— 让模型基于真实资料回答问题（系统设计视角）</h2>
<p>在上一章，我们已经得出了一个非常明确的结论：</p>
<blockquote>
<p><strong>只要模型缺乏可靠的事实来源，幻觉就一定会出现。</strong></p>
</blockquote>
<p>因此，真正严肃的 LLM 应用，必须回答一个问题：</p>
<blockquote>
<p><strong>系统如何为模型“提供事实”，而不是让它凭空猜？</strong></p>
</blockquote>
<p>RAG（Retrieval-Augmented Generation）并不是一个技巧，而是一种<strong>系统设计模式</strong>。</p>
<p>这一章，我们会站在工程和系统设计的角度，把 RAG 讲清楚。</p>
<hr>
<h3> 6.1 一个几乎所有人都会走过的弯路</h3>
<p>在第一次做“基于文档的问答”时，很多人都会自然想到：</p>
<blockquote>
<p>“那我是不是把文档内容直接塞进 Prompt 就行了？”</p>
</blockquote>
<p>在文档很短、用户很少的情况下，这种做法<strong>确实能跑起来</strong>。</p>
<p>但一旦进入真实系统，你很快就会遇到：</p>
<ul>
<li>文档内容远超上下文窗口</li>
<li>成本随着文档长度线性上涨</li>
<li>模型抓不住重点，回答质量反而下降</li>
</ul>
<p>这时你会意识到一个事实：</p>
<blockquote>
<p><strong>问题不在模型，而在信息投喂方式。</strong></p>
</blockquote>
<hr>
<h3> 6.2 RAG 的本质：把“找资料”和“生成回答”拆开</h3>
<p>RAG 的核心思想可以用一句话概括：</p>
<blockquote>
<p><strong>让系统负责“找事实”，让模型负责“说人话”。</strong></p>
</blockquote>
<p>这一步拆分，在系统设计上非常重要。</p>
<ul>
<li>
<p>检索阶段（Retrieval）：</p>
<ul>
<li>关注的是：
<ul>
<li>找得准不准</li>
<li>覆盖全不全</li>
</ul>
</li>
</ul>
</li>
<li>
<p>生成阶段（Generation）：</p>
<ul>
<li>关注的是：
<ul>
<li>表达是否清晰</li>
<li>是否遵循约束</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>通过这种拆分：</p>
<blockquote>
<p><strong>模型不再被当成“知识库”，而只是一个表达引擎。</strong></p>
</blockquote>
<hr>
<h3> 6.3 为什么要用向量检索？（系统角度的解释）</h3>
<p>在系统设计中，“检索”并不是新问题。</p>
<p>你可能会问：</p>
<blockquote>
<p>“我能不能直接用关键词搜索？”</p>
</blockquote>
<p>在很多场景下，答案是：<strong>不够好</strong>。</p>
<p>原因在于：</p>
<ul>
<li>用户的提问方式是多样的</li>
<li>文档里的表述方式也是多样的</li>
<li>关键词很难穷举所有同义表达</li>
</ul>
<p>向量检索的价值在于：</p>
<blockquote>
<p><strong>它检索的是“语义相似度”，而不是字面匹配。</strong></p>
</blockquote>
<p>从系统角度看，这意味着：</p>
<ul>
<li>检索层对用户输入更宽容</li>
<li>上层生成质量更稳定</li>
</ul>
<hr>
<h3> 6.4 RAG 的标准系统架构</h3>
<p>从工程角度看，一个典型的 RAG 系统，可以拆成下面几个明确的组件。</p>
<hr>
<h4> 组件一：文档接入与预处理</h4>
<p>这一层的目标只有一个：</p>
<blockquote>
<p><strong>把原始资料，变成“适合被检索”的形态。</strong></p>
</blockquote>
<p>常见职责包括：</p>
<ul>
<li>文档解析（PDF / Word / HTML 等）</li>
<li>文档清洗（去噪、去无关内容）</li>
<li>文档切分（Chunking）</li>
</ul>
<p>切分的设计原则是：</p>
<ul>
<li>单个 Chunk 语义相对完整</li>
<li>不要过长，也不要过短</li>
</ul>
<p>这是一个<strong>典型的工程取舍点</strong>。</p>
<hr>
<h4> 组件二：向量化与存储</h4>
<p>这一层的职责是：</p>
<ul>
<li>把每个 Chunk 转换成向量</li>
<li>存入向量数据库</li>
</ul>
<p>从系统设计角度看：</p>
<ul>
<li>这是一个<strong>离线为主</strong>的过程</li>
<li>更新频率取决于文档变化频率</li>
</ul>
<p>一个重要认知是：</p>
<blockquote>
<p><strong>Embedding 模型的选择，直接影响检索质量上限。</strong></p>
</blockquote>
<hr>
<h4> 组件三：查询理解与检索</h4>
<p>当用户发起请求时，系统并不会立刻调用 LLM。</p>
<p>而是先：</p>
<ul>
<li>对用户问题进行向量化</li>
<li>在向量库中检索 Top-K 相关 Chunk</li>
</ul>
<p>这里的关键设计点包括：</p>
<ul>
<li>K 取多少</li>
<li>是否做重排序（Re-ranking）</li>
<li>是否引入元数据过滤</li>
</ul>
<p>这些设计，决定了：</p>
<blockquote>
<p><strong>模型“能看到哪些事实”。</strong></p>
</blockquote>
<hr>
<h4> 组件四：上下文构建与生成</h4>
<p>只有在完成检索之后，系统才会：</p>
<ul>
<li>把检索到的内容</li>
<li>组织成上下文</li>
<li>交给模型生成最终回答</li>
</ul>
<p>这里的系统职责是：</p>
<ul>
<li>控制上下文长度</li>
<li>明确告诉模型：
<blockquote>
<p>“只能基于这些资料回答”</p>
</blockquote>
</li>
</ul>
<hr>
<h3> 6.5 RAG 系统中常见的设计误区</h3>
<p>在实际项目中，RAG 常见的失败，并不是算法问题，而是设计问题。</p>
<hr>
<h4> 误区一：把 RAG 当成一次性功能</h4>
<p>RAG 不是“接一次就完了”的功能。</p>
<p>随着：</p>
<ul>
<li>文档规模增长</li>
<li>用户问题变化</li>
</ul>
<p>你必须不断调整：</p>
<ul>
<li>切分策略</li>
<li>检索策略</li>
<li>上下文构建方式</li>
</ul>
<hr>
<h4> 误区二：过度依赖模型能力</h4>
<p>即使在 RAG 系统中：</p>
<blockquote>
<p><strong>模型仍然不会帮你纠错。</strong></p>
</blockquote>
<p>如果检索阶段拿错了资料，
模型只会：</p>
<blockquote>
<p>一本正经地基于错误资料回答。</p>
</blockquote>
<hr>
<h4> 误区三：忽视失败场景设计</h4>
<p>一个健壮的 RAG 系统，必须考虑：</p>
<ul>
<li>检索不到相关资料怎么办</li>
<li>检索结果冲突怎么办</li>
<li>是否要让模型明确说明“不知道”</li>
</ul>
<p>这些都属于系统层面的责任。</p>
<hr>
<h3> 6.6 一个重要的认知升级</h3>
<p>到这里，你应该已经意识到一件事：</p>
<blockquote>
<p><strong>RAG 的难点，不在模型，而在系统设计。</strong></p>
</blockquote>
<p>模型只是整个链路中的一环。</p>
<p>真正决定系统质量的，是：</p>
<ul>
<li>数据准备是否合理</li>
<li>检索是否稳定</li>
<li>上下文是否清晰</li>
</ul>
<hr>
<h3> 本章小结</h3>
<p>这一章你需要牢牢记住的，是下面几个系统级认知：</p>
<ol>
<li>RAG 是一种系统设计模式，而不是模型技巧</li>
<li>核心思想是“检索”和“生成”的职责分离</li>
<li>系统设计决定 RAG 的效果上限</li>
<li>模型只负责表达，不负责保证事实正确</li>
</ol>
<p>理解了这些内容之后，你就具备了：</p>
<blockquote>
<p><strong>设计“可信 LLM 应用”的核心能力之一。</strong></p>
</blockquote>
<p>下一章，我们将继续解决一个现实问题：</p>
<blockquote>
<p><strong>即使模型知道该做什么，它也“什么都做不了”。</strong></p>
</blockquote>
<p>这将引出另一个关键能力：</p>
<blockquote>
<p><strong>Function Calling —— 让模型参与真实系统的执行流程。</strong></p>
</blockquote>
<hr>
<h2> 第 7 章：Function Calling —— 让模型真正参与系统执行</h2>
<p>在上一章，我们已经解决了一个非常关键的问题：</p>
<blockquote>
<p><strong>如何让模型“基于真实资料说话”。</strong></p>
</blockquote>
<p>但当你真的把 RAG 系统接入业务后，很快又会遇到一个新的现实困境。</p>
<p>模型现在：</p>
<ul>
<li>能理解问题了</li>
<li>也能给出看起来很合理的回答</li>
</ul>
<p>但问题是：</p>
<blockquote>
<p><strong>它只能“说”，不能“做”。</strong></p>
</blockquote>
<p>这一章，我们要解决的，正是这个问题。</p>
<hr>
<h3> 7.1 一个非常常见、但很快会失败的做法</h3>
<p>很多人在第一次尝试“让模型帮我干活”时，会这样设计系统：</p>
<blockquote>
<p>“我让模型输出一段 JSON，
然后我在代码里解析这个 JSON，
再根据内容去调用对应逻辑。”</p>
</blockquote>
<p>在 Demo 阶段，这种方式通常可以跑起来。</p>
<p>但一旦进入真实系统，你会发现问题接踵而至：</p>
<ul>
<li>JSON 格式不稳定</li>
<li>字段名偶尔变化</li>
<li>缺字段、多字段</li>
<li>模型输出夹杂自然语言</li>
</ul>
<p>这时你会意识到：</p>
<blockquote>
<p><strong>模型并不知道哪些输出是“必须严格遵守的”。</strong></p>
</blockquote>
<hr>
<h3> 7.2 Function Calling 要解决的核心问题</h3>
<p>Function Calling 并不是为了“让模型会写代码”。</p>
<p>它真正解决的是一个系统层面的问题：</p>
<blockquote>
<p><strong>如何让模型在“自然语言理解”和“系统能力调用”之间，
建立一个稳定、可控的接口。</strong></p>
</blockquote>
<p>换句话说：</p>
<ul>
<li>
<p>模型负责：</p>
<ul>
<li>理解用户意图</li>
<li>决定“要做什么”</li>
</ul>
</li>
<li>
<p>系统负责：</p>
<ul>
<li>提供“能做什么”</li>
<li>执行具体逻辑</li>
</ul>
</li>
</ul>
<p>这是一次非常重要的职责划分。</p>
<hr>
<h3> 7.3 从系统角度看 Function Calling 的工作方式</h3>
<p>站在系统设计视角，Function Calling 可以被理解为：</p>
<blockquote>
<p><strong>模型参与决策，但不直接参与执行。</strong></p>
</blockquote>
<p>一个典型流程如下：</p>
<ol>
<li>
<p>系统向模型声明：</p>
<ul>
<li>当前有哪些函数（工具）可用</li>
<li>每个函数的用途和参数结构</li>
</ul>
</li>
<li>
<p>模型根据用户输入：</p>
<ul>
<li>判断是否需要调用函数</li>
<li>以及应该调用哪一个</li>
</ul>
</li>
<li>
<p>系统接管执行：</p>
<ul>
<li>校验参数</li>
<li>调用真实业务逻辑</li>
</ul>
</li>
<li>
<p>执行结果再回传给模型，用于后续回答</p>
</li>
</ol>
<p>在这个过程中：</p>
<blockquote>
<p><strong>模型从“输出文本”，升级为“输出结构化决策”。</strong></p>
</blockquote>
<hr>
<h3> 7.4 为什么说 Function Calling 是“工程能力”，不是模型能力</h3>
<p>一个非常容易被忽略的点是：</p>
<blockquote>
<p><strong>Function Calling 的可靠性，主要由系统保证，而不是模型保证。</strong></p>
</blockquote>
<p>即使模型判断错了：</p>
<ul>
<li>参数缺失</li>
<li>类型不对</li>
<li>调用了不该调用的函数</li>
</ul>
<p>系统仍然可以：</p>
<ul>
<li>拒绝执行</li>
<li>返回错误信息</li>
<li>要求模型重新决策</li>
</ul>
<p>这意味着：</p>
<blockquote>
<p><strong>风险被牢牢控制在系统边界内。</strong></p>
</blockquote>
<hr>
<h3> 7.5 Function Calling 在系统中的典型使用场景</h3>
<p>当你理解了它的系统定位，就会发现 Function Calling 非常适合下面这些场景。</p>
<hr>
<h4> 场景一：查询类操作</h4>
<p>例如：</p>
<ul>
<li>查询订单状态</li>
<li>查询库存信息</li>
<li>查询用户配置</li>
</ul>
<p>模型负责理解“查什么”，
系统负责返回真实数据。</p>
<hr>
<h4> 场景二：状态变更类操作</h4>
<p>例如：</p>
<ul>
<li>创建订单</li>
<li>修改配置</li>
<li>提交审批</li>
</ul>
<p>这里尤其重要的一点是：</p>
<blockquote>
<p><strong>模型永远不应该直接修改数据。</strong></p>
</blockquote>
<p>它只能“请求”，
是否执行，完全由系统决定。</p>
<hr>
<h4> 场景三：多步流程中的一步</h4>
<p>在更复杂的系统中：</p>
<ul>
<li>模型并不一次完成所有事情</li>
<li>而是参与多个步骤的决策</li>
</ul>
<p>这为后面引入 Agent 打下基础。</p>
<hr>
<h3> 7.6 Function Calling 的设计边界</h3>
<p>理解边界，比理解能力更重要。</p>
<p>在系统设计中，你需要明确：</p>
<ul>
<li>哪些能力可以暴露给模型</li>
<li>哪些能力必须完全禁止</li>
</ul>
<p>一个基本原则是：</p>
<blockquote>
<p><strong>模型只能调用“可逆、可校验、可回滚”的操作。</strong></p>
</blockquote>
<p>任何：</p>
<ul>
<li>高风险</li>
<li>不可恢复</li>
<li>责任重大的操作</li>
</ul>
<p>都不应该直接暴露给模型。</p>
<hr>
<h3> 7.7 一个重要的系统认知升级</h3>
<p>到这里，你应该已经意识到：</p>
<blockquote>
<p><strong>Function Calling 不是让模型更聪明，
而是让系统更安全。</strong></p>
</blockquote>
<p>它的价值不在于：</p>
<ul>
<li>模型能做更多事</li>
</ul>
<p>而在于：</p>
<ul>
<li>模型被限制在正确的位置上</li>
<li>系统始终掌握最终控制权</li>
</ul>
<hr>
<h3> 本章小结</h3>
<p>在这一章中，你需要记住下面几个关键点：</p>
<ol>
<li>模型只能理解意图，不能直接执行</li>
<li>Function Calling 是模型与系统之间的“安全接口”</li>
<li>决策与执行必须严格分离</li>
<li>风险控制是系统设计的首要目标</li>
</ol>
<p>理解了这些内容之后，你已经具备了：</p>
<blockquote>
<p><strong>设计“可控 LLM 系统”的关键能力。</strong></p>
</blockquote>
<p>下一章，我们将把前面所有能力组合起来，回答一个常被过度神话的问题：</p>
<blockquote>
<p><strong>什么时候，我们才真的需要 Agent？</strong></p>
</blockquote>
<hr>
<h2> 第 8 章：Agent 的工程化理解 —— 去神话版</h2>
<p>在前面的章节中，我们已经一步步为模型补齐了能力：</p>
<ul>
<li>第 5 章：认识到模型会幻觉，不能被直接信任</li>
<li>第 6 章：通过 RAG，让模型基于真实资料回答</li>
<li>第 7 章：通过 Function Calling，让模型参与系统决策</li>
</ul>
<p>到这里，很多人会自然地产生一个想法：</p>
<blockquote>
<p>“那是不是把这些东西一组合，我就有了一个 Agent？”</p>
</blockquote>
<p>答案是：</p>
<blockquote>
<p><strong>是的，但也正因为如此，Agent 并不神秘。</strong></p>
</blockquote>
<p>这一章，我们就从工程角度，把 Agent 这件事彻底讲清楚。</p>
<hr>
<h3> 8.1 先回答一个尖锐的问题：你真的需要 Agent 吗？</h3>
<p>在技术社区中，Agent 往往被描述成：</p>
<ul>
<li>能自主思考</li>
<li>能自动规划</li>
<li>能持续执行任务</li>
</ul>
<p>听起来非常强大。</p>
<p>但在真实工程中，你需要先冷静下来问一句：</p>
<blockquote>
<p><strong>我的系统，真的需要这种复杂度吗？</strong></p>
</blockquote>
<p>因为 Agent 带来的，不只是能力提升，还有：</p>
<ul>
<li>系统复杂度指数级上升</li>
<li>调试和测试难度显著增加</li>
<li>不确定性扩大</li>
</ul>
<p>一个非常务实的判断标准是：</p>
<blockquote>
<p><strong>如果一个请求，在一次 RAG + Function Calling 中就能解决，
那你根本不需要 Agent。</strong></p>
</blockquote>
<hr>
<h3> 8.2 Agent 并不是一个新能力</h3>
<p>一个常见误解是：</p>
<blockquote>
<p>“Agent 是模型的新能力。”</p>
</blockquote>
<p>但从工程角度看，这并不准确。</p>
<p>事实上，一个 Agent 通常只是下面这些能力的组合：</p>
<ul>
<li>Prompt（任务描述）</li>
<li>上下文管理（状态）</li>
<li>RAG（事实获取）</li>
<li>Function Calling（工具调用）</li>
<li>一个控制循环（Loop）</li>
</ul>
<p>也就是说：</p>
<blockquote>
<p><strong>Agent 的核心，不在模型，而在“控制逻辑”。</strong></p>
</blockquote>
<hr>
<h3> 8.3 控制循环：Agent 真正的核心</h3>
<p>如果一定要用一句话来定义 Agent：</p>
<blockquote>
<p><strong>Agent = 一个带状态的、可重复执行的决策循环。</strong></p>
</blockquote>
<p>一个最简化的 Agent 循环，可以抽象为：</p>
<ol>
<li>读取当前状态</li>
<li>决定下一步要做什么</li>
<li>调用工具或获取信息</li>
<li>更新状态</li>
<li>判断是否结束，否则继续</li>
</ol>
<p>注意这里的关键点：</p>
<blockquote>
<p><strong>循环是由系统控制的，而不是模型。</strong></p>
</blockquote>
<p>模型只是参与每一轮的“决策建议”。</p>
<hr>
<h3> 8.4 为什么 Agent 必须由系统“牵着走”</h3>
<p>很多失败的 Agent 实验，问题都出在这里：</p>
<ul>
<li>把过多控制权交给模型</li>
<li>让模型自己决定是否继续</li>
</ul>
<p>这在工程上是非常危险的。</p>
<p>一个健壮的 Agent 系统，通常会明确限制：</p>
<ul>
<li>最大执行步数</li>
<li>每一步允许调用的工具</li>
<li>明确的终止条件</li>
</ul>
<p>这些限制的目的只有一个：</p>
<blockquote>
<p><strong>把不确定性关进笼子里。</strong></p>
</blockquote>
<hr>
<h3> 8.5 Agent 适合解决什么问题？</h3>
<p>在真实系统中，Agent 并不是“通用解法”。</p>
<p>它更适合下面这些场景：</p>
<ul>
<li>需要多步推理和多次信息获取</li>
<li>步骤之间存在依赖关系</li>
<li>中间结果会影响后续决策</li>
</ul>
<p>例如：</p>
<ul>
<li>复杂任务拆解与执行</li>
<li>多工具协作的问题解决</li>
<li>长时间运行的辅助流程</li>
</ul>
<p>而不适合：</p>
<ul>
<li>简单问答</li>
<li>单步决策</li>
<li>强一致性、高风险操作</li>
</ul>
<hr>
<h3> 8.6 一个现实的工程建议</h3>
<p>如果你是第一次在项目中引入 Agent，我给你一个非常保守但实用的建议：</p>
<blockquote>
<p><strong>先把 Agent 当成“可多次调用的流程编排器”，
而不是“自主智能体”。</strong></p>
</blockquote>
<p>从工程视角看，这会让你：</p>
<ul>
<li>更容易调试</li>
<li>更容易监控</li>
<li>更容易回滚</li>
</ul>
<hr>
<h3> 本章小结</h3>
<p>在这一章中，你需要牢牢记住下面几点：</p>
<ol>
<li>Agent 并不神秘，它是能力的组合</li>
<li>控制循环才是 Agent 的核心</li>
<li>系统必须始终掌握控制权</li>
<li>大多数场景下，你并不需要 Agent</li>
</ol>
<p>如果你能带着这些认知去使用 Agent，那么它会成为：</p>
<blockquote>
<p><strong>一个强大但可控的工程工具。</strong></p>
</blockquote>
<p>而不是一个不可预测的风险源。</p>
<hr>
<h2> 全文总结：从“用模型”到“设计系统”</h2>
<h3> 写给工程师的 LLM 使用宣言</h3>
<p>如果你完整读完了这套教程，我希望你至少记住一件事：</p>
<blockquote>
<p><strong>大语言模型不是一个可以被“信任”的系统组件。</strong></p>
</blockquote>
<p>它不保证正确性，
不理解后果，
也不会为错误负责。</p>
<p>真正可靠的，从来不是模型本身，而是你设计的系统。</p>
<hr>
<h3> 不要问“模型还能多聪明”</h3>
<p>在工程实践中，一个更有价值的问题是：</p>
<blockquote>
<p><strong>哪些不确定性，必须被系统兜住？</strong></p>
</blockquote>
<ul>
<li>用 Prompt 约束表达</li>
<li>用 RAG 约束事实</li>
<li>用 Function Calling 约束执行</li>
<li>用 Agent 的控制循环约束流程</li>
</ul>
<p>这不是限制模型，而是保护系统。</p>
<hr>
<h3> 大多数失败，都不是模型失败</h3>
<p>如果一个 LLM 应用：</p>
<ul>
<li>经常胡说八道</li>
<li>行为不可预测</li>
<li>出问题后无法追踪</li>
</ul>
<p>那么问题通常不在模型，而在于：</p>
<blockquote>
<p><strong>系统把不该交给模型的责任，交给了模型。</strong></p>
</blockquote>
<hr>
<h3> 成熟的 LLM 工程，是“去魔法化”的过程</h3>
<p>当你不再期待模型“自动搞定一切”，
而是：</p>
<ul>
<li>明确边界</li>
<li>明确职责</li>
<li>明确失败路径</li>
</ul>
<p>你会发现，LLM 反而变得可靠起来。</p>
<hr>
<h3> 最后一句话</h3>
<p>如果你想长期做 LLM 应用开发，请记住这句话：</p>
<blockquote>
<p><strong>不是让模型变强，而是让系统变稳。</strong></p>
</blockquote>
<p>只要你坚持这个原则，
无论技术如何变化，你都站在正确的一边。</p>
]]></content:encoded>
    </item>
    <item>
      <title>LLM应用开发进阶大纲</title>
      <link>https://ppai.top/ai-guides/tutorial/hello-llm/02.LLM%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B%E5%A4%A7%E7%BA%B2.html</link>
      <guid>https://ppai.top/ai-guides/tutorial/hello-llm/02.LLM%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B%E5%A4%A7%E7%BA%B2.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">LLM应用开发进阶大纲</source>
      <description>终章｜下一步你该学什么？ 什么时候该微调？ 什么时候该换模型？ LLM 应用的长期演进方向 📌 附录 Prompt 模板速查表 RAG 参数调优清单 Agent 架构设计 Checklist 常见坑位与反模式总结</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 09:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<hr>
<h1> 终章｜下一步你该学什么？</h1>
<ul>
<li>什么时候该微调？</li>
<li>什么时候该换模型？</li>
<li>LLM 应用的长期演进方向</li>
</ul>
<hr>
<h2> 📌 附录</h2>
<ul>
<li>Prompt 模板速查表</li>
<li>RAG 参数调优清单</li>
<li>Agent 架构设计 Checklist</li>
<li>常见坑位与反模式总结</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>前言</title>
      <link>https://ppai.top/ai-guides/tutorial/hello-llm/03.%E5%89%8D%E8%A8%80.html</link>
      <guid>https://ppai.top/ai-guides/tutorial/hello-llm/03.%E5%89%8D%E8%A8%80.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">前言</source>
      <description>下面是一份可以直接作为成稿使用的「前言」章节内容，风格与全书保持一致：不炫技、不晦涩，用问题牵引认知转变，并且明确告诉读者这本书“解决什么、不解决什么”。 前言 为什么你“会用 LLM”，但做不出复杂应用？ 如果你已经读到这里，大概率符合下面的画像之一： 你能写出效果不错的 Prompt 你做过一些 Demo，看起来“挺智能” 但一到真实场景，就开始不对劲： 回答时好时坏 对话一长就跑偏 数据一多就失控 Demo 很难上线，更谈不上长期维护</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 09:45:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>下面是一份<strong>可以直接作为成稿使用的「前言」章节内容</strong>，风格与全书保持一致：不炫技、不晦涩，用问题牵引认知转变，并且<strong>明确告诉读者这本书“解决什么、不解决什么”</strong>。</p>
<hr>
<h2> 前言</h2>
<h3> 为什么你“会用 LLM”，但做不出复杂应用？</h3>
<p>如果你已经读到这里，大概率符合下面的画像之一：</p>
<ul>
<li>
<p>你能写出效果不错的 Prompt</p>
</li>
<li>
<p>你做过一些 Demo，看起来“挺智能”</p>
</li>
<li>
<p>但一到真实场景，就开始不对劲：</p>
<ul>
<li>回答时好时坏</li>
<li>对话一长就跑偏</li>
<li>数据一多就失控</li>
<li>Demo 很难上线，更谈不上长期维护</li>
</ul>
</li>
</ul>
<p>你可能已经问过自己一些问题：</p>
<ul>
<li><strong>为什么 Prompt 调得很好，系统却依然不稳定？</strong></li>
<li><strong>为什么 Demo 阶段“看起来能用”，上线后问题不断？</strong></li>
<li><strong>为什么模型很强，但应用却很脆弱？</strong></li>
</ul>
<p>如果你有这些困惑，那问题<strong>并不在于你不会用 LLM</strong>。</p>
<p>真正的问题是：</p>
<blockquote>
<p><strong>你学到的大多数内容，都是“如何驱动模型”，
而不是“如何构建系统”。</strong></p>
</blockquote>
<hr>
<h4> 调得好 Prompt ≠ 系统就稳定</h4>
<p>这是很多开发者都会踩的第一个坑。</p>
<p>Prompt 确实重要，但它只解决一件事：</p>
<blockquote>
<p><strong>在一次生成中，如何约束模型行为。</strong></p>
</blockquote>
<p>而真实的 LLM 应用，必然涉及：</p>
<ul>
<li>多轮对话</li>
<li>状态变化</li>
<li>知识更新</li>
<li>错误处理</li>
<li>成本与安全边界</li>
</ul>
<p>这些问题，<strong>没有一个是靠多写几句 Prompt 能解决的</strong>。</p>
<hr>
<h4> 为什么多数 Demo 无法上线？</h4>
<p>因为 Demo 往往具备三个“天然优势”：</p>
<ul>
<li>用户少</li>
<li>数据小</li>
<li>时间短</li>
</ul>
<p>一旦进入真实环境：</p>
<ul>
<li>上下文开始膨胀</li>
<li>知识开始过期</li>
<li>用户开始“乱问”</li>
<li>错误开始积累</li>
</ul>
<p>你会发现：</p>
<blockquote>
<p><strong>Demo 是“一次生成的问题”，
而上线是“系统随时间演化的问题”。</strong></p>
</blockquote>
<p>这正是两者之间的本质鸿沟。</p>
<hr>
<h4> 这篇系列教程解决什么问题？不解决什么问题？</h4>
<p>这个系列教程<strong>不试图</strong>做以下事情：</p>
<ul>
<li>❌ 教你写“最强 Prompt 模板”</li>
<li>❌ 罗列各种框架 API 用法</li>
<li>❌ 追逐最新模型或参数技巧</li>
</ul>
<p>本书真正要解决的是：</p>
<blockquote>
<p><strong>如何把一个不可靠的大模型，
放进一个可控、可维护、可演进的系统中。</strong></p>
</blockquote>
<p>更具体地说：</p>
<ul>
<li>为什么 Prompt 必须是“约束”，而不是“知识”</li>
<li>为什么上下文会天然失控，以及如何设计记忆</li>
<li>为什么 RAG 不是外挂，而是工程必然</li>
<li>为什么 Agent 不是智能幻想，而是系统循环</li>
<li>为什么评估与监控决定了项目能不能活下来</li>
</ul>
<p>如果你期待的是“技巧合集”，这个系列教程可能不适合你。</p>
<p>如果你想的是<strong>真正把 LLM 应用做成产品</strong>，那你来对了。</p>
<hr>
<h3> 本书的学习路径说明</h3>
<p>这不是一本可以“跳着看也无所谓”的书。</p>
<p>因为它试图做一件事：</p>
<blockquote>
<p><strong>带你完成一次从“模型使用者”到“系统设计者”的转变。</strong></p>
</blockquote>
<hr>
<h4> 你需要什么基础？</h4>
<p>你不需要：</p>
<ul>
<li>深度学习理论</li>
<li>Transformer 数学推导</li>
<li>算法竞赛背景</li>
</ul>
<p>但你需要：</p>
<ul>
<li>基本的编程经验</li>
<li>对 Web / 后端 / 系统设计有基本认知</li>
<li>至少实现过一个简单的 LLM 应用或 Demo</li>
</ul>
<p>如果你已经写过几次 Prompt、接过模型 API、踩过一些坑，那正是<strong>最佳起点</strong>。</p>
<hr>
<h4> 每一模块学完，你“能做什么”？</h4>
<p>本书的每一部分，都对应一种<strong>能力跃迁</strong>：</p>
<ul>
<li>
<p><strong>理解模型本质</strong>
→ 不再迷信“模型会自己想明白”</p>
</li>
<li>
<p><strong>Prompt 与约束</strong>
→ 能设计行为边界，而不是碰运气</p>
</li>
<li>
<p><strong>Context 与 Memory</strong>
→ 能做稳定的多轮系统</p>
</li>
<li>
<p><strong>RAG 与知识注入</strong>
→ 能让系统基于真实事实回答</p>
</li>
<li>
<p><strong>Function Calling 与 Agent</strong>
→ 能让系统完成任务，而不只是聊天</p>
</li>
<li>
<p><strong>评估与工程化</strong>
→ 能让系统长期运行、持续演进</p>
</li>
</ul>
<p>你最终获得的不是某个技巧，而是：</p>
<blockquote>
<p><strong>一套判断“该不该这么设计”的工程直觉。</strong></p>
</blockquote>
<hr>
<h4> 推荐的学习与实践方式</h4>
<p>这本书<strong>强烈不推荐</strong>只读不做。</p>
<p>更好的方式是：</p>
<ol>
<li>
<p><strong>以“企业知识库助手”为主线对照阅读</strong></p>
<ul>
<li>每读一章，想一想：
<em>如果是我的系统，会在哪里出问题？</em></li>
</ul>
</li>
<li>
<p><strong>在你已有的 Demo 上逐步套用</strong></p>
<ul>
<li>不用一次重构</li>
<li>先从约束、再到上下文、再到检索</li>
</ul>
</li>
<li>
<p><strong>接受一个事实</strong></p>
<ul>
<li>LLM 应用不是“搭完就好”</li>
<li>而是一个会随时间退化的系统</li>
</ul>
</li>
</ol>
<p>如果你在阅读过程中不断产生这样的想法：</p>
<blockquote>
<p>“原来我之前的问题不是偶然的。”
“原来这一步是迟早要做的。”</p>
</blockquote>
<p>那么，这本书正在发挥它真正的价值。</p>
<hr>
<blockquote>
<p><strong>这不是一本教你“怎么用模型”的书，
而是一本教你“如何与模型共处”的工程指南。</strong></p>
</blockquote>
<p>欢迎开始。</p>
<hr>
<h3> 全书大纲</h3>
<figure><img src="/imgs/column/llm/03-1.png" alt="思维导图版大纲" tabindex="0" loading="lazy"><figcaption>思维导图版大纲</figcaption></figure>
<p>文字版大纲如下</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/llm/03-1.png" type="image/png"/>
    </item>
    <item>
      <title>第 1 章：LLM 到底在做什么？</title>
      <link>https://ppai.top/ai-guides/tutorial/hello-llm/04.LLM%E5%88%B0%E5%BA%95%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88.html</link>
      <guid>https://ppai.top/ai-guides/tutorial/hello-llm/04.LLM%E5%88%B0%E5%BA%95%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">第 1 章：LLM 到底在做什么？</source>
      <description>在开始写任何复杂的 LLM 应用之前，我们必须先解决一个根本问题： LLM 到底在“干什么”？ 如果你对这个问题的理解是模糊的，那么后面所有工程决策——Prompt 怎么写、参数怎么调、是否要加 RAG、什么时候该用 Agent——都会变成“试出来的经验”，而不是可复用的能力。 本章我们不从“官方定义”开始，而是从你在真实开发中一定遇到过的困惑说起。 1.1 一个反直觉的问题：LLM 真的「理解」语言吗？</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 10:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>在开始写任何复杂的 LLM 应用之前，我们必须先解决一个根本问题：</p>
<blockquote>
<p><strong>LLM 到底在“干什么”？</strong></p>
</blockquote>
<p>如果你对这个问题的理解是模糊的，那么后面所有工程决策——Prompt 怎么写、参数怎么调、是否要加 RAG、什么时候该用 Agent——都会变成“试出来的经验”，而不是可复用的能力。</p>
<p>本章我们不从“官方定义”开始，而是从<strong>你在真实开发中一定遇到过的困惑</strong>说起。</p>
<hr>
<h3> 1.1 一个反直觉的问题：LLM 真的「理解」语言吗？</h3>
<p>先看一个你大概率遇到过的现象：</p>
<ul>
<li>同一个 Prompt</li>
<li>同一个模型</li>
<li>有时回答像专家</li>
<li>有时却一本正经地胡说八道</li>
</ul>
<p>于是你可能会问：</p>
<blockquote>
<p><strong>它到底懂不懂我在说什么？</strong></p>
</blockquote>
<p>直觉上，我们很容易把 LLM 当成一个“理解语言的智能体”。但如果你站在工程视角，这种理解反而会误导你。</p>
<p>一个更接近事实、也更有用的结论是：</p>
<blockquote>
<p><strong>LLM 并不理解语言，它在做的是「基于上下文的概率预测」。</strong></p>
</blockquote>
<p>这句话非常重要，后面几乎所有设计原则都会从这里推导出来。</p>
<p>既然 LLM 的核心行为是 “基于上下文的概率预测”，那从计算逻辑的角度，我们该如何抽象这种行为？如果把它看作一个函数，这个函数的输入和输出又是什么？这正是我们接下来要拆解的核心 —— 用函数视角重新理解 LLM 的工作机制。</p>
<hr>
<h3> 1.2 用函数视角重新理解 LLM</h3>
<p>如果我们暂时抛开“智能”“理解”这些词，只从计算角度看，LLM 的核心行为可以抽象成一个函数：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>也就是说：</p>
<ul>
<li>输入：你给它的所有上下文（system / user / assistant）</li>
<li>输出：<strong>下一个最可能出现的 token</strong></li>
</ul>
<p>不断重复这个过程，就得到了完整的回答。</p>
<p>这里有三个关键点，请你特别留意：</p>
<ol>
<li><strong>LLM 永远只预测下一个 token</strong>，它并不知道“整段话是否正确”；</li>
<li>所谓的“推理过程”，只是多步 token 预测的自然结果；</li>
<li>模型对世界的全部认知，都来自你提供的上下文。</li>
</ol>
<p>但这个 “只预测下一个 token” 的函数，似乎与我们观察到的现象有矛盾：当我们让 LLM 解数学题或写代码时，它明明能展现出 “一步步推导” 的能力。这难道不算是 “推理” 吗？</p>
<hr>
<h3> 1.3 为什么它「看起来」会推理？</h3>
<p>你可能会反驳：</p>
<blockquote>
<p>可是 LLM 明明能一步步推导数学题、写出复杂代码？</p>
</blockquote>
<p>这并不矛盾。</p>
<p>原因在于：</p>
<ul>
<li>在训练阶段，模型看过**大量“推理过程长什么样”**的文本</li>
<li>它学会了：
<ul>
<li>在什么上下文下</li>
<li>下一步“看起来合理”的 token 是什么</li>
</ul>
</li>
</ul>
<p>当你要求它“逐步思考”“一步一步推导”时，</p>
<blockquote>
<p>它并不是在“思考”，而是在<strong>模仿一种常见的文本模式</strong>。</p>
</blockquote>
<p>这也是为什么 <strong>Chain-of-Thought 是一种提示策略，而不是模型能力本身</strong>。</p>
<hr>
<h3> 1.4 采样机制：随机性从哪里来？</h3>
<p>既然 LLM 是在“预测下一个 token”，那为什么同一个 Prompt 会有不同结果？</p>
<p>这种随机性并非偶然，而是模型生成过程中一个关键机制的直接体现，答案在于：采样机制</p>
<blockquote>
<p><strong>模型输出的不是一个确定值，而是一个概率分布。</strong></p>
</blockquote>
<p>简化后的过程如下：</p>
<figure><img src="/imgs/column/llm/04-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>temperature 越低：越偏向“最可能”的结果</li>
<li>temperature 越高：越容易探索“次优但合理”的结果</li>
</ul>
<p><strong>随机性不是噪声，而是模型能力的一部分。</strong></p>
<p>工程问题在于：</p>
<blockquote>
<p>你是否在合适的场景下，使用了合适的随机性？</p>
</blockquote>
<hr>
<h3> 1.5 第一性原理小结（非常重要）</h3>
<p>从 “不理解语言，只做概率预测”，到 “函数视角下的 token 生成”，再到 “推理是模仿文本模式” 和 “随机性来自采样机制”，我们已经拆解了 LLM 的核心行为逻辑。现在，我们可以基于这些观察，提炼出一组工程视角下的第一性原理 —— 这将成为后续所有系统设计的底层逻辑。</p>
<p>这一组<strong>工程级结论</strong>即：</p>
<ul>
<li>LLM 不是知识库</li>
<li>LLM 不是规则引擎</li>
<li>LLM 也不是“思考主体”</li>
</ul>
<p>而是：</p>
<blockquote>
<p><strong>一个基于上下文进行概率生成的语言函数</strong></p>
</blockquote>
<p>这意味着：</p>
<ul>
<li>它的所有能力，都依赖于输入</li>
<li>它的所有不可靠性，也来自输入</li>
</ul>
<p><strong>你能控制的，不是模型本身，而是系统如何使用它。</strong></p>
<p>既然 “系统如何使用 LLM” 是可控的核心，那么在系统设计中，除了输入的上下文（比如 Prompt），还有哪些因素会直接影响 LLM 的行为？</p>
<p>如果你曾困惑于 “为什么同样的模型和 Prompt，效果时好时坏”，答案很可能藏在那些被你当作 “微调参数” 的配置里 —— 它们其实是控制 LLM 行为的核心面板。接下来的第二章，我们就来拆解这些参数的真正作用。</p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/llm/04-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>第 2 章：模型不是重点，参数才是你真正的控制面板</title>
      <link>https://ppai.top/ai-guides/tutorial/hello-llm/05.LLM%E5%8F%82%E6%95%B0%E5%86%B3%E7%AD%96.html</link>
      <guid>https://ppai.top/ai-guides/tutorial/hello-llm/05.LLM%E5%8F%82%E6%95%B0%E5%86%B3%E7%AD%96.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">第 2 章：模型不是重点，参数才是你真正的控制面板</source>
      <description>在了解 LLM 的基本工作方式之后，我们来看一个实际体验中很常见的问题： 为什么同一个模型、同样的 Prompt， 有时表现很好，有时却很糟糕？ 2.1 一个常见困惑：为什么效果忽好忽坏？ 在实际使用中，我们可能都遇到过，选择了更牛的模型、也按照要求反复调整了提示词，在demo中表现挺好，可是只要一上线，各种问题就来了，如 输出不稳定 有时啰嗦，有时过于简短 出现不符合现状或者自相矛盾的结果</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 11:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>在了解 LLM 的基本工作方式之后，我们来看一个<strong>实际体验中很常见的问题</strong>：</p>
<blockquote>
<p><strong>为什么同一个模型、同样的 Prompt， 有时表现很好，有时却很糟糕？</strong></p>
</blockquote>
<hr>
<h3> 2.1 一个常见困惑：为什么效果忽好忽坏？</h3>
<p>在实际使用中，我们可能都遇到过，选择了更牛的模型、也按照要求反复调整了提示词，在demo中表现挺好，可是只要一上线，各种问题就来了，如</p>
<ul>
<li>输出不稳定</li>
<li>有时啰嗦，有时过于简短</li>
<li>出现不符合现状或者自相矛盾的结果</li>
</ul>
<p>然后我们能干啥呢？ 换个模型？ 调整下提示词？ 或者随机改一下传参？ 即便是某一次碰巧搞定了，也不知道为啥。 将确定的编程过程整成了玄学，一个雷放在那儿、随时可能爆炸，这可以说是一个码农的噩梦了。</p>
<p>但问题到底出在什么地方呢？LLM开发让人头疼的一点也在于此，不像我们的业务代码，还可以通过debug，单步到核心逻辑去研究一下；大模型对于开发者而言，更多的是一个黑盒，想调试也束手无策</p>
<p>一般这种场景下，问题有可能并不在模型本身，而在于：</p>
<blockquote>
<p><strong>你是否意识到：参数本身就是“行为策略”？</strong></p>
</blockquote>
<p>当我们说 “参数是行为策略”，并不是指那些随意调整的 “玄学数值”。 比如 <code>temperature</code> 和 <code>top_p</code> 这两个最常用的参数，很多地方将他们描述为 “控制创造性的调味料”，这种描述挺贴切的，但是在具体的编码活动中，我们可能更希望有一个确切的数值标准，如果有不同的应用场景的最佳参数设置实践，那就更完美了。</p>
<p>接下来，我们仔细盘一下这两个参数 —— 它们到底在控制 LLM 的什么行为？</p>
<hr>
<h3> 2.2 temperature / top_p 不是“调味料”</h3>
<p>网上很多教程中，将<code>temperature</code> 解释为 <strong>“控制创造性，越大越发散”</strong> 的核心控制参数</p>
<p>这句话<strong>挺贴切的，从工程化的角度改怎么理解呢？</strong>。</p>
<p>使用更专业或者不那么容易懂语言进行解释</p>
<blockquote>
<p><strong>temperature 决定：模型是否允许偏离当前最优预测路径。</strong></p>
</blockquote>
<ul>
<li>temperature 越低
→ 越倾向选择概率最高的 token</li>
<li>temperature 越高
→ 越允许探索次优甚至低概率路径的 token</li>
</ul>
<p>从上面的描述，也可以得出一个直观的感受，temperature的取值，可影响</p>
<ul>
<li>输出是否可复现</li>
<li>行为是否稳定</li>
<li>是否适合被系统消费（而不仅是人阅读）</li>
</ul>
<hr>
<h4> 那 top_p 又是什么？</h4>
<p>如果说 temperature 是“整体发散程度”，那 <code>top_p</code> 更像是：</p>
<blockquote>
<p><strong>你允许模型在“多大的候选范围”里做选择。</strong></p>
</blockquote>
<ul>
<li><code>top_p = 0.9</code>
→ 只从累计概率前 90% 的 token 中选</li>
<li><code>top_p = 1.0</code>
→ 几乎不做限制</li>
</ul>
<p>请注意，所有的参数都不是独立生效的，他们必然是相互影响的（感觉像是废话，参数都是一起传给大模型的，肯定是一起工作的啊🤣）</p>
<p>在实际的开发过程中，不妨借鉴一下 “控制变量法” 的思路来进行调参：</p>
<ul>
<li><strong>固定其中一个</strong></li>
<li><strong>调另一个作为主策略</strong></li>
</ul>
<p>显然这又是一个痛苦和煎熬的反复拉扯过程~</p>
<hr>
<h3> 2.3 model：不是“越强越好”，而是“是否匹配任务”</h3>
<p>有一个反直觉的事实表现：</p>
<blockquote>
<p><strong>模型越大、越新，系统并不一定表现就越好。</strong></p>
</blockquote>
<p>在真实的应用抉择上，模型选择其实是一个多方面的<strong>工程权衡问题</strong>：</p>
<ul>
<li>能力上限</li>
<li>成本</li>
<li>延迟</li>
<li>行为一致性</li>
</ul>
<p>比如几个经典的应用场景下对模型的要求：</p>
<ul>
<li>
<p><strong>规则解释 / 企业知识问答</strong></p>
<ul>
<li>更需要稳定、克制</li>
<li>不一定需要最“聪明”的模型</li>
</ul>
</li>
<li>
<p><strong>创意生成 / 头脑风暴</strong></p>
<ul>
<li>可以接受不确定性</li>
<li>模型探索能力更重要</li>
</ul>
</li>
</ul>
<p>因此，一个更健康的视角是：</p>
<blockquote>
<p><strong>model 是能力边界，参数决定你是否触碰这个边界。</strong></p>
</blockquote>
<hr>
<h3> 2.4 max_tokens：你允许系统“说到什么程度”</h3>
<p><code>max_tokens</code> 经常被当作一个简单的“长度限制”。</p>
<p>但在系统层面，它真正控制的是：</p>
<blockquote>
<p><strong>模型是否被允许“继续展开思路”。</strong></p>
</blockquote>
<p>这在以下场景尤为关键：</p>
<ul>
<li>多步推理</li>
<li>解释性回答</li>
<li>Agent 场景中的中间推理</li>
</ul>
<p>如果 <code>max_tokens</code> 过低，导致 <code>推理会被强行截断</code> + <code>输出容易“看似合理但不完整”</code></p>
<p>如果过高，也会导致 <code>成本上升</code> + <code>模型更容易开始“自由发挥”</code></p>
<p>所以它本质上是：</p>
<blockquote>
<p><strong>对“思考深度”的一种工程约束。</strong></p>
</blockquote>
<p>看到这里不知道你脑海里是否和我有相同的感觉，这种大模型调用的传参，感觉变成了一个<code>经验学科</code>了，只有实际体验得多了，才知道什么场景、选择什么样的传参🤣</p>
<hr>
<h3> 2.5 stream：不是体验优化，而是系统架构选择</h3>
<p><code>stream</code> 可以简单的理解为 <code>能不能一边生成一边显示结果</code></p>
<p>在复杂系统中，它还包含着一些潜在的含义：</p>
<ul>
<li>是否允许<strong>增量消费输出</strong></li>
<li>是否能在生成过程中：
<ul>
<li>中断</li>
<li>校验</li>
<li>触发后续逻辑</li>
</ul>
</li>
</ul>
<p>在 Agent / Tool / 长文本场景中：</p>
<ul>
<li>非流式 → 一次性黑箱结果</li>
<li>流式 → 可观测、可干预</li>
</ul>
<p>从上面的描述也可以看出，流式调用除了体验的优化之外，还有一些系统约束层面的能力</p>
<blockquote>
<p><strong>LLM可以是“一次性函数调用”之外，作为系统的一部分存在</strong></p>
</blockquote>
<h3> 2.6 用「任务类型」来决定参数，而不是凭感觉</h3>
<p>上面说了这些参数，那么在我的应用场景中，具体应该怎么设置呢， 全部用默认参数吗？</p>
<p>显然一个更合理的做法是：</p>
<blockquote>
<p><strong>先判断你在做什么任务，再决定参数策略。</strong></p>
</blockquote>
<p>比如根据实际场景，我是否需要一个发散性的回复，例如</p>
<ul>
<li>代码生成：
<ul>
<li>temperature 低</li>
<li>输出结构稳定</li>
</ul>
</li>
<li>创意写作：
<ul>
<li>temperature 高</li>
<li>接受一定不确定性</li>
</ul>
</li>
</ul>
<figure><img src="/imgs/column/llm/05-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>一组参数配合调参，应对不同的应用场景：</p>
<figure><img src="/imgs/column/llm/05-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h3> 2.7 把参数当成策略的一部分（伪代码示例）</h3>
<p>明确了 “任务类型决定参数策略” 的逻辑后，接下来我们再来看一下，代码实现上，可以怎么进行表现（好像也是简单的if/else 😊）</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 2.8 本章小结</h3>
<p>这一篇的内容主要介绍了大模型访问的几个关键传参，并且声明了大模型表现与参数配置之间的关系</p>
<ul>
<li>模型决定能力上限</li>
<li>参数决定行为方式</li>
<li>行为决定系统是否可靠</li>
</ul>
<p>在后面的章节中我们也会逐渐发现</p>
<ul>
<li>Prompt 是<strong>约束</strong></li>
<li>参数是<strong>策略</strong></li>
<li>RAG / Tool / Memory 是<strong>补偿机制</strong></li>
</ul>
<p>所有的这一切，都是围绕着 <strong>如何让一个不可靠的模型，在系统中变得可控。</strong> 努力</p>
<p>既然参数这一块已经说明，接下来自然就是重头戏，如何与LLM进行对话交流，所以下一部分，我们将正式进入 <code>Prompt</code> 工程，但不从“怎么写”开始，而是先回答：</p>
<p><strong>Prompt 为什么会失败？</strong></p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/llm/05-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>第二部分｜Prompt 工程：从“写提示词”到“设计约束系统”（以企业知识库助手为主线）</title>
      <link>https://ppai.top/ai-guides/tutorial/hello-llm/06.%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%20Prompt%E5%B7%A5%E7%A8%8B.html</link>
      <guid>https://ppai.top/ai-guides/tutorial/hello-llm/06.%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%20Prompt%E5%B7%A5%E7%A8%8B.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">第二部分｜Prompt 工程：从“写提示词”到“设计约束系统”（以企业知识库助手为主线）</source>
      <description>本部分目标： 让读者真正理解 Prompt 在系统中的地位，而不是学会几条写作技巧 通过「企业知识库助手」这一真实场景，引导读者像工程师一样思考 Prompt 为后续 RAG、Memory、Agent 建立统一的“约束设计”认知框架 在第一部分中，我们已经反复强调过一个结论： LLM 天生不可靠，可靠性来自系统，而不是模型本身。</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 11:55:07 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本部分目标：</p>
<ul>
<li>让读者真正<strong>理解 Prompt 在系统中的地位</strong>，而不是学会几条写作技巧</li>
<li>通过「企业知识库助手」这一真实场景，引导读者<strong>像工程师一样思考 Prompt</strong></li>
<li>为后续 RAG、Memory、Agent 建立统一的“约束设计”认知框架</li>
</ul>
</blockquote>
<p>在第一部分中，我们已经反复强调过一个结论：</p>
<blockquote>
<p><strong>LLM 天生不可靠，可靠性来自系统，而不是模型本身。</strong></p>
</blockquote>
<p>这一部分要回答的问题是：</p>
<blockquote>
<p><strong>在还没有 RAG、没有工具、没有 Agent 之前，
我们能做的第一件工程化的事情是什么？</strong></p>
</blockquote>
<p>答案是：<strong>Prompt 工程。</strong></p>
<p>但请注意：</p>
<blockquote>
<p>本书所说的 Prompt 工程，
并不是“写得更聪明”，
而是“约束得更清楚”。</p>
</blockquote>
<hr>
<h2> 示例应用贯穿说明：企业知识库助手</h2>
<p>在本书后续所有章节中，我们都会围绕同一个示例系统展开：</p>
<blockquote>
<p><strong>企业知识库助手（Enterprise Knowledge Assistant）</strong></p>
</blockquote>
<p>这是一个非常“现实世界”的系统：</p>
<ul>
<li>面向公司内部员工（用户群体明确，需求集中在业务流程、制度规范、产品信息等具体领域）</li>
<li>回答的问题往往<strong>有标准答案</strong>（例如 “报销流程需要哪些审批人”“产品 A 的质保期限是多久”）</li>
<li>回答错误的成本很高（可能导致员工操作违规、业务决策失误，甚至法律风险）</li>
<li>“听起来合理但其实是错的”，比“不知道”更糟糕（例如错误告知 “供应商付款无需 CEO 审批”，可能引发财务漏洞）</li>
</ul>
<p>这使它成为 Prompt 工程的<strong>理想试验场</strong>。—— 因为它对 “准确性” 和 “可控性” 的要求，恰好击中了 LLM 最需要被约束的痛点。</p>
<p>正是这样一个对可靠性要求极高的系统，在实际开发中却常常因为 “简单化的 Prompt 设计” 而翻车。很多团队认为只要给模型贴上 “知识库助手” 的标签，就能得到符合预期的结果，但现实往往事与愿违。为什么看似清晰的 Prompt 会失效？这背后藏着对 LLM 工作逻辑的认知偏差，也暴露了 Prompt 设计中未被重视的核心问题 —— 这正是我们接下来要深入拆解的内容。</p>
]]></content:encoded>
    </item>
    <item>
      <title>第 3 章：Prompt 为什么会失败？</title>
      <link>https://ppai.top/ai-guides/tutorial/hello-llm/07.Prompt%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%A4%B1%E8%B4%A5.html</link>
      <guid>https://ppai.top/ai-guides/tutorial/hello-llm/07.Prompt%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%A4%B1%E8%B4%A5.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">第 3 章：Prompt 为什么会失败？</source>
      <description>在大模型应用开发之初，demo版、或者初版的设计一般大同小异，比如以企业知识库助手为例，第一版实现通常是这样的： “你是一个企业知识库助手，请根据公司文档回答用户的问题。” 从实际的表现来看，demo还行，但是离生产使用，总是差点意思：</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 12:15:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>在大模型应用开发之初，demo版、或者初版的设计一般大同小异，比如以企业知识库助手为例，第一版实现通常是这样的：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从实际的表现来看，demo还行，但是离生产使用，总是差点意思：</p>
<ul>
<li>回答流畅（大模型的输出一般还是很可以的，至少语言组织天赋应该胜过很多像我这样比较潦草的人了🤣）</li>
<li>语气专业（即使回答内容有误，也是一股正经、理直气壮，这就是让开发者感到为难的地方了~）</li>
<li>但事实经常对不上（例如把 “3 个工作日审批” 说成 “5 个工作日”，把 “部门经理审批” 漏掉）</li>
</ul>
<p>那么问题来了：</p>
<blockquote>
<p><strong>Prompt 已经写了，为什么系统还是不可靠？</strong></p>
</blockquote>
<hr>
<h3> 3.1 一个必须先纠正的认知误区</h3>
<p>很多小伙伴可能会有下面这个潜意识</p>
<blockquote>
<p>“Prompt 是给模型下指令的。”</p>
</blockquote>
<p>但如果你还记得第一部分的结论，就会意识到：</p>
<blockquote>
<p><strong>LLM 并不会‘执行指令’，它只是在延续文本。</strong></p>
</blockquote>
<p>这是啥意思呢，又表明什么呢？</p>
<ul>
<li><code>Prompt</code> 不是命令（模型没有 “理解指令并执行” 的能力，它只是根据上下文概率生成下一个词）</li>
<li><code>Prompt</code> 是上下文的一部分（模型会把 Prompt 当作 “对话历史” 的开头，然后 “接话”）</li>
<li><code>Prompt</code> 的作用，是改变生成空间的形状（通过调整上下文，让模型更可能生成符合预期的内容）</li>
</ul>
<p>如果你在上下文中留下了模糊空间，大模型“自由合理地填满这些空白”，就是必然会出现的结果了</p>
<p>举个例子来解释下上面的说法</p>
<p>当用户问 “公司的病假工资怎么算？”，如果 Prompt 只说 “根据公司文档回答”，模型会怎么做？</p>
<p>它会先从训练数据中回忆 “一般公司的病假工资规则”（比如 “按基本工资的 80% 发放”），再尝试把这个 “常识” 套进 “公司文档” 的语境里</p>
<p>即使文档中明确写的是 “按全额工资发放”，模型也可能因为 “常识更熟悉” 而优先输出错误内容。</p>
<hr>
<h3> 3.2 企业场景下，Prompt 最常见的三类失败模式</h3>
<h4> 失败模式一：角色边界缺失</h4>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个描述在自然语言中是清晰的，但对模型来说，信息几乎为零。</p>
<p>问题在于：</p>
<ul>
<li>这个角色是否可以使用常识？（比如用户问 “打印机坏了怎么办”，是否可以推荐 “重启试试” 这种通用经验？）</li>
<li>是否可以综合多份资料？（比如用户问 “跨部门协作流程”，是否允许整合《部门沟通规范》和《项目管理手册》的内容？）</li>
<li>是否允许推断 “合理但未写明” 的结论？（比如文档说 “员工入职满 1 年可休年假”，是否可以推断 “不满 1 年不可休”？）</li>
</ul>
<blockquote>
<p><strong>没有被否定的行为，都会被模型视为“允许”。</strong></p>
</blockquote>
<p>在企业场景中，这种 “默认允许” 往往是灾难的源头。</p>
<p>比如某公司文档只写了 “经理级以上可申请弹性工作”，模型可能会 “合理推断”“主管级以下不可申请”</p>
<p>但实际上，文档漏写了 “主管级满足条件也可申请”，导致员工权益受损。</p>
<hr>
<h4> 失败模式二：信息来源未被工程化</h4>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从模型视角看：</p>
<ul>
<li>“你所知道的内容” = 训练语料（互联网上的通用知识、其他公司的制度、甚至过时的信息） + 当前上下文（可能包含的部分文档片段）</li>
</ul>
<p>而在企业知识库助手中，我们真正想要的是：</p>
<blockquote>
<p><strong>一个“被严格限制的信息子集”（即 “仅当前提供的公司内部文档”）。</strong></p>
</blockquote>
<p>这也是为什么后续 RAG 的核心价值，并不只是“补充知识”，而是： <strong>缩小生成空间。</strong></p>
<p>举个具体案例：</p>
<p>某公司 2025 年更新了差旅费标准（住宿上限从 800 元调整为 1000 元），但模型训练数据截止到 2024 年。</p>
<p>如果 Prompt 没有严格限制 “仅用提供的 2024 年文档”，当用户问 “出差住宿能报多少” 时，模型会优先输出训练数据中的 800 元</p>
<p>因为对它来说，“旧知识” 比 “新文档片段” 更 “熟悉”。</p>
<hr>
<h4> 失败模式三：输出目标不可判定</h4>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这类 Prompt 最大的问题不是“不清楚”，而是：</p>
<blockquote>
<p><strong>你无法客观判断它有没有答对。</strong></p>
</blockquote>
<p>详细” 是多详细？“相关” 是哪些相关？当输出结果出现时，你只能凭感觉说 “好像对” 或 “好像不对”，但无法用明确的标准验证。</p>
<p>一旦输出目标不可判定：</p>
<ul>
<li>系统无法测试（无法写自动化用例验证 “是否符合详细说明的要求”）</li>
<li>系统无法评估（无法量化 “回答准确率”，只能靠人工主观打分）</li>
<li>系统也无法迭代（不知道改 Prompt 后是变好还是变坏）</li>
</ul>
<p>例如，当用户问 “报销流程有几步” 时，“详细说明” 可能输出 “先填单、再审批、最后报销”（3 步），也可能输出 “填单需附发票、审批分部门和财务、报销到账约 3 天”（包含额外信息）。</p>
<p>这两种输出都符合 “详细”，但前者漏了关键步骤（如 “发票校验”），却无法通过明确规则判定错误。</p>
<hr>
<h3> 3.3 本章小结</h3>
<p>到这里，我们可以给出一个工程层面的总结：</p>
<blockquote>
<p><strong>Prompt 失败的根本原因，不是表达能力不足，而是约束设计不足。</strong></p>
</blockquote>
<p>Prompt 的核心职责不是 “告诉模型该怎么说”（比如 “用专业语气”“分点回答”），而是：</p>
<blockquote>
<p><strong>明确告诉模型：哪些内容是被允许生成的，哪些不是。</strong></p>
</blockquote>
<p>既然我们已经找到了 Prompt 失败的根源是 “约束设计不足”，那么解决方案就不再是 “优化措辞”，而是构建一套系统化的约束框架。Prompt 不应该是零散的指令集合，而需要有稳定、可复用的结构来承载这些约束</p>
<p>—— 这正是第 4 章要探讨的核心：如何通过工程化的结构设计，让 Prompt 真正成为可靠的 “约束系统”。</p>
]]></content:encoded>
    </item>
    <item>
      <title>第 4 章：Prompt 的工程化结构设计</title>
      <link>https://ppai.top/ai-guides/tutorial/hello-llm/08.Prompt%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1.html</link>
      <guid>https://ppai.top/ai-guides/tutorial/hello-llm/08.Prompt%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">第 4 章：Prompt 的工程化结构设计</source>
      <description>既然 Prompt 的本质是“约束生成空间”，那么它就不应该是随意拼接的字符串，而应该具备清晰、稳定、可复用的结构。 4.1 Prompt 为什么必须结构化？ 请思考一个问题： 如果 Prompt 改了一句话，系统行为发生了明显变化， 这是好事，还是坏事？ 在工程视角下，这通常是一个危险信号。 因为它意味着： 行为不可预测（改一个词就 “性情大变”，说明系统没有稳定的约束逻辑） 改动影响范围不可控（不知道改这句话会让哪些场景的输出出错）</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 12:45:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>既然 Prompt 的本质是“约束生成空间”，那么它就不应该是随意拼接的字符串，而应该具备清晰、稳定、可复用的结构。</p>
<hr>
<h3> 4.1 Prompt 为什么必须结构化？</h3>
<p>请思考一个问题：</p>
<blockquote>
<p>如果 Prompt 改了一句话，系统行为发生了明显变化， 这是好事，还是坏事？</p>
</blockquote>
<p>在工程视角下，这通常是一个<strong>危险信号</strong>。</p>
<p>因为它意味着：</p>
<ul>
<li>行为不可预测（改一个词就 “性情大变”，说明系统没有稳定的约束逻辑）</li>
<li>改动影响范围不可控（不知道改这句话会让哪些场景的输出出错）</li>
</ul>
<p>结构化 Prompt 的目标正是：</p>
<blockquote>
<p><strong>让系统行为的变化，来源于“有意识的设计”，
而不是偶然的文本差异。</strong></p>
</blockquote>
<p>例如，当你想调整 “是否允许模型使用外部知识” 时，只需要修改 “约束/Constraints” 部分的某一条规则，而不是在整个 Prompt 中 “凭感觉加一句话”—— 这样的改动可预期、可追溯。</p>
<hr>
<h3> 4.2 一个可解释、可扩展的 Prompt 结构</h3>
<p>在企业知识库助手中，我们采用如下四段式结构：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这四部分分别解决四个不同的问题：</p>
<ul>
<li>我是谁？（Role：明确模型的 “权限范围” 和 “责任边界”，避免越权行为）</li>
<li>我要做什么？（Task：锁定当前任务的核心目标，避免答非所问）</li>
<li>我不能做什么？（Constraints：划出 “红线”，禁止可能导致错误的行为）</li>
<li>我的结果如何被判断？（Output Schema：定义输出的格式和标准，让 “对 / 错” 可量化）</li>
</ul>
<p>这个结构的优势在于：</p>
<ul>
<li>可解释性：任何一个环节的设计都有明确目的，便于团队协作理解</li>
<li>可扩展性：需要新增约束时，直接在对应部分补充即可，无需重构整体</li>
<li>可测试性：每一部分都能单独验证（比如测试 Constraints 是否有效阻止了幻觉）</li>
</ul>
<hr>
<h3> 4.3 将结构落地到企业知识库助手（深入示例）</h3>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意这里的几个关键设计细节：</p>
<ul>
<li><strong>Role 部分的权责绑定</strong>：不仅说了 “是什么”，还明确了 “不是什么”（没有权限访问未公开信息），从源头限制模型的 “越界冲动”。</li>
<li><strong>Task 部分的冲突处理</strong>：提前定义 “资料冲突时需全部列出”，避免模型 “主观选择” 一个更 “合理” 的答案（而忽略真实的资料矛盾）。</li>
<li><strong>Constraints 中的 “禁止推断”</strong>：在企业场景中，“资料没说 = 不能确定”，比如资料只写了 “销售部可享受 XX 福利”，模型不能推断 “其他部门不可享受”（可能只是资料漏写）。</li>
<li><strong>Output Schema 的可验证性</strong>：通过 “标注资料编号”，用户可以直接回溯原始资料验证答案；冲突处理的格式要求，让 “矛盾信息” 一目了然，避免误导。</li>
</ul>
<p>其中最核心的设计是：</p>
<blockquote>
<p><strong>“不知道”被明确列为一种合法输出。</strong></p>
</blockquote>
<p>这一步对于企业系统至关重要，因为它第一次从 Prompt 层面：</p>
<blockquote>
<p><strong>压缩了幻觉出现的空间。</strong></p>
</blockquote>
<p>模型会意识到：“说不知道” 是被允许的，甚至是更安全的选择，而不是必须 “强行给一个答案”。</p>
<hr>
<h3> 4.4 Prompt 结构如何影响生成空间（示意图）</h3>
<figure><img src="/imgs/column/llm/08-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这个示意图的核心逻辑是：</p>
<ul>
<li>Role 和 Task 先框定 “大致范围”（比如 “企业知识库助手”+“回答资料相关问题”）</li>
<li>Constraints 像 “过滤器” 一样压缩空间（去掉 “外部知识”“推断内容” 等无效区域）</li>
<li>Output Schema 最后筛选出 “符合格式标准” 的输出（确保结果可评估）</li>
</ul>
<p>最终的 “可生成空间” 越小、越明确，LLM 输出的可靠性就越高。</p>
<p>结构化 Prompt 解决了 “单次调用” 的约束问题，但在真实的企业系统中，Prompt 不会是 “一劳永逸” 的 —— 新业务场景会要求新增约束，多部门复用会需要灵活适配，版本迭代会需要追溯变更。这意味着 Prompt 不能只停留在 “设计” 层面，还需要进入工程化的治理体系，像代码一样被管理、被复用、被迭代 —— 这正是第 5 章要聚焦的 “从 Prompt 到 Prompt 模板与工程治理”。</p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/llm/08-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>第 5 章：从 Prompt 到 Prompt 模板与工程治理</title>
      <link>https://ppai.top/ai-guides/tutorial/hello-llm/09.Prompt%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%B7%A5%E7%A8%8B%E6%B2%BB%E7%90%86.html</link>
      <guid>https://ppai.top/ai-guides/tutorial/hello-llm/09.Prompt%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%B7%A5%E7%A8%8B%E6%B2%BB%E7%90%86.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">第 5 章：从 Prompt 到 Prompt 模板与工程治理</source>
      <description>当你的系统开始被真实用户使用时，你会很快发现： Prompt 不是一次性工作（初期设计总会有遗漏，比如没考虑 “资料重复” 的处理） Prompt 会不断演进（新的业务场景出现，需要新增约束；模型升级后，可能需要调整规则） 而且每一次修改，都可能悄悄改变系统行为 这意味着： Prompt 必须进入工程治理体系。 5.1 Prompt 是“软代码”，而不是文案 在很多早期项目中，Prompt 往往以这样的形式存在：</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 13:45:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>当你的系统开始被真实用户使用时，你会很快发现：</p>
<ul>
<li>Prompt 不是一次性工作（初期设计总会有遗漏，比如没考虑 “资料重复” 的处理）</li>
<li>Prompt 会不断演进（新的业务场景出现，需要新增约束；模型升级后，可能需要调整规则）</li>
<li>而且每一次修改，都可能悄悄改变系统行为</li>
</ul>
<p>这意味着：</p>
<blockquote>
<p><strong>Prompt 必须进入工程治理体系。</strong></p>
</blockquote>
<hr>
<h3> 5.1 Prompt 是“软代码”，而不是文案</h3>
<p>在很多早期项目中，Prompt 往往以这样的形式存在：</p>
<ul>
<li>写在代码里的一段字符串</li>
<li>存在 Notion / 文档中的一段描述</li>
<li>甚至只存在于某个同事的“经验里”</li>
</ul>
<p>这在 Demo 阶段或许还能接受，但在企业知识库助手这样的系统中，这是<strong>极其危险的</strong>。</p>
<p>如在企业知识库助手中：</p>
<ul>
<li>Prompt 的一次微调（比如删掉 “禁止推断”）</li>
<li>可能直接影响业务决策（员工根据错误推断的内容执行操作）</li>
</ul>
<p>这种不可控性，很容易产生不可预知的后果，而产生这些问题的原因也很简单：</p>
<ul>
<li>
<p>Prompt 决定模型的<strong>行为边界</strong></p>
</li>
<li>
<p>Prompt 的一次微调，可能直接影响：</p>
<ul>
<li>回答是否合规</li>
<li>是否产生幻觉</li>
<li>是否越权推断</li>
</ul>
</li>
</ul>
<p>从工程视角看，你必须接受一个事实：</p>
<blockquote>
<p><strong>Prompt 是一种“软代码（Soft Code）”。</strong></p>
</blockquote>
<p>它和代码的区别只在于：</p>
<ul>
<li>不是由编译器执行</li>
<li>而是由模型“解释执行”</li>
</ul>
<p>因此你需要像对待代码一样对待 Prompt：</p>
<ul>
<li>版本管理：记录每一次修改的时间、修改人、修改原因（例如 “v1.2 新增‘资料冲突处理规则’，解决财务制度矛盾问题”）</li>
<li>可回滚：当某次修改导致错误率上升时，能快速切回上一个稳定版本</li>
<li>可审计：在出现问题时，能追溯到某版 Prompt 的设计逻辑，分析漏洞来源</li>
</ul>
<hr>
<h3> 5.2 什么是 Prompt 模板？（不是字符串复用）</h3>
<p>很多人第一次听到“Prompt 模板”时，会误以为：</p>
<blockquote>
<p><em>不就是把 Prompt 抽成一个格式化字符串吗？</em></p>
</blockquote>
<p>这只是最表层的理解。</p>
<p>更准确地说：</p>
<blockquote>
<p><strong>Prompt 模板是一种“设计决策的结构化表达”。</strong></p>
</blockquote>
<p>它的核心目标不是复用文本，而是<strong>固定认知结构</strong>。</p>
<h4> 一个最小但正确的 Prompt 模板结构</h4>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意：
这里的每一块，并不是为了“好看”，而是为了<strong>工程可控性</strong>。</p>
<p>在工程实践中，这意味着：</p>
<ul>
<li>Prompt 可以被 review：团队成员能清晰看到 “Role/Task/Constraints” 等模块的设计，针对性提出意见（比如 “Constraints 漏了‘禁止修改数字’”）</li>
<li>Prompt 可以被测试：通过填充不同变量（如不同的 reference_materials），编写自动化用例验证 “是否符合约束”（例如用例 1：输入无相关资料的问题，检查是否输出 “不知道”）</li>
<li>Prompt 变化是可追踪的：当需要调整时，只需修改对应模块的变量（如更新 constraints 列表），而不是改写整个 Prompt，确保改动可预期</li>
</ul>
<p>例如，针对不同部门的知识库（如 “人力资源”“财务”），可以通过填充不同的 role 变量（“你是人力资源知识库助手，专注于考勤、福利等制度”），实现 “一套模板，多场景复用”，同时保持核心约束的一致性。</p>
<hr>
<h3> 5.3 Prompt 模板解决的，其实是“无意识漂移”</h3>
<p>Prompt 最危险的地方在于：<strong>它可以在不被察觉的情况下改变系统行为。</strong></p>
<p>例如：</p>
<ul>
<li>新增一句“请尽量详细说明”</li>
<li>删除一句“不确定时请说明不知道”</li>
<li>调整一下角色描述语气</li>
</ul>
<p>这些修改往往是：</p>
<ul>
<li>出于好意</li>
<li>为了解决一个局部问题</li>
</ul>
<p>但它们可能导致：</p>
<blockquote>
<p><strong>整个系统的行为分布发生变化。</strong></p>
</blockquote>
<p>Prompt 模板的真正价值就在于：</p>
<blockquote>
<p><strong>把“为什么要这么写”固化成结构，而不是留在人的记忆里。</strong></p>
</blockquote>
<hr>
<h3> 5.4 Prompt 模板在系统中的位置（结构图）</h3>
<p>下面这张图非常关键，它说明了 Prompt 在整个 LLM 系统中的真实位置：</p>
<figure><img src="/imgs/column/llm/09-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这意味着：</p>
<ul>
<li>Prompt <strong>不是直接对着模型写的</strong></li>
<li>而是：
<ul>
<li>介于「业务意图」与「模型行为」之间的<strong>中间层</strong></li>
</ul>
</li>
</ul>
<p>它是<strong>第一道、也是最脆弱的一道约束机制</strong>。</p>
<hr>
<h3> 5.5 Prompt 工程 ≠ Prompt 治理</h3>
<p>到这里，很多读者会产生一个误解：</p>
<blockquote>
<p><em>“那我只要设计一个好模板就行了？”</em></p>
</blockquote>
<p>答案是：<strong>远远不够。</strong></p>
<p>Prompt 工程解决的是：</p>
<ul>
<li><strong>如何设计一次合理的约束</strong></li>
</ul>
<p>而 Prompt 治理要解决的是：</p>
<ul>
<li><strong>这些约束如何在时间维度上不被破坏</strong></li>
</ul>
<hr>
<h4> 一个典型的 Prompt 失控路径</h4>
<figure><img src="/imgs/column/llm/09-2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>注意：
这条路径中，<strong>没有任何一步是“错误操作”</strong>。</p>
<p>但最终结果却是：</p>
<ul>
<li>行为不可预测</li>
<li>无法解释为什么“最近变差了”</li>
</ul>
<hr>
<h3> 5.6 工程治理中的 Prompt 最佳实践</h3>
<p>在企业级 LLM 应用中，Prompt 至少应当具备以下治理能力：</p>
<h4> 1️. Prompt 必须版本化</h4>
<ul>
<li>
<p>每一次修改都有版本号</p>
</li>
<li>
<p>可以明确回答：</p>
<blockquote>
<p>“这个行为是从哪个版本开始变化的？”</p>
</blockquote>
</li>
</ul>
<h4> 2. Prompt 必须可审计</h4>
<ul>
<li>
<p>你要能回答：</p>
<ul>
<li>谁改的？</li>
<li>为什么改？</li>
<li>解决什么问题？</li>
</ul>
</li>
</ul>
<h4> 3️. Prompt 必须可测试</h4>
<ul>
<li>
<p>至少要能在一组固定输入上：</p>
<ul>
<li>对比修改前 / 后输出差异</li>
</ul>
</li>
</ul>
<h4> 4. Prompt 只负责“静态约束”</h4>
<ul>
<li>
<p>不要试图在 Prompt 中：</p>
<ul>
<li>记忆历史</li>
<li>管理状态</li>
<li>承载大量知识</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Prompt 的职责边界越清晰，系统就越稳定。</strong></p>
</blockquote>
<hr>
<h3> 5.7 Prompt 模板示例（工程化）</h3>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个模板的价值不在于“写得好不好”，而在于：</p>
<ul>
<li>行为边界清晰</li>
<li>失败路径明确</li>
<li>可被团队理解与维护</li>
</ul>
<h3> 5.3 本部分总结：Prompt 是约束，不是智能来源</h3>
<p>通过这一部分，你应该已经建立起这样一种认知：</p>
<ul>
<li>Prompt 不是魔法</li>
<li>Prompt 也不是文案</li>
<li>Prompt 更不是“越复杂越好”</li>
</ul>
<p>而是：</p>
<blockquote>
<p><strong>LLM 系统中的第一层行为约束机制。</strong></p>
</blockquote>
<p>但你也应该已经隐约意识到一个事实：</p>
<blockquote>
<p>即使 Prompt 再稳定，
只要对话持续、信息累积，
系统仍然会开始失控。</p>
</blockquote>
<p>这并不是 Prompt 设计的问题，而是<strong>上下文与记忆无法靠 Prompt 解决</strong>的问题。</p>
<hr>
<blockquote>
<p><strong>下一部分，我们将进入 Context 与 Memory：
为什么“对话一变长，系统就一定会出问题”？</strong></p>
</blockquote>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/llm/09-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>第三部分｜上下文与记忆：让企业知识库助手在时间维度上可靠</title>
      <link>https://ppai.top/ai-guides/tutorial/hello-llm/10.%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%20%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E8%AE%B0%E5%BF%86.html</link>
      <guid>https://ppai.top/ai-guides/tutorial/hello-llm/10.%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%20%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E8%AE%B0%E5%BF%86.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">第三部分｜上下文与记忆：让企业知识库助手在时间维度上可靠</source>
      <description>本部分目标： 解释一个几乎所有真实 LLM 系统都会遇到的问题：为什么对话一变长，系统就开始失控？ 引入并系统化「Context Engineering（上下文工程）」这一核心思想 让企业知识库助手从“单轮可用”，升级为“多轮可信” 在第二部分中，我们通过 Prompt 工程为模型建立了单次生成层面的约束—— 比如明确系统角色、限定回答范围、规范输出格式等。这些方法在单轮对话中往往能取得不错的效果：用户问一个问题，系统基于设定的规则和知识库给出答案，看起来既准确又可靠。</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 13:55:07 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本部分目标：</p>
<ul>
<li>解释一个几乎所有真实 LLM 系统都会遇到的问题：<strong>为什么对话一变长，系统就开始失控？</strong></li>
<li>引入并系统化「Context Engineering（上下文工程）」这一核心思想</li>
<li>让企业知识库助手从“单轮可用”，升级为“多轮可信”</li>
</ul>
</blockquote>
<p>在第二部分中，我们通过 Prompt 工程为模型建立了单次生成层面的约束—— 比如明确系统角色、限定回答范围、规范输出格式等。这些方法在单轮对话中往往能取得不错的效果：用户问一个问题，系统基于设定的规则和知识库给出答案，<em>看起来</em>既准确又可靠。</p>
<p>但如果你真正将企业知识库助手投入实际使用，很快就会收到用户这样的反馈：“一开始回答得挺准的，多聊几句就越来越离谱了。”</p>
<p>这并非 Prompt 突然失效，也不是模型能力下降，而是当对话从 “单轮” 进入 “多轮”，系统面临了一个全新的<strong>挑战维度 —— 时间</strong>。</p>
<p>在持续交互中，历史信息的累积会逐渐改变模型的输入环境，进而打破最初设定的约束边界。</p>
<p>接下来，我们将从上下文窗口的本质出发，逐步拆解多轮对话失控的根源，最终落地一套可工程化的上下文管理方案。</p>
]]></content:encoded>
    </item>
    <item>
      <title>第 6 章：上下文窗口的真实边界</title>
      <link>https://ppai.top/ai-guides/tutorial/hello-llm/11.%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AA%97%E5%8F%A3%E7%9A%84%E7%9C%9F%E5%AE%9E%E8%BE%B9%E7%95%8C.html</link>
      <guid>https://ppai.top/ai-guides/tutorial/hello-llm/11.%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AA%97%E5%8F%A3%E7%9A%84%E7%9C%9F%E5%AE%9E%E8%BE%B9%E7%95%8C.html</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">第 6 章：上下文窗口的真实边界</source>
      <description>在讨论“记忆”之前，我们必须先回答一个技术决策层面的问题： 当用户开始连续提问时，我们是否应该“尽量多地保留历史对话”？ 很多团队在这个问题上的直觉答案是： 当然要保留，历史越完整，模型越能理解上下文，回答自然更准确 但这一章要做的事情，正是推翻这个直觉 —— 因为 “全量保留历史” 不仅无法解决问题，反而会埋下系统失控的隐患。</description>
      <category>LLM</category>
      <pubDate>Tue, 30 Dec 2025 14:05:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>在讨论“记忆”之前，我们必须先回答一个<strong>技术决策层面的问题</strong>：</p>
<blockquote>
<p><strong>当用户开始连续提问时，我们是否应该“尽量多地保留历史对话”？</strong></p>
</blockquote>
<p>很多团队在这个问题上的直觉答案是：</p>
<blockquote>
<p><em>当然要保留，历史越完整，模型越能理解上下文，回答自然更准确</em></p>
</blockquote>
<p>但这一章要做的事情，正是<strong>推翻这个直觉</strong> —— 因为 “全量保留历史” 不仅无法解决问题，反而会埋下系统失控的隐患。</p>
<hr>
<h3> 6.1 一个常被忽略的事实：上下文不是记忆</h3>
<p>在 LLM 的 API 交互中，我们通常通过 messages 参数传入对话历史，格式类似这样：</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这很容易让人产生一个工程误判：</p>
<blockquote>
<p>“只要我把历史消息都塞进去，模型就能记住一切。”</p>
</blockquote>
<p>但如果回到第一部分对 LLM 本质 —— <strong><code>token</code>序列的概率预测模型</strong> —— 的分析，你会发现：</p>
<ul>
<li>模型接收的所有上下文（包括系统提示、用户提问、历史回答）会被<strong>一次性拼接成一个长 <code>token</code> 序列</strong>（比如上述示例会变成 “<code>&lt;system&gt;</code>你是企业知识库助手...<code>&lt;user&gt;</code>请问年假怎么申请？<code>&lt;assistant&gt;</code>需通过 OA 系统...”）</li>
<li>它并不知道哪些是“历史”，哪些是“当前”（即它只会基于整个序列的统计规律预测下一个 token）</li>
<li>更不知道哪些信息<strong>在工程上更重要</strong>（比如 “仅回答内部政策”），哪些是 “临时的无关信息”。</li>
</ul>
<p>因此，一个关键认知是：</p>
<blockquote>
<p><strong>上下文只是输入数据，而不是记忆机制。</strong></p>
</blockquote>
<p>人类的记忆会主动筛选、分层、关联信息，而上下文只是无序的信息堆砌。</p>
<hr>
<h3> 6.2 上下文窗口的三个硬限制（为什么“全塞进去”一定会失败）</h3>
<p>即使你愿意无条件保留所有历史，对话系统也会很快撞上三个不可绕过的限制：</p>
<ol>
<li><strong>长度上限</strong>：超过窗口，信息会被直接截断</li>
</ol>
<p>所有 LLM 都有明确的 token 长度限制（比如 GPT-3.5 为 4k token，GPT-4 基础版为 8k token，增强版为 128k token）。当历史对话累积的 token 数超过这个上限时，系统只能通过 “截断” 处理（通常是删除最早的内容），这会直接导致早期关键信息（比如系统约束）丢失。举例：如果系统提示包含</p>
<p><em>“禁止回答外部政策”，但随着对话变长，这条约束被挤出窗口，模型就可能开始回答无关内容。</em></p>
<ol start="2">
<li><strong>注意力衰减</strong>：越靠前的信息，影响力越弱</li>
</ol>
<p><em>举例：用户在第 1 轮提到 “我是市场部员工”，到第 10 轮询问报销政策时，模型可能已经 “忽略” 了这个身份信息，给出了不适用的规则。</em></p>
<ol start="3">
<li><strong>成本与延迟</strong>：token 越多，系统越慢、越贵</li>
</ol>
<p>LLM 的调用成本（按 token 计费）和响应延迟与上下文长度正相关。全量保留历史会导致每轮对话的 token 数持续增长，直接推高系统成本（可能是初始成本的 10 倍以上），同时延长用户等待时间（从几百毫秒增至几秒）。</p>
<p>这些限制最终会导致一个危险的后果：</p>
<blockquote>
<p><strong>最早写下的系统约束（比如 “仅用知识库内容回答”“不泄露隐私”），反而最先失效。</strong></p>
</blockquote>
<hr>
<h3> 6.3 技术决策的失败路径：对话为什么会“慢慢跑偏”？</h3>
<p>当我们坚持 “全量保留历史对话” 时，对话系统会沿着一条可预见的路径逐渐失控，我们可以用一个流程图来理解这个过程：</p>
<figure><img src="/imgs/column/llm/11-1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这并不是模型突然变差，而是系统在时间维度上<strong>失去了对约束的控制权</strong>。每一轮对话都会让关键规则的影响力减弱一分，直到最后完全失效。</p>
<p><em>比如，一个初始设定为 “仅回答薪酬相关问题” 的助手，在多轮对话后可能会开始回应 “公司地址”“产品价格” 等无关内容 —— 不是它 “忘记” 了规则，而是规则在上下文序列中被稀释到几乎无法影响预测结果。</em></p>
<hr>
<h3> 6.4 本章小结：一个必须接受的结论</h3>
<p>通过本章的分析，我们可以得出一个明确的结论：</p>
<ul>
<li>“尽量保留所有上下文”是一个<strong>工程反模式(Anti-pattern)</strong>，它会导致约束失效、成本飙升、体验下降。</li>
<li>上下文窗口无法承担“长期记忆”的职责，其本质上是 “一次性输入缓冲区”</li>
</ul>
<p>既然全量保留不可行，那自然会引出下一个问题：</p>
<blockquote>
<p><strong>如果不能无脑堆上下文，那我们到底该保留什么？</strong></p>
</blockquote>
<p>这正是下一章要解决的核心问题 —— 从 “被动堆积上下文” 转向 “主动管理上下文”。</p>
]]></content:encoded>
      <enclosure url="https://ppai.top/ai-guides/imgs/column/llm/11-1.webp" type="image/webp"/>
    </item>
    <item>
      <title>LLM应用开发</title>
      <link>https://ppai.top/ai-guides/tutorial/hello-llm/</link>
      <guid>https://ppai.top/ai-guides/tutorial/hello-llm/</guid>
      <source url="https://ppai.top/ai-guides/rss.xml">LLM应用开发</source>
      <description>LLM应用开发:零基础也可以入门的大模型应用开发教程 前言 为什么你“会用 LLM”，但做不出复杂应用？ 为什么调得好 Prompt ≠ 系统就稳定？ 为什么多数 Demo 无法上线？ 本书解决什么问题、不解决什么问题 本书的学习路径说明 你需要什么基础？ 每一模块学完你“能做什么” 推荐的学习与实践方式 第一部分｜重新认识 LLM：不是模型问题，而是系统问题</description>
      <pubDate>Thu, 22 Jan 2026 08:45:40 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>LLM应用开发:零基础也可以入门的大模型应用开发教程</p>
</blockquote>
<h1> 前言</h1>
<h3> 为什么你“会用 LLM”，但做不出复杂应用？</h3>
<ul>
<li>为什么调得好 Prompt ≠ 系统就稳定？</li>
<li>为什么多数 Demo 无法上线？</li>
<li>本书解决什么问题、不解决什么问题</li>
</ul>
<h3> 本书的学习路径说明</h3>
<ul>
<li>你需要什么基础？</li>
<li>每一模块学完你“能做什么”</li>
<li>推荐的学习与实践方式</li>
</ul>
<hr>
<h1> 第一部分｜重新认识 LLM：不是模型问题，而是系统问题</h1>
<blockquote>
<p><strong>目标：建立“工程师视角”的 LLM 认知模型</strong></p>
</blockquote>
<hr>
<h2> 第 1 章：LLM 到底在做什么？（程序员版认知重建）</h2>
<h3> 1.1 一个反直觉的问题：LLM 真的“理解”语言吗？</h3>
<ul>
<li>如果它不理解，为什么还能推理？</li>
<li>“下一个 token 预测”到底意味着什么？</li>
</ul>
<h3> 1.2 从函数视角理解 LLM</h3>
<ul>
<li>LLM ≈ <code>f(context) → token</code></li>
<li>为什么上下文就是一切？</li>
<li>为什么 prompt 是“代码”？</li>
</ul>
<p>📊 <strong>图：Token 预测与采样机制示意图（mermaid）</strong></p>
<hr>
<h3> 1.3 你必须接受的事实：LLM 天生不可靠</h3>
<ul>
<li>什么是幻觉？为什么无法彻底消除？</li>
<li>“不知道”为什么是最难的答案？</li>
</ul>
<p>📊 <strong>图：无约束生成 vs 受约束生成对比图</strong></p>
<hr>
<h3> 1.4 第一性原理总结</h3>
<ul>
<li>LLM 擅长什么？</li>
<li>LLM 永远不该做什么？</li>
<li>哪些问题必须交给系统解决？</li>
</ul>
<hr>
<h2> 第 2 章：模型不是重点，参数才是你真正的控制面板</h2>
<h3> 2.1 一个问题：为什么同一个 Prompt 效果忽好忽坏？</h3>
<ul>
<li>随机性从哪来？</li>
<li>temperature / top_p 在“干什么”？</li>
</ul>
<h3> 2.2 参数 ≠ 配置，而是策略</h3>
<ul>
<li>不同任务的参数决策逻辑</li>
<li>为什么大多数人“乱调参”？</li>
</ul>
<p>📊 <strong>图：任务类型 → 参数决策树</strong></p>
<hr>
<h3> 2.3 API 调用的本质结构</h3>
<ul>
<li>messages 是“状态机”</li>
<li>system role 真正的权力边界</li>
</ul>
<p>🧪 示例：最小多轮对话实现（伪代码）</p>
<hr>
<h1> 第二部分｜Prompt 工程：让模型“稳定干活”的第一道防线</h1>
<blockquote>
<p><strong>目标：从“写提示词”升级为“设计 Prompt 结构”</strong></p>
</blockquote>
<hr>
<h2> 第 3 章：Prompt 为什么会失败？</h2>
<h3> 3.1 一个常见误区：Prompt 写得越长越好？</h3>
<ul>
<li>模糊 ≠ 自由</li>
<li>细节 ≠ 噪声</li>
</ul>
<h3> 3.2 Prompt 的三条工程原则</h3>
<ul>
<li>清晰性</li>
<li>约束性</li>
<li>可复用性</li>
</ul>
<p>📊 <strong>图：坏 Prompt vs 好 Prompt 结构对比</strong></p>
<hr>
<h2> 第 4 章：从 Zero-shot 到 Few-shot 的设计思维</h2>
<h3> 4.1 什么时候你真的需要 Few-shot？</h3>
<ul>
<li>模型不会“猜你的规则”</li>
</ul>
<h3> 4.2 示例驱动 Prompt 的本质</h3>
<ul>
<li>示例是在教模型“判题规则”</li>
</ul>
<p>🧪 示例：文本分类 / 数据抽取 Prompt 演进过程</p>
<hr>
<h2> 第 5 章：Prompt 模板化与工程落地</h2>
<h3> 5.1 为什么 Prompt 必须版本化？</h3>
<ul>
<li>Prompt 就是代码</li>
</ul>
<h3> 5.2 通用 Prompt 模板结构</h3>
<ul>
<li>Role</li>
<li>Task</li>
<li>Constraints</li>
<li>Output Schema</li>
</ul>
<p>📊 <strong>图：Prompt 模板结构图</strong></p>
<hr>
<h1> 第三部分｜上下文与记忆：对话为什么会“失忆”？</h1>
<blockquote>
<p><strong>目标：掌握对话系统设计，而不是堆 messages</strong></p>
</blockquote>
<hr>
<h2> 第 6 章：上下文窗口的真实边界</h2>
<h3> 6.1 上下文不是“无限内存”</h3>
<ul>
<li>Token 成本、性能与遗忘</li>
</ul>
<h3> 6.2 为什么长对话一定会崩？</h3>
<p>📊 <strong>图：上下文窗口滚动与信息丢失示意图</strong></p>
<hr>
<h2> 第 7 章：三种记忆策略的工程取舍</h2>
<h3> 7.1 短期记忆：直接塞上下文</h3>
<h3> 7.2 摘要记忆：用 LLM 管 LLM</h3>
<h3> 7.3 长期记忆：向量化存储历史</h3>
<p>📊 <strong>图：短 / 中 / 长期记忆系统架构对比</strong></p>
<p>🧪 示例：对话摘要生成伪代码</p>
<hr>
<h2> 第 8 章：上下文工程（Context Engineering）</h2>
<h3> 8.1 什么信息值得留下？</h3>
<h3> 8.2 信息如何“压缩但不失真”？</h3>
<h3> 8.3 结构化上下文设计模式</h3>
<p>📊 <strong>图：结构化上下文拼装流程图</strong></p>
<hr>
<h1> 第四部分｜能力扩展：让 LLM 走出“纯聊天”</h1>
<blockquote>
<p><strong>目标：让 LLM 接入真实世界，而不是只会说话</strong></p>
</blockquote>
<hr>
<h2> 第 9 章：为什么单靠 LLM 永远不够？</h2>
<h3> 9.1 知识截止的问题</h3>
<h3> 9.2 无状态的问题</h3>
<h3> 9.3 无执行能力的问题</h3>
<p>📊 <strong>图：LLM 核心缺陷总览</strong></p>
<hr>
<h2> 第 10 章：Function Calling —— LLM 的“决策大脑”</h2>
<h3> 10.1 模型是如何“选择工具”的？</h3>
<h3> 10.2 Schema 设计的关键原则</h3>
<ul>
<li>函数不是越多越好</li>
</ul>
<p>📊 <strong>图：Function Calling 全流程闭环</strong></p>
<p>🧪 示例：天气 / 数据库查询工具调用</p>
<hr>
<h2> 第 11 章：RAG —— 企业级 LLM 的地基</h2>
<h3> 11.1 为什么 RAG 不是“外挂知识库”？</h3>
<h3> 11.2 RAG 解决的是哪一类问题？</h3>
<p>📊 <strong>图：RAG 离线 + 在线全流程图</strong></p>
<hr>
<h3> 11.3 文档 → Chunk → Embedding 的关键设计点</h3>
<ul>
<li>切多大才合理？</li>
<li>为什么分割决定效果上限？</li>
</ul>
<h3> 11.4 检索失败的真实原因</h3>
<ul>
<li>不是模型问题，而是数据问题</li>
</ul>
<p>🧪 示例：最小 RAG 原型（伪代码）</p>
<hr>
<h1> 第五部分｜Agent 思维：从调用模型到构建系统</h1>
<blockquote>
<p><strong>目标：理解“智能体”不是框架，而是架构模式</strong></p>
</blockquote>
<hr>
<h2> 第 12 章：什么是 Agent？它和 Prompt 的本质区别</h2>
<h3> 12.1 为什么 CoT ≠ Agent？</h3>
<h3> 12.2 ReAct / Plan-Execute 的本质抽象</h3>
<p>📊 <strong>图：Agent 推理循环结构图</strong></p>
<hr>
<h2> 第 13 章：一个 Agent 的最小系统结构</h2>
<ul>
<li>输入解析</li>
<li>状态管理</li>
<li>工具调度</li>
<li>结果评估</li>
</ul>
<p>📊 <strong>图：Agent 系统架构全景图</strong></p>
<hr>
<h2> 第 14 章：失败的 Agent 都失败在哪？</h2>
<ul>
<li>无限循环</li>
<li>工具滥用</li>
<li>目标漂移</li>
</ul>
<p>🧪 示例：Agent 失败案例拆解</p>
<hr>
<h1> 第六部分｜实战：从 Demo 到“可上线系统”</h1>
<blockquote>
<p><strong>目标：真正跑起来，而不是只在 Notebook 里成功</strong></p>
</blockquote>
<hr>
<h2> 第 15 章：实战一：可控的多轮对话助手</h2>
<ul>
<li>Prompt + 记忆 + 参数策略</li>
</ul>
<h2> 第 16 章：实战二：企业知识库问答系统（RAG）</h2>
<ul>
<li>文档接入</li>
<li>检索优化</li>
<li>引用溯源</li>
</ul>
<h2> 第 17 章：实战三：工具驱动型 Agent</h2>
<ul>
<li>Function Calling</li>
<li>状态管理</li>
<li>错误恢复</li>
</ul>
]]></content:encoded>
    </item>
  </channel>
</rss>